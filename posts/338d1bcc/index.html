<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="TWTqGRcdm7qMQZ1XqfQLJEwhOaDcUy81paYiE7e3tyw">
  <meta name="msvalidate.01" content="05EA84E81FBC0002CD044701E7E4E569">
  <meta name="baidu-site-verification" content="uuaszSSnES">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"wylu.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":false,"nav":null,"activeClass":"changyan"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="剑指Offer系列刷题笔记总结">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer总结">
<meta property="og:url" content="https://wylu.me/posts/338d1bcc/index.html">
<meta property="og:site_name" content="wylu">
<meta property="og:description" content="剑指Offer系列刷题笔记总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/85361b2d31f9d61a9ac306659ca69f52.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/58cadd0fdd8be83d5702f3d50abd3e7f.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/cda1edfddae568a341e0c80d10953827.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/8e7ab743619ec1b0e2f6b61e4b57a6ef.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/ee3d5a227becfec5b725c133ede3bd48.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/508dae0cb6875456956be8d1d2e7434c.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/271fc1b413a66e12a97f96ab1640df19.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/79529c6a002030ccb5807c770f1b330d.png">
<meta property="article:published_time" content="2019-06-03T02:37:24.000Z">
<meta property="article:modified_time" content="2022-11-23T17:04:10.543Z">
<meta property="article:author" content="lu wenye">
<meta property="article:tag" content="剑指Offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wylu/img/85361b2d31f9d61a9ac306659ca69f52.png">


<link rel="canonical" href="https://wylu.me/posts/338d1bcc/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wylu.me/posts/338d1bcc/","path":"posts/338d1bcc/","title":"剑指Offer总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>剑指Offer总结 | wylu</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155154294-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-155154294-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "enj9prl9r6");
</script>


  <script async defer data-website-id src></script>

  <script defer data-domain src></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="wylu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wylu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Keep It Simple, Stupid</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">67</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">37</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-commenting fa-fw"></i>留言板</a></li><li class="menu-item menu-item-sitelog"><a href="/sitelog/" rel="section"><i class="fa fa-list-alt fa-fw"></i>站点日志</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">二维数组中的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="nav-text">把字符串转换成整数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-text">从尾到头打印链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">二叉树的下一个结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">用两个栈实现队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">算法和数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="nav-text">递归和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">青蛙跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">变态跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96"><span class="nav-text">矩阵覆盖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-text">查找和排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-text">旋转数组的最小数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">矩阵中的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">机器人的运动范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">动态规划与贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">二进制中1的个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text">高质量的代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-text">代码的完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-text">打印1到最大的n位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8o1%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9"><span class="nav-text">在O(1)时间删除链表结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-text">删除链表中重复的结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">正则表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">表示数值的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-text">调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E6%89%A9%E5%B1%95"><span class="nav-text">调整数组顺序使奇数位于偶数前面(扩展)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7"><span class="nav-text">代码的鲁棒性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">链表中倒数第 k 个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-text">链表中环的入口结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-text">合并两个排序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">树的子结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-text">解决面试题的思路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF"><span class="nav-text">面试官谈面试思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">二叉树的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">对称的二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%BB%E5%9B%BE%E8%AE%A9%E6%8A%BD%E8%B1%A1%E9%97%AE%E9%A2%98%E5%BD%A2%E8%B1%A1%E5%8C%96"><span class="nav-text">画图让抽象问题形象化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">顺时针打印矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AE%A9%E6%8A%BD%E8%B1%A1%E9%97%AE%E9%A2%98%E5%85%B7%E4%BD%93%E5%8C%96"><span class="nav-text">举例让抽象问题具体化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-text">包含 min 函数的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">从上到下打印二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">之字形打印二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-text">二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">二叉树中和为某一值的路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%AE%A9%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E7%AE%80%E5%8D%95%E5%8C%96"><span class="nav-text">分解让复杂问题简单化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">复杂链表的复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">序列化二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-text">字符串的排列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87"><span class="nav-text">优化时间和空间效率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87"><span class="nav-text">时间效率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0"><span class="nav-text">最小的 k 个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">数据流中的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">连续子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">从 1 到 n 整数中 1 出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-text">把数组排成最小的数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="nav-text">时间效率与空间效率的平衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%91%E6%95%B0"><span class="nav-text">丑数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-text">第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-text">字符流中第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-text">数组中的逆序对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-text">两个链表的第一个公共结点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B"><span class="nav-text">面试中的各项能力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E8%BF%81%E7%A7%BB%E8%83%BD%E5%8A%9B"><span class="nav-text">知识迁移能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E7%BB%93%E7%82%B9"><span class="nav-text">二叉搜索树的第 k 大结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">二叉树的深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">判断平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中只出现一次的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-text">和为S的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-text">和为S的连续正数序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-text">翻转单词顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">左旋转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">6.1.10 队列的最大值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%BB%BA%E6%A8%A1%E8%83%BD%E5%8A%9B"><span class="nav-text">抽象建模能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-text">n 个骰子的点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-text">扑克牌的顺子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">圆圈中最后剩下的数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E6%95%A3%E6%80%9D%E7%BB%B4%E8%83%BD%E5%8A%9B"><span class="nav-text">发散思维能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82-12...n"><span class="nav-text">求 1+2+...+n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-text">不用加减乘除做加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-text">构建乘积数组</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lu wenye" src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">lu wenye</p>
  <div class="site-description" itemprop="description">Hard work, Dedication and Discipline</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wylu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wylu" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15wylu@gmail.com" title="E-Mail → mailto:15wylu@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32767041" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32767041" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-book fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wylu.me/posts/338d1bcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="lu wenye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wylu">
      <meta itemprop="description" content="Hard work, Dedication and Discipline">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="剑指Offer总结 | wylu">
      <meta itemprop="description" content>
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指Offer总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-03 10:37:24" itemprop="dateCreated datePublished" datetime="2019-06-03T10:37:24+08:00">2019-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-24 01:04:10" itemprop="dateModified" datetime="2022-11-24T01:04:10+08:00">2022-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>剑指Offer系列刷题笔记总结</p>
<span id="more"></span>
<h1 id="数据结构">数据结构</h1>
<h2 id="数组">数组</h2>
<h3 id="数组中重复的数字">数组中重复的数字</h3>
<p><strong>思路：</strong></p>
<p>利用一个辅助数组来表示数字是否已出现过了，如果已出现过则返回当前数字。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuplicateNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">duplicate</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] duplication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[e])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = e;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[e] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;, duplication = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(duplicate(arr, duplication));</span><br><span class="line">        System.out.println(duplication[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">二维数组中的查找</h3>
<p><strong>思路：</strong></p>
<ul>
<li>首先选取数组中右上角的数字。</li>
<li>如果该数字等于要查找的数字，则查找过程结束；</li>
<li>如果该数字大于要查找的数字，则剔除这个数字所在的列；</li>
<li>如果该数字小于要查找的数字，则剔除这个数字所在的行；</li>
<li>直到找到要查找的数字，或者查找范围为空。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows+cols)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDArrayFind</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3 id="替换空格">替换空格</h3>
<p><strong>思路：</strong></p>
<p>先遍历一次字符串，统计出字符串中空格的总数，并由此计算出替换后的字符串的总长度；每替换一个空格，长度就增长 2。</p>
<ul>
<li>准备两个指针：<span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 指向原始字符串的末尾，而 <span class="math inline">\(P_2\)</span> 指向替换之后的字符串的末尾；</li>
<li>接着向前移动指针 <span class="math inline">\(P_1\)</span>，逐个把它指向的字符复制到 <span class="math inline">\(P_2\)</span> 指向的位置，直到碰到空格为止；</li>
<li>碰到空格后，把 <span class="math inline">\(P_1\)</span> 向前移动1格，在 <span class="math inline">\(P_2\)</span> 之前插入字符串 "%20"，由于 "%20" 的长度为 3，同时也要把 <span class="math inline">\(P_2\)</span> 向前移动 3 格；</li>
<li>重复以上步骤，直至 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向同一位置。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> originLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> numOfSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            ++originLen;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) ++numOfSpace;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> indexOfOrigin = originLen;</span><br><span class="line">        <span class="type">int</span> indexOfNew = originLen + numOfSpace * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(indexOfOrigin &lt; indexOfNew)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOfOrigin] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexOfNew--] = str[indexOfOrigin];</span><br><span class="line">            &#125;</span><br><span class="line">            indexOfOrigin--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="把字符串转换成整数">把字符串转换成整数</h3>
<p><strong>思路：</strong></p>
<p>把第一个字符分两种情况对待，第一种为符号位即 '+' 或 '-'，第二种为 '0'-'9' 的数字字符。</p>
<p>从第一个数字字符开始到最后一个字符做如下运算：</p>
<ul>
<li>每次循环将上一次的结果 <code>*</code> 10</li>
<li>然后加上本次循环的字符数字</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<p>未做溢出判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrToInt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">signBit</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (signBit != <span class="string">&#x27;+&#x27;</span> &amp;&amp; signBit != <span class="string">&#x27;-&#x27;</span> &amp;&amp; (signBit &lt; <span class="string">&#x27;0&#x27;</span> || signBit &gt; <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (signBit &gt;= <span class="string">&#x27;0&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            res += (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signBit == <span class="string">&#x27;-&#x27;</span> ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;+2147483647&quot;</span>));</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;4562&quot;</span>));</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;-87904562&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<h3 id="从尾到头打印链表">从尾到头打印链表</h3>
<p><strong>思路：</strong></p>
<p>直接从头到尾遍历链表，将遍历的结点都加入列表中，最后对列表进行逆序操作。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintListFromTailToHead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printListFromTailToHead</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) <span class="keyword">return</span> nodes;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>)&#123;</span><br><span class="line">            nodes.add(pHead.val);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(nodes); <span class="comment">//线性运行时间</span></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="重建二叉树">重建二叉树</h3>
<p><strong>思路：</strong></p>
<ul>
<li>根据前序遍历的第一个数字创建根结点；</li>
<li>接着在中序遍历序列中找到根结点的位置，确定左、右子树的结点数量；</li>
<li>在前序遍历和中序遍历序列中划分了左、右子树结点的值后，递归地调用函数去分别构建它的左、右子树。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReconstructBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructCore</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> startPre, <span class="type">int</span> endPre,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> pre[startPre];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (startPre == endPre) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIn</span> <span class="operator">=</span> startIn;</span><br><span class="line">        <span class="keyword">while</span> (rootIn &lt;= endIn &amp;&amp; in[rootIn] != rootValue) rootIn++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> rootIn - startIn;</span><br><span class="line">        <span class="keyword">if</span> (leftLen &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.left = constructCore(pre, in,</span><br><span class="line">                    startPre+<span class="number">1</span>, startPre+leftLen,</span><br><span class="line">                    startIn, rootIn-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftLen &lt; endPre - startPre)&#123;</span><br><span class="line">            root.right = constructCore(pre, in,</span><br><span class="line">                    startPre+leftLen+<span class="number">1</span>, endPre,</span><br><span class="line">                    rootIn+<span class="number">1</span>, endIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length == <span class="number">0</span> || pre.length != in.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> constructCore(pre, in,</span><br><span class="line">                <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点">二叉树的下一个结点</h3>
<p><strong>思路：</strong></p>
<ul>
<li>如果一个结点有右子树，那么它的下一个结点就是它右子树中的最左结点。</li>
<li>如果一个结点没有右子树，则分两种情况：
<ul>
<li>如果结点是它父结点的左子结点，那么它的下一个结点即为它的父结点。</li>
<li>如果结点是它父结点的右子结点，则可以沿着父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点，如果这样的结点存在，那么这个结点的父结点就是要找的下一个结点。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeLinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">getNext</span><span class="params">(TreeLinkNode pNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeLinkNode pNext;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">pRight</span> <span class="operator">=</span> pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pRight.left != <span class="literal">null</span>) pRight = pRight.left;</span><br><span class="line">            pNext = pRight;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">pCurrent</span> <span class="operator">=</span> pNode, pParent = pNode.next;</span><br><span class="line">            <span class="keyword">while</span> (pParent != <span class="literal">null</span> &amp;&amp; pCurrent == pParent.right)&#123;</span><br><span class="line">                pCurrent = pParent;</span><br><span class="line">                pParent = pCurrent.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNext = pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈和队列">栈和队列</h2>
<h3 id="用两个栈实现队列">用两个栈实现队列</h3>
<p><strong>思路：</strong></p>
<ul>
<li>入队时，直接将元素压入 stack1</li>
<li>出队时分两种情况：
<ul>
<li>若 stack2 不空，则弹出 stack2 栈顶；</li>
<li>若 stack2 为空，则将 stack1 中的元素逐个弹出并压入 stack2，然后再弹出 stack2 栈顶。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> 入队 <span class="math inline">\(O(1)\)</span>，出队 <span class="math inline">\(O(1) \sim O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoStacksToQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法和数据操作">算法和数据操作</h1>
<h2 id="递归和循环">递归和循环</h2>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p><strong>思路：</strong></p>
<p>从下往上计算，首先根据 <span class="math inline">\(f(0)\)</span> 和 <span class="math inline">\(f(1)\)</span> 算出 <span class="math inline">\(f(2)\)</span>，再根据 <span class="math inline">\(f(1)\)</span> 和 <span class="math inline">\(f(2)\)</span> 算出 <span class="math inline">\(f(3)\)</span> ... 以此类推就可以算出第 n 项了。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>, f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="青蛙跳台阶">青蛙跳台阶</h3>
<p><strong>思路：</strong></p>
<p>把 <span class="math inline">\(n\)</span> 级台阶时的跳法看成 <span class="math inline">\(n\)</span> 的函数，记为 <span class="math inline">\(f(n)\)</span>：</p>
<ul>
<li>显然有 <span class="math inline">\(f(1)=1，f(2)=2\)</span></li>
<li>当 <span class="math inline">\(n \gt 2\)</span> 时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrogJumpSteps</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变态跳台阶">变态跳台阶</h3>
<p><strong>思路：</strong></p>
<p><span class="math inline">\(f(n)=2^{n-1}\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrogJumpStepsII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵覆盖">矩阵覆盖</h3>
<p><strong>思路：</strong></p>
<p><span class="math inline">\(f(1)=1，f(2)=2\)</span></p>
<p>当 <span class="math inline">\(n &gt; 2\)</span> 时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectCover</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> f[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = f[<span class="number">1</span>] + f[<span class="number">2</span>];</span><br><span class="line">            f[<span class="number">1</span>] = f[<span class="number">2</span>];</span><br><span class="line">            f[<span class="number">2</span>] = f[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找和排序">查找和排序</h2>
<h3 id="旋转数组的最小数字">旋转数组的最小数字</h3>
<p><strong>思路：</strong></p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 总是指向前面递增的数组的元素，而 <span class="math inline">\(P_2\)</span> 总是指向后面递增数组的元素。</li>
<li>初始时，<span class="math inline">\(P_1\)</span> 指向数组的第一个元素，<span class="math inline">\(P_2\)</span> 指向数组的最后一个元素。</li>
<li>如果 <span class="math inline">\(arr[P_1] \le arr[P_2]\)</span>，则直接进行顺序查找；</li>
<li>如果 <span class="math inline">\(arr[P_1] \gt arr[P_2]\)</span>，则进行如下步骤：
<ul>
<li>找到 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 的中间元素，如果该中间元素位于前面的递增子数组，则把 <span class="math inline">\(P_1\)</span> 指向该中间元素；</li>
<li>如果该中间元素位于后面的递增子数组，则把 <span class="math inline">\(P_2\)</span> 指向该中间元素；</li>
<li>重复以上步骤，直至两个指针相邻时，<span class="math inline">\(P_2\)</span> 指向的元素即为最小的元素。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinNumberInRotateArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2 || arr[p1] &lt; arr[p2]) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] == arr[p2])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[p1]) p1 = i;</span><br><span class="line">            <span class="keyword">return</span> arr[p1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 - p1 != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (p1 + p2) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt;= arr[p1]) p1 = mid;</span><br><span class="line">            <span class="keyword">else</span> p2 = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[p2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯法">回溯法</h2>
<h3 id="矩阵中的路径">矩阵中的路径</h3>
<p><strong>思路：</strong></p>
<p>利用回溯法：</p>
<ul>
<li>首先在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为 ch，并且这个格子将对应于路径上的第 <code>i</code> 个字符。</li>
<li>如果路径上的第 <code>i</code> 个字符不是 ch，那么这个格子不可能处在路径上的第 <code>i</code> 个位置。</li>
<li>如果路径上的第 <code>i</code> 个字符正好是 ch，那么就到相邻的格子寻找路径上的第 <code>i+1</code> 个字符。</li>
<li>除矩阵边界上的格子之外，其它格子都有 4 个相邻的格子。</li>
<li>重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows \ast cols \ast str.length)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixPath</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathCore</span><span class="params">(<span class="type">char</span>[] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] str,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span>[] pathLen, <span class="type">boolean</span>[] visited)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pathLen[<span class="number">0</span>] == str.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPath</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols</span><br><span class="line">                &amp;&amp; matrix[i*cols+j] == str[pathLen[<span class="number">0</span>]]</span><br><span class="line">                &amp;&amp; !visited[i*cols+j])&#123;</span><br><span class="line">            pathLen[<span class="number">0</span>]++;</span><br><span class="line">            visited[i*cols+j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            hasPath = hasPathCore(matrix, rows, cols, i, j-<span class="number">1</span>, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i-<span class="number">1</span>, j, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i, j+<span class="number">1</span>, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i+<span class="number">1</span>, j, str, pathLen, visited);</span><br><span class="line">            <span class="keyword">if</span> (!hasPath)&#123;</span><br><span class="line">                pathLen[<span class="number">0</span>]--;</span><br><span class="line">                visited[i*cols+j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(<span class="type">char</span>[] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows * cols];</span><br><span class="line">        <span class="type">int</span>[] pathLen = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, i, j, str, pathLen, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">机器人的运动范围</h3>
<p><strong>思路：</strong></p>
<p>利用回溯法：</p>
<ul>
<li>机器人从坐标 <code>(0,0)</code> 开始移动。</li>
<li>当它准备进入坐标为 <code>(i,j)</code> 的格子时，通过检查坐标的数位和来判断机器人是否能够进入。</li>
<li>如果机器人能够进入坐标为 <code>(i,j)</code> 的格子，则计数加 1；然后再判断它能否进入右方和下方的格子 <code>(i,j+1)</code>，<code>(i+1,j)</code>。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows*cols)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotMoveArea</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDigitSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols</span><br><span class="line">                &amp;&amp; getDigitSum(i) + getDigitSum(j) &lt;= threshold</span><br><span class="line">                &amp;&amp; !visited[i * cols + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">movingCountCore</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(threshold, rows, cols, i, j, visited)) &#123;</span><br><span class="line">            visited[i*cols+j] = <span class="literal">true</span>;</span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, i, j+<span class="number">1</span>, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, i+<span class="number">1</span>, j, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">return</span> movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划与贪心算法">动态规划与贪心算法</h2>
<h2 id="位运算">位运算</h2>
<h3 id="二进制中1的个数">二进制中1的个数</h3>
<p><strong>思路：</strong></p>
<p>把一个整数减去 1，再和原整数做与运算，会把该整数最右边的 1 变成 0。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOf1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOf1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高质量的代码">高质量的代码</h1>
<h2 id="代码的完整性">代码的完整性</h2>
<h3 id="数值的整数次方">数值的整数次方</h3>
<p><strong>思路：</strong></p>
<p>快速幂</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerWithIntExponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exp)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (exp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="literal">true</span>;</span><br><span class="line">            exp = -exp;</span><br><span class="line">            <span class="keyword">if</span> (base == <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            base *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1.0</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印1到最大的n位数">打印1到最大的n位数</h3>
<p><strong>思路：</strong></p>
<p>如果我们在数字前面补 0，就会发现 n 位所有十进制其实就是 n 个从 0 到 9 的全排列。即如果把数字的每一位都从 0 到 9 排列一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的 0 不打印出来罢了。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(10^n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintToMaxOfNDigits</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">char</span>[] num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isZero</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isZero &amp;&amp; num[i] != <span class="string">&#x27;0&#x27;</span>) isZero = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isZero) System.out.print(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isZero) System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printRecursively</span><span class="params">(<span class="type">char</span>[] num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == num.length - <span class="number">1</span>)&#123;</span><br><span class="line">            printNumber(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[index + <span class="number">1</span>] = (<span class="type">char</span>) (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            printRecursively(num, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintToMaxOfNDigits</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span>[] num = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[<span class="number">0</span>] = (<span class="type">char</span>) (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            printRecursively(num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrintToMaxOfNDigits</span>().PrintToMaxOfNDigits(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在o1时间删除链表结点">在O(1)时间删除链表结点</h3>
<p><strong>思路：</strong></p>
<p>对于 n-1 个非尾结点，可以在 <span class="math inline">\(O(1)\)</span> 时间内把下一个结点的内容复制覆盖要删除的结点，并删除下一个结点；对于尾结点，仍需要顺序查找，然后进行删除，时间复杂度是 <span class="math inline">\(O(n)\)</span>；总的平均时间复杂度为 <span class="math inline">\([(n-1)*O(1)+O(n)]/n\)</span>，结果为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Offer.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(ListNode[] pHead, ListNode[] pDel)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pDel == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pDel[<span class="number">0</span>].next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pDel[<span class="number">0</span>].next;</span><br><span class="line">            pDel[<span class="number">0</span>].val = pNode.val;</span><br><span class="line">            pDel[<span class="number">0</span>].next = pNode.next;</span><br><span class="line">            pNode.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pDel == pHead)&#123;</span><br><span class="line">            pDel[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">            pHead[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (pNode.next != pDel[<span class="number">0</span>]) pNode = pNode.next;</span><br><span class="line">            pNode.next = <span class="literal">null</span>;</span><br><span class="line">            pDel[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中重复的结点">删除链表中重复的结点</h3>
<p><strong>思路：</strong></p>
<p>遍历整个链表：</p>
<ul>
<li>如果当前结点的值与下一个结点的值相同，那么它们都要被删除。</li>
<li>为保证删除后的链表仍是相连的，要把当前结点的前一个结点和后面值比当前结点值大的结点相连。</li>
<li>确保前一个结点始终与下一个没有重复的结点连接在一起。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteDuplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplication</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        first.next = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span> &amp;&amp; pNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode.val == pNode.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> pNode.val;</span><br><span class="line">                <span class="keyword">while</span> (pNode != <span class="literal">null</span> &amp;&amp; pNode.val == val)</span><br><span class="line">                    pNode = pNode.next;</span><br><span class="line">                last.next = pNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last = pNode;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">            pNode.next = tmp;</span><br><span class="line">            pNode = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteDuplication</span>().deleteDuplication(pHead);</span><br><span class="line">        <span class="keyword">while</span> (res != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(res.val);</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">正则表达式匹配</h3>
<p><strong>思路：</strong></p>
<p>根据模式中第二个字符是否为 <code>*</code> 分两种情况考虑：</p>
<ul>
<li>模式中的第二个字符不是 <code>*</code> 时
<ul>
<li>如果字符串中的第一个字符和模式的第一个字符相匹配，则字符串和模式都向后移动一个字符，然后继续匹配剩余字符。</li>
<li>如果字符串中的第一个字符和模式的第一个字符不匹配，则直接返回 false</li>
</ul></li>
<li>模式中的第二个字符是 <code>*</code> 时，有多种匹配模式
<ul>
<li>如果字符串第一个字符和模式第一个字符 <strong>不匹配</strong>，则模式后移两个字符，然后继续匹配剩余字符</li>
<li>如果字符串第一个字符和模式第一个字符 <strong>匹配</strong>，可以有 3 种匹配方式：
<ul>
<li>字符串后移 1 个字符，模式不变</li>
<li>模式后移 2 个字符，相当于 <code>x*</code> 被忽略</li>
<li>字符串后移 1 个字符，模式后移 2 个字符</li>
</ul></li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span>[] str, <span class="type">char</span>[] pattern)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || pattern == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">matchCore</span><span class="params">(<span class="type">char</span>[] str,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> idxStr,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] pattern,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> idxPat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idxStr == str.length &amp;&amp; idxPat == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (idxStr != str.length &amp;&amp; idxPat == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idxPat + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[idxPat + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (idxStr != str.length</span><br><span class="line">                &amp;&amp; (pattern[idxPat] == str[idxStr] || pattern[idxPat] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat + <span class="number">2</span>)</span><br><span class="line">                        || matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat)</span><br><span class="line">                        || matchCore(str, idxStr, pattern, idxPat + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> matchCore(str, idxStr, pattern, idxPat + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idxStr != str.length</span><br><span class="line">            &amp;&amp; (str[idxStr] == pattern[idxPat] || pattern[idxPat] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(match(<span class="string">&quot;aaa&quot;</span>.toCharArray(), <span class="string">&quot;ab*ac*a&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(match(<span class="string">&quot;&quot;</span>.toCharArray(), <span class="string">&quot;.*&quot;</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表示数值的字符串">表示数值的字符串</h3>
<p><strong>思路：</strong></p>
<p>表示数值的字符串遵循模式 <code>A[.[B]][e|EC]</code> 或者 <code>.B[e|EC]</code>，其中：</p>
<ul>
<li>A 为数值的整数部分（可能以 '+' 或 '-' 开头的 0-9 的数位串）</li>
<li>B 紧跟着小数点为数值的小数部分（0-9 的数位串）</li>
<li>C 紧跟 'e' 或 'E' 为数值的指数部分（可能以 '+' 或 '-' 开头的 0-9 的数位串）</li>
</ul>
<p>在小数里可能没有整数部分，如小数 <code>.123</code> 等于 <code>0.123</code>，因此 A 部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsNumeric</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">scanUnsignedInteger</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span>[] idx)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> idx[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (idx[<span class="number">0</span>] &lt; str.length &amp;&amp; str[idx[<span class="number">0</span>]] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[idx[<span class="number">0</span>]] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> idx[<span class="number">0</span>] &gt; startIdx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">scanInteger</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span>[] idx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] &lt; str.length &amp;&amp; (str[idx[<span class="number">0</span>]] == <span class="string">&#x27;+&#x27;</span> || str[idx[<span class="number">0</span>]] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">char</span>[] str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] idx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numeric</span> <span class="operator">=</span> scanInteger(str, idx);</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] != str.length &amp;&amp; str[idx[<span class="number">0</span>]] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">            numeric = scanUnsignedInteger(str, idx) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] != str.length &amp;&amp; (str[idx[<span class="number">0</span>]] == <span class="string">&#x27;e&#x27;</span> || str[idx[<span class="number">0</span>]] == <span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(str, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; idx[<span class="number">0</span>] == str.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;.123&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;123.&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;.e2&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;12e&quot;</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</h3>
<p><strong>思路：</strong></p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 指向数组的第一个数字，<span class="math inline">\(P_2\)</span> 指向最后一个数字；</li>
<li><span class="math inline">\(P_1\)</span> 向后移动直至它指向偶数；</li>
<li><span class="math inline">\(P_2\)</span> 向前移动直至它指向奇数；</li>
<li>交换 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向的元素；</li>
<li>直到 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 相遇。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderOddEven</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderOddEven</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; (arr[p1] &amp; <span class="number">1</span>) == <span class="number">1</span>) p1++;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; (arr[p2] &amp; <span class="number">1</span>) == <span class="number">0</span>) p2--;</span><br><span class="line">            <span class="keyword">if</span> (p1 &lt; p2) swap(arr, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面扩展">调整数组顺序使奇数位于偶数前面(扩展)</h3>
<p>调整后保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>思路：</strong></p>
<p>空间换时间</p>
<ul>
<li>遍历两次数组，第一次遍历时将全部的奇数按顺序保存到辅助数组；</li>
<li>第二次遍历时将全部的偶数按顺序追加到数组尾部。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderOddEvenII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reOrderArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) <span class="keyword">if</span> ((e &amp; <span class="number">1</span>) == <span class="number">1</span>) res[k++] = e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) <span class="keyword">if</span> ((e &amp; <span class="number">1</span>) == <span class="number">0</span>) res[k++] = e;</span><br><span class="line">        System.arraycopy(res, <span class="number">0</span>, arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码的鲁棒性">代码的鲁棒性</h2>
<h3 id="链表中倒数第-k-个结点">链表中倒数第 k 个结点</h3>
<p><strong>思路：</strong></p>
<blockquote>
<p>假设整个链表有 n 个结点，那么倒数第 k 个结点就是从头结点开始的第 n-k+1 个结点。</p>
<ul>
<li>遍历一次链表，得到链表长度 n；</li>
<li>第二次遍历时，从头结点开始指针前进 n-k+1 步，即为倒数第 k 个结点。</li>
</ul>
</blockquote>
<p>上面的方法需要遍历两次链表，但我们有只需要遍历一次链表的解法。</p>
<ul>
<li>定义两个指针，第一个指针从链表的头指针开始遍历向前走 k-1 步，第二个指针保持不动；</li>
<li>从第 k 步开始，第二个指针也开始从链表的的头指针开始遍历；</li>
<li>由于两个指针的距离保持在 k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个（走在后面的）指针正好指向倒数第 k 个结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindKthToTail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findKthToTail</span><span class="params">(ListNode pHead, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> pHead, p2 = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span> &amp;&amp; p1 != <span class="literal">null</span>; i++) p1 = p1.next;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中环的入口结点">链表中环的入口结点</h3>
<p><strong>思路：</strong></p>
<p>第一步确定一个链表中是否包含环</p>
<ul>
<li>定义两个指针，同时从链表头结点出发，一个指针一次走一步，另一个指针一次走两步；</li>
<li>如果走得快的指针追上了走得慢的指针，那么链表就包含环；</li>
<li>如果走得快的指针到了链表末尾也没有追上第一个指针，那么链表就不包含环。</li>
</ul>
<p>第二步统计环中的结点数</p>
<ul>
<li>两个指针相遇的结点一定是在环中的，可以从这个结点出发；</li>
<li>一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了。</li>
</ul>
<p>第三步找到环的入口</p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向链表头结点，如果链表中的环有 n 个结点，则指针 <span class="math inline">\(P_1\)</span> 先在链表上向前移动 n 步；</li>
<li>然后两个指针以相同的速度向前移动；</li>
<li>当两个指针相遇时，指针指向的结点即为环的入口结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntryNodeOfLoop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">meetingNode</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pSlow</span> <span class="operator">=</span> pHead, pFast = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (pFast != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pFast == pSlow) <span class="keyword">return</span> pFast;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            <span class="keyword">if</span> (pFast != <span class="literal">null</span>) pFast = pFast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">entryNodeOfLoop</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">meetNode</span> <span class="operator">=</span> meetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span> (meetNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodesInLoop</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> meetNode;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != meetNode)&#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            nodesInLoop++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode1</span> <span class="operator">=</span> pHead, pNode2 = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodesInLoop; i++) pNode1 = pNode1.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pNode1 != pNode2)&#123;</span><br><span class="line">            pNode1 = pNode1.next;</span><br><span class="line">            pNode2 = pNode2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">EntryNodeOfLoop</span> <span class="variable">entryNodeOfLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntryNodeOfLoop</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node3;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">entryNode</span> <span class="operator">=</span> entryNodeOfLoop.entryNodeOfLoop(node1);</span><br><span class="line">        System.out.println(entryNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表">反转链表</h3>
<p><strong>思路：</strong></p>
<p>定义 3 个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pPrev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        ListNode pNext;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pNext = pNode.next;</span><br><span class="line">            pNode.next = pPrev;</span><br><span class="line">            pPrev = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pPrev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序的链表">合并两个排序的链表</h3>
<p><strong>思路：</strong></p>
<p>把两个链表中值较小的头结点链接到已合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeTwoOrderedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode pResHead;</span><br><span class="line">        <span class="keyword">if</span> (pHead1.val &lt; pHead2.val)&#123;</span><br><span class="line">            pResHead = pHead1;</span><br><span class="line">            pResHead.next = merge(pHead1.next, pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pResHead = pHead2;</span><br><span class="line">            pResHead.next = merge(pHead1, pHead2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pResHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeII</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">        ListNode pResHead, pResEnd, pNode1, pNode2;</span><br><span class="line">        <span class="keyword">if</span> (pHead1.val &lt; pHead2.val)&#123;</span><br><span class="line">            pResHead = pResEnd = pHead1;</span><br><span class="line">            pNode1 = pHead1.next;</span><br><span class="line">            pNode2 = pHead2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pResHead = pResEnd = pHead2;</span><br><span class="line">            pNode1 = pHead1;</span><br><span class="line">            pNode2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode1 != <span class="literal">null</span> &amp;&amp; pNode2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode minNode;</span><br><span class="line">            <span class="keyword">if</span> (pNode1.val &lt; pNode2.val)&#123;</span><br><span class="line">                minNode = pNode1;</span><br><span class="line">                pNode1 = pNode1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                minNode = pNode2;</span><br><span class="line">                pNode2 = pNode2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pResEnd = pResEnd.next = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pResEnd.next = (pNode1 != <span class="literal">null</span>) ? pNode1 : pNode2;</span><br><span class="line">        <span class="keyword">return</span> pResHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的子结构">树的子结构</h3>
<p><strong>思路：</strong></p>
<p>分两步：第一步，在树 A 中找到和树 B 的根结点的值一样的结点 R；第二步，判断树 A 中以 R 为根结点的子树是否包含和树 B 一样的结构。</p>
<p>对于第二步同样可以用递归的思路来考虑：如果结点 R 的值和树 B 的根结点不同，则以 R 为根结点的子树和树 B 肯定不具有相同的结点；如果它们的值相同，则递归地判断它们各自的左右结点的值是不是相同。递归终止的条件是我们达到了树 A 或者树 B 的叶子结点。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n*m)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasSubTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doesTree1HaveTree2</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1.val == pRoot2.val)</span><br><span class="line">            <span class="keyword">return</span> doesTree1HaveTree2(pRoot1.left, pRoot2.left)</span><br><span class="line">                    &amp;&amp; doesTree1HaveTree2(pRoot1.right, pRoot2.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasSubTree</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 != <span class="literal">null</span> &amp;&amp; pRoot2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pRoot1.val == pRoot2.val)</span><br><span class="line">                result = doesTree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">            <span class="keyword">if</span> (!result) result = hasSubTree(pRoot1.left, pRoot2);</span><br><span class="line">            <span class="keyword">if</span> (!result) result = hasSubTree(pRoot1.right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解决面试题的思路">解决面试题的思路</h1>
<h2 id="面试官谈面试思路">面试官谈面试思路</h2>
<h3 id="二叉树的镜像">二叉树的镜像</h3>
<p><strong>思路：</strong></p>
<p>前序遍历树的每一个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左、右子结点之后，就得到了树的镜像。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeMirror</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mirror</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> pRoot.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> pRoot.right;</span><br><span class="line">        pRoot.left = right;</span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) mirror(left);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) mirror(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称的二叉树">对称的二叉树</h3>
<p><strong>思路：</strong></p>
<p>定义一种对称的前序遍历算法，即先遍历父结点，再遍历它的右子结点，最后遍历它的左子结点。</p>
<p>针对一颗二叉树，分别使用前序遍历算法和对称的前序遍历算法进行遍历，如果两次遍历得到的序列一样，则该二叉树是对称的。</p>
<p>注：遍历的过程中需要把 null 结点也考虑在内。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsSymmetrical</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> &amp;&amp; pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> || pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1.val != pRoot2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot1.left, pRoot2.right)</span><br><span class="line">                &amp;&amp; isSymmetrical(pRoot1.right, pRoot2.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="画图让抽象问题形象化">画图让抽象问题形象化</h2>
<h3 id="顺时针打印矩阵">顺时针打印矩阵</h3>
<p><strong>思路：</strong></p>
<p>由于是以外圈到内圈的顺序依次打印的，所以我们可以把矩阵想象成若干个圈，如下图所示，可以用一个循环来打印矩阵，每次打印矩阵中的一个圈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/85361b2d31f9d61a9ac306659ca69f52.png" alt="print-matrix-in-circle"></p>
<p>假设矩阵的行数为 rows，列数为 cols，则循环结束的条件为： <code>cols &gt; startX * 2 &amp;&amp; rows &gt; startY * 2</code>， <code>(startX, startY)</code> 为本次循环要打印的第一个位置的坐标。</p>
<p>接着我们考虑如何打印一圈的功能，即如何实现 printMatrixInCircle。我们可以把打印一圈分成四步：</p>
<ul>
<li>第一步，从左到右打印一行；</li>
<li>第二步，从上到下打印一列；</li>
<li>第三步，从右到左打印一行；</li>
<li>第四步，从下到上打印一列。</li>
</ul>
<p>几个退化的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/58cadd0fdd8be83d5702f3d50abd3e7f.png" alt="matrix-degradation-examples"></p>
<ul>
<li>经分析发现，第一步总是需要的；</li>
<li>如果只有一行，那就不用第二步了，也即进行第二步的前提条件是终止行号大于起始行号；</li>
<li>需要第三步的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号，还有终止列号大于起始列号。</li>
<li>同理，第四步的前提条件是至少有三行两列，因此要求终止行号比起始行号至少大 2，同时终止列号大于起始列号。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n*m)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMatrixClockwisely</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMatrixInCircle</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> start, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endX</span> <span class="operator">=</span> cols - <span class="number">1</span> - start, endY = rows - <span class="number">1</span> - start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= endX; i++) res.add(matrix[start][i]);</span><br><span class="line">        <span class="keyword">if</span> (endY &gt; start)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt;= endY; i++) res.add(matrix[i][endX]);</span><br><span class="line">        <span class="keyword">if</span> (endY &gt; start &amp;&amp; endX &gt; start)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> endX - <span class="number">1</span>; i &gt;= start; i--) res.add(matrix[endY][i]);</span><br><span class="line">        <span class="keyword">if</span> (endX &gt; start &amp;&amp; endY - start &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> endY - <span class="number">1</span>; i &gt; start; i--) res.add(matrix[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printMatrixClockwisely</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cols &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>)</span><br><span class="line">            printMatrixInCircle(matrix, rows, cols, start++, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="举例让抽象问题具体化">举例让抽象问题具体化</h2>
<h3 id="包含-min-函数的栈">包含 min 函数的栈</h3>
<p><strong>思路：</strong></p>
<p>使用两个栈，数据栈和辅助栈；</p>
<ul>
<li>每当数据栈压入数据后，辅助栈压入当前数据栈的最小值；</li>
<li>每当数据栈弹出数据后，辅助栈也直接弹出栈顶元素。</li>
</ul>
<p><strong>时间复杂度：</strong> min 函数 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackWithMin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; dataStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        dataStack.push(num);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) minStack.push(num);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curMin</span> <span class="operator">=</span> minStack.peek();</span><br><span class="line">            minStack.push((num &lt; curMin) ? num : curMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的压入弹出序列">栈的压入、弹出序列</h3>
<p><strong>思路：</strong></p>
<p>建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>
<p>判断一个序列是不是栈的弹出序列的规律：</p>
<ul>
<li>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；</li>
<li>如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；</li>
<li>如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsPopOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPopOrder</span><span class="params">(<span class="type">int</span>[] pPush, <span class="type">int</span>[] pPop)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pPush == <span class="literal">null</span> || pPop == <span class="literal">null</span></span><br><span class="line">                || pPush.length != pPop.length || pPush.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curPush</span> <span class="operator">=</span> <span class="number">0</span>, curPop = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curPop &lt; pPop.length)&#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isEmpty() || stack.peek() != pPop[curPop])&#123;</span><br><span class="line">                <span class="keyword">if</span> (curPush == pPush.length) <span class="keyword">break</span>;</span><br><span class="line">                stack.push(pPush[curPush++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.peek() != pPop[curPop]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            stack.pop();</span><br><span class="line">            curPop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curPop == pPop.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从上到下打印二叉树">从上到下打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用一个辅助队列，每次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放入队列的尾部。接着取出队列的下一个结点，重复前面的打印操作。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintFromTopToBottom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printFromTopToBottom</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分行从上到下打印二叉树">分行从上到下打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用一个辅助队列来保存将要打印的结点；其次需要定义两个变量：一个变量 <code>last</code> 表示当前层的尾结点；另一个变量 <code>nextLast</code> 表示下一层的尾结点。</p>
<ul>
<li>在打印某一层结点时，把下一层的子结点保存到队列中。</li>
<li>在把下一层的结点加到队列时，同步更新 <code>nextLast</code>，使 <code>nextLast</code> 指向队列的尾结点。</li>
<li>在打印到本层的尾结点时，更新 <code>last</code>，使 <code>last = nextLast</code></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LayerPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> pRoot, nextLast = pRoot;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            layer.add(pNode.val);</span><br><span class="line">            <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(pNode.left);</span><br><span class="line">                nextLast = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(pNode.right);</span><br><span class="line">                nextLast = pNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pNode == last)&#123;</span><br><span class="line">                last = nextLast;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="之字形打印二叉树">之字形打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用两个辅助栈：</p>
<ul>
<li>在打印某一层结点时，把下一层的子结点保存到相应的栈里。</li>
<li>如果当前打印的奇数层（第 1 层、第 3 层等），则先保存左子结点再保存右子结点到第一个栈里；</li>
<li>如果当前打印的是偶数层（第 2 层、第 4 层等），则先保存右子结点再保存左子结点到第二个栈里。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList[] levels = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">2</span>];</span><br><span class="line">        levels[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        levels[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>, next = <span class="number">1</span>;</span><br><span class="line">        levels[current].push(pRoot);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!levels[<span class="number">0</span>].isEmpty() || !levels[<span class="number">1</span>].isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> (TreeNode) levels[current].pop();</span><br><span class="line">            layer.add(pNode.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) levels[next].push(pNode.left);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) levels[next].push(pNode.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) levels[next].push(pNode.right);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) levels[next].push(pNode.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (levels[current].isEmpty())&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                current = <span class="number">1</span> - current;</span><br><span class="line">                next = <span class="number">1</span> - next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack1.size();</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">                layer.add(pNode.val);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) stack2.push(pNode.left);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) stack2.push(pNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack1.size() != size)&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            size = stack2.size();</span><br><span class="line">            <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">                layer.add(pNode.val);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) stack1.push(pNode.right);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) stack1.push(pNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack2.size() != size)&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列</h3>
<p><strong>思路：</strong></p>
<p>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结点的值小；第二部分是右子树结点的值，它们都比根结点的值大。</p>
<p>以数组 {5,7,6,9,11,10,8} 为例，后序遍历结果的最后一个数字 8 就是根结点的值。在这个数组中，前 3 个数字 5、7 和 6 都比 8 小，是值为 8 的结点的左子树结点；后 3 个数字 9、11 和 10 都比 8 大，是值为 8 的结点的右子树结点。所以我们可以用同样的方法确定与数组每一部分对应的子树的结构。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifySequenceOfBST</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">verifyCore</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> sequence[right], sep = left;</span><br><span class="line">        <span class="keyword">while</span> (sep &lt; right &amp;&amp; sequence[sep] &lt; root) sep++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sep + <span class="number">1</span>; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verifyCore(sequence, left, sep - <span class="number">1</span>)</span><br><span class="line">                &amp;&amp; verifyCore(sequence, sep, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifySequenceOfBST</span><span class="params">(<span class="type">int</span>[] sequence)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="literal">null</span> || sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verifyCore(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径">二叉树中和为某一值的路径</h3>
<p><strong>思路：</strong></p>
<p>经分析，当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。</p>
<ul>
<li>如果该结点为叶子结点，并且路径中结点值的和刚好等于输入的整数，则当前路径符合要求，我们把它打印出来。</li>
<li>如果当前结点不是叶子结点，则继续访问它的子结点。</li>
<li>当前结点访问结束后，递归函数自动回到它的父结点。因此在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是从根结点到父结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindPath</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPathCore</span><span class="params">(TreeNode root, <span class="type">int</span> target, <span class="type">int</span>[] curSum,</span></span><br><span class="line"><span class="params">                              ArrayList&lt;Integer&gt; curPath,</span></span><br><span class="line"><span class="params">                              ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths)</span>&#123;</span><br><span class="line">        curSum[<span class="number">0</span>] += root.val;</span><br><span class="line">        curPath.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; curSum[<span class="number">0</span>] == target)</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curPath)); <span class="comment">//浅拷贝，线性时间</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">            findPathCore(root.left, target, curSum, curPath, paths);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">            findPathCore(root.right, target, curSum, curPath, paths);</span><br><span class="line">        curPath.remove(curPath.size()-<span class="number">1</span>);</span><br><span class="line">        curSum[<span class="number">0</span>] -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">findPath</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        <span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; curPath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findPathCore(root, target, curSum, curPath, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分解让复杂问题简单化">分解让复杂问题简单化</h2>
<h3 id="复杂链表的复制">复杂链表的复制</h3>
<p><strong>思路：</strong></p>
<ul>
<li><p>第一步根据原始链表的每个结点 <span class="math inline">\(N\)</span> 创建对应的 <span class="math inline">\(N&#39;\)</span>，直接把 <span class="math inline">\(N&#39;\)</span> 链接在 <span class="math inline">\(N\)</span> 的后面。经过这一步之后的结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cda1edfddae568a341e0c80d10953827.png" alt="complex-linked-list-copy-1"></p></li>
<li><p>第二步设置复制出来的结点的 random。假设原始链表上的 <span class="math inline">\(N\)</span> 的 random 指向结点 <span class="math inline">\(S\)</span>，那么其对应复制出来的 <span class="math inline">\(N&#39;\)</span> 是 <span class="math inline">\(N\)</span> 的 next 的指向的结点，同理 <span class="math inline">\(S&#39;\)</span> 也是 <span class="math inline">\(S\)</span> 的 next 指向的结点。设置 random 之后的链表如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8e7ab743619ec1b0e2f6b61e4b57a6ef.png" alt="complex-linked-list-copy-2"></p></li>
<li><p>第三步把这个长链表拆分成两个链表：把奇数位置的结点用 next 连接起来就是原始链表，把偶数位置的结点用 next 链接起来就是复制出来的链表。链表拆分之后的两个链表如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ee3d5a227becfec5b725c133ede3bd48.png" alt="complex-linked-list-copy-3"></p></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> label;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">random</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="type">int</span> label) &#123;</span><br><span class="line">        <span class="built_in">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexLinkedListCopy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cloneNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">pClone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(pNode.label);</span><br><span class="line">            pClone.next = pNode.next;</span><br><span class="line">            pNode.next = pClone;</span><br><span class="line">            pNode = pClone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectRandomNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">pClone</span> <span class="operator">=</span> pNode.next;</span><br><span class="line">            <span class="keyword">if</span> (pNode.random != <span class="literal">null</span>) pClone.random = pNode.random.next;</span><br><span class="line">            pNode = pClone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RandomListNode <span class="title function_">reconnectNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pCloneHead</span> <span class="operator">=</span> <span class="literal">null</span>, pCloneNode = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pCloneHead = pCloneNode = pNode.next;</span><br><span class="line">            pNode.next = pCloneNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pCloneNode.next = pNode.next;</span><br><span class="line">            pCloneNode = pCloneNode.next;</span><br><span class="line">            pNode.next = pCloneNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">clone</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        cloneNodes(pHead);</span><br><span class="line">        connectRandomNodes(pHead);</span><br><span class="line">        <span class="keyword">return</span> reconnectNodes(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表">二叉搜索树与双向链表</h3>
<p><strong>思路：</strong></p>
<p>在二叉搜索树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在将二叉搜索树转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点的指针。</p>
<p>按照中序遍历的顺序，当我们遍历转换到根结点时，它的左子树已经转换成一个排序的链表了，并且处在链表中的最后一个结点是当前值最大的结点。我们把这个结点和根结点链接起来，此时链表中的最后一个结点就是根结点了。接着我们去遍历转换右子树，并把根结点和右子树中最小的结点链接起来。子树的转换过程是一样的，所以我们可以用递归解决。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTreeConvertToDLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">convertNode</span><span class="params">(TreeNode pRoot, TreeNode[] pLast)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        convertNode(pRoot.left, pLast);</span><br><span class="line"></span><br><span class="line">        pRoot.left = pLast[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (pLast[<span class="number">0</span>] != <span class="literal">null</span>) pLast[<span class="number">0</span>].right = pRoot;</span><br><span class="line">        pLast[<span class="number">0</span>] = pRoot;</span><br><span class="line"></span><br><span class="line">        convertNode(pRoot.right, pLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convert</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode[] pLast = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[]&#123;<span class="literal">null</span>&#125;;</span><br><span class="line">        convertNode(pRoot, pLast);</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pHeadOfList</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        <span class="keyword">while</span> (pHeadOfList.left != <span class="literal">null</span>) pHeadOfList = pHeadOfList.left;</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树">序列化二叉树</h3>
<p><strong>思路：</strong></p>
<ul>
<li>序列化
<ul>
<li>根据前序遍历的顺序来序列化二叉树；</li>
<li>在遍历时，遇到 null 指针时，将这些 null 指针序列化为一个特殊的字符（如 <code>$</code> ）；</li>
<li>其次结点的数值之间要用一个特殊的字符（如 <code>,</code> ）隔开。</li>
</ul></li>
<li>反序列化
<ul>
<li>以 <code>"1,2,4,$,$,$,3,5,$,$,6,$,$"</code> 为例：</li>
<li>第一个读出的是 1，由于前序遍历是从根结点开始的，这是根结点的值。</li>
<li>接下来读出的是 2，根据前序遍历的规则，这是根结点的左子结点。</li>
<li>同样，接下来的 4 是 2 的左子结点。</li>
<li>接着从序列读出两个 <code>$</code>，这表明 4 的左、右子结点均为 null，因此它是一个叶子结点。</li>
<li>接下来回到 2 的结点，重建它的右子结点。</li>
<li>由于下一个是 <code>$</code>，这表明 2 的右子结点为 null，说明这个结点的左、右子树都已构建完毕。</li>
<li>接下来回到根结点，同样的方法反序列化根结点的右子树。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeAndDeserialize</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> String[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toSerial</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        toSerial(root.left);</span><br><span class="line">        toSerial(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        toSerial(root);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">toDeserial</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes[++index].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(nodes[index]));</span><br><span class="line">            root.left = toDeserial();</span><br><span class="line">            root.right = toDeserial();</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserailize</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">null</span>) nodes = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> toDeserial();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的排列">字符串的排列</h3>
<p><strong>思路：</strong></p>
<p>把一个字符串看成由两部分组成：第一部分是它的第一个字符；第二部分是后面的所有字符。求整个字符串的排列，可以看成两步：</p>
<ul>
<li>第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。</li>
<li>第二步固定第一个字符，求后面所有字符的排列，这时仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后进行同样的操作。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permutation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">permutationCore</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, ArrayList&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == arr.length) res.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; arr[i] == arr[start]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            permutationCore(arr, start + <span class="number">1</span>, res);</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permutationCore(str.toCharArray(), <span class="number">0</span>, res);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化时间和空间效率">优化时间和空间效率</h1>
<h2 id="时间效率">时间效率</h2>
<h3 id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</h3>
<p><strong>思路：</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其它所有数字出现次数的和还要多。因此我们可以考虑 <strong>在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。</strong></p>
<p>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加 1；如果下一个数字和我们之前保存的数字不同，则次数减 1。如果次数为 0，则保存下一个数字，并把次数设为 1。</p>
<p>由于要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次吧次数设为 1 时对应的数字。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoreThanHalfNum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkMoreThanHalf</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> result)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anArr : arr) <span class="keyword">if</span> (anArr == result) times++;</span><br><span class="line">        <span class="keyword">return</span> times &gt; arr.length / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">moreThanHalfNum</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == result) times++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((--times) == <span class="number">0</span>)&#123;</span><br><span class="line">                result = arr[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkMoreThanHalf(arr, result) ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(moreThanHalfNum(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的-k-个数">最小的 k 个数</h3>
<p><strong>思路：</strong></p>
<p>可以基于 partition 函数来解决这个问题。</p>
<p>如果基于数组的第 k 个数字来调整，使得比第 k 个数字小的所有数字都位于数组的左边，比第 k 个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的 k 个数字就是最小的 k 个数字（这 k 个数字不一定是排序的）。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetLeastNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, ++j, right);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right, base = arr[left], tmp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j] &gt;= base &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt;= base &amp;&amp; i &lt; j) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                tmp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[i];</span><br><span class="line">        arr[i] = base;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">getLeastNumbers</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="literal">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(input, left, right);</span><br><span class="line">        <span class="keyword">while</span>(index != k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; k -<span class="number">1</span>) right = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) result.add(input[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = getLeastNumbers(arr, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: res) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流中的中位数">数据流中的中位数</h3>
<p><strong>思路：</strong></p>
<p>如果数据在容器中已经排序，那么中位数可以由 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向的数得到。如果容器中的数据的数目是奇数，那么 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向同一个数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/508dae0cb6875456956be8d1d2e7434c.png" alt="median-in-data-stream"></p>
<ul>
<li><span class="math inline">\(P_1\)</span> 指向的数据是左边部分的最大的数，<span class="math inline">\(P_2\)</span> 指向的数据是左边部分最小的数。</li>
<li>如果能够保证容器左边的数据小于右边的数据，那么即使左右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。</li>
</ul>
<p>可以用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 <span class="math inline">\(O(logn)\)</span>；得到中位数的时间复杂度是 <span class="math inline">\(O(1)\)</span>。</p>
<ul>
<li>插入时要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1。</li>
<li>可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最大堆。</li>
<li>在插入时同时要保证最大堆的所有数据都要小于最小堆的数据。</li>
</ul>
<p><strong>时间复杂度：</strong> 插入一个数据的时间效率是 <span class="math inline">\(O(logn)\)</span>；得到中位数的时间复杂度是 <span class="math inline">\(O(1)\)</span>。</p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianOfDataStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">16</span>, (o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getMedian</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (count % <span class="number">2</span> == <span class="number">0</span>) ? (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span> : <span class="number">1.0</span> * minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">连续子数组的最大和</h3>
<p><strong>思路：</strong></p>
<p>可以利用动态规划来解决这个问题。</p>
<p>如果用函数 <code>dp[i]</code> 表示以第 <code>i</code> 个数字结尾的子数组的最大和，那么我们要求出 <code>max(dp[i])</code>，其中 <code>0&lt;=i&lt;=n</code>。状态转移方程如下：</p>
<p><span class="math display">\[
dp[i] = \left\{\begin{aligned}
&amp; arr[i] &amp;  &amp; {i=0\ or\ dp[i-1] \le 0 }\\
&amp; dp[i-1]+arr[i] &amp; &amp; {i \neq 0\ and\ dp[i-1] \gt 0}
\end{aligned}\right.
\]</span></p>
<p>这个公式的意义：当以第 <code>i-1</code> 个数字结尾的子数组的最大和小于等于 0 时，如果把这个负数与第 <code>i</code> 个数累加，得到的结果比第 <code>i</code> 个数字本身还要小，所以这种情况下以第 <code>i</code> 个数字结尾的子数组的最大和就是第 <code>i</code> 个数字本身。</p>
<p>如果以第 <code>i-1</code> 个数字结尾的子数组的最大和大于 0，则与第 <code>i</code> 个数字累加就得到以第 <code>i</code> 个数字为结尾的子数组的最大和。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindGreatestSumOfSubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> curSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt;= <span class="number">0</span>) curSum = arr[i];</span><br><span class="line">            <span class="keyword">else</span> curSum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &gt; maxSum) maxSum = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(findGreatestSumOfSubArray(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="从-1-到-n-整数中-1-出现的次数">从 1 到 n 整数中 1 出现的次数</h3>
<p><strong>思路：</strong></p>
<p>https://blog.csdn.net/yi_Afly/article/details/52012593</p>
<p>对每一位来说，记每一位的权值为 base，位值为 weight，该位之前的数是 former，举例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/271fc1b413a66e12a97f96ab1640df19.png" alt="count-1-occurrences"></p>
<p>则有：</p>
<ul>
<li>若 <code>weight = 0</code>，则 1 出现的次数为 <code>round * base</code></li>
<li>若 <code>weight = 1</code>，则 1 出现的次数为 <code>round * base + former + 1</code></li>
<li>若 <code>weight &gt; 1</code>，则 1 出现的次数为 <code>round * base + base</code></li>
</ul>
<p>注：<span class="math inline">\(base=10^i\)</span>，<code>i</code> 为当前位右边位的个数，如当前位为个位，则 <code>i=0</code></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOf1Between1AndN</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countNumberOfOne</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">1</span>, round = n;</span><br><span class="line">        <span class="keyword">while</span> (round &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> round % <span class="number">10</span>;</span><br><span class="line">            round /= <span class="number">10</span>;</span><br><span class="line">            counter += round * base;</span><br><span class="line">            <span class="keyword">if</span> (weight == <span class="number">1</span>) counter += (n % base + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (weight &gt; <span class="number">1</span>) counter += base;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(countNumberOfOne(<span class="number">534</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">把数组排成最小的数</h3>
<p><strong>思路：</strong></p>
<p>对数组进行排序，排序时需要判断 a 和 b 哪个应该排在前面，判断规则如下：</p>
<p>将 a 和 b 分别拼接成 ab 和 ba，比较 ab 和 ba 的字典序：</p>
<ul>
<li>若 ab &lt; ba，则 a 应该排在 b 前面</li>
<li>若 ab = ba，说明 a=b</li>
<li>若 ab &gt; ba，则 b 应该排在 a 前面</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMinNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> a + b, ba = b + a;</span><br><span class="line">        <span class="keyword">return</span> ab.compareTo(ba) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span>(compare(String.valueOf(arr[i]), String.valueOf(arr[right])))</span><br><span class="line">            	swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printMinNumber</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) sb.append(e);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">        System.out.println(printMinNumber(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMinNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printMinNumber</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anArr : arr) arrayList.add(anArr);</span><br><span class="line">        arrayList.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> o1.toString() + o2.toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ba</span> <span class="operator">=</span> o2.toString() + o1.toString();</span><br><span class="line">            <span class="keyword">return</span> ab.compareTo(ba);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arrayList) sb.append(e);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">        System.out.println(printMinNumber(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间效率与空间效率的平衡">时间效率与空间效率的平衡</h2>
<h3 id="丑数">丑数</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存排好序的丑数，利用已得到的丑数计算出下一个丑数，并将新的丑数加到数组尾部。</p>
<p>利用已得有序丑数计算下一个丑数的思路：</p>
<p>每一个丑数都是前面的丑数乘以 2、3 或者 5 得到的（除 1 以外）。</p>
<ul>
<li>假设已有最大的丑数记为 <span class="math inline">\(M\)</span></li>
<li><span class="math inline">\(T_2\)</span> 代表着数组的某个丑数的下标，这个丑数满足 <span class="math inline">\(arr[T_2] \ast 2 &gt; M\)</span>，同时若有任意小于 <span class="math inline">\(arr[T_2]\)</span> 的丑数 <span class="math inline">\(arr[T]\)</span>，则 <span class="math inline">\(T\)</span> 满足 <span class="math inline">\(arr[T] \ast 2 \le M\)</span>，<span class="math inline">\(T_3\)</span>、<span class="math inline">\(T_5\)</span> 的含义与 <span class="math inline">\(T_2\)</span> 类似</li>
<li><span class="math inline">\(M_2 = arr[T_2] \ast 2\)</span>，<span class="math inline">\(M_3 = arr[T_3] \ast 3\)</span>，<span class="math inline">\(M_5 = arr[T_5] \ast 5\)</span>，则下一个丑数为 <span class="math inline">\(M&#39; = min(M_2, M_3, M_5)\)</span></li>
<li>每次计算完下一个丑数 <span class="math inline">\(M&#39;\)</span>，及时更新 <span class="math inline">\(T_2\)</span>、<span class="math inline">\(T_3\)</span>、<span class="math inline">\(T_5\)</span></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetUglyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getUglyNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> arr[t2] * <span class="number">2</span>, m3 = arr[t3] * <span class="number">3</span>, m5 = arr[t5] * <span class="number">5</span>;</span><br><span class="line">            arr[i] = Math.min(Math.min(m2, m3), m5);</span><br><span class="line">            <span class="keyword">while</span> (arr[t2] * <span class="number">2</span> &lt;= arr[i]) t2++;</span><br><span class="line">            <span class="keyword">while</span> (arr[t3] * <span class="number">3</span> &lt;= arr[i]) t3++;</span><br><span class="line">            <span class="keyword">while</span> (arr[t5] * <span class="number">5</span> &lt;= arr[i]) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(getUglyNumber(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第一个只出现一次的字符">第一个只出现一次的字符</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存每个字母出现的次数，该数组相当于一个哈希表。</p>
<p>为了解决这个问题，需要从头开始扫描字符串两次：</p>
<ul>
<li>第一次扫描时，每扫描到一个字符就在数组的对应项中把次数加1</li>
<li>第二次扫描时，每扫描到一个字符就从数组中取出对应出现的次数</li>
</ul>
<p>这样第一个只出现一次的字符就是符合要求的输出。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstNotRepeatingChar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstNotRepeatingChar</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] counters = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">123</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            counters[str.charAt(i)]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            <span class="keyword">if</span> (counters[str.charAt(i)] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(firstNotRepeatingChar(<span class="string">&quot;abaccdeff&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流中第一个只出现一次的字符">字符流中第一个只出现一次的字符</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存 <strong>字符在字符流中的位置</strong>。</p>
<ul>
<li>当一个字符第一次从字符流中读出来时，把它在字符流中的位置保存到数据容器中。</li>
<li>当这个字符再次从字符流中读出来时，那么它就不是只出现一次的字符，也就可以被忽略了。这时把它在数据容器中保存的值更新成一个特殊的值。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStatistics</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] occurrence = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) occurrence[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (occurrence[ch] == -<span class="number">1</span>) occurrence[ch] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (occurrence[ch] &gt;= <span class="number">0</span>) occurrence[ch] = -<span class="number">2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstAppearingOnce</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; minIdx)&#123;</span><br><span class="line">                ch = (<span class="type">char</span>) i;</span><br><span class="line">                minIdx = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">CharStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharStatistics</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="string">&quot;google&quot;</span>.toCharArray()) &#123;</span><br><span class="line">            statistics.insert(ch);</span><br><span class="line">            System.out.println(statistics.firstAppearingOnce());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">数组中的逆序对</h3>
<p><strong>思路：</strong></p>
<p>利用归并排序统计逆序对数。</p>
<ul>
<li>把数组分隔成子数组</li>
<li>先统计出子数组内部的逆序对的数目</li>
<li>然后再统计出两个相邻子数组之间的逆序对的数目</li>
</ul>
<p>在统计逆序对的过程中，还需要对数组进行排序。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p>额外空间复杂度 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<p>可能会溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InversePairsCore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid, j = right, k = right, counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= left &amp;&amp; j &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j])&#123;</span><br><span class="line">                counter += (j - mid);</span><br><span class="line">                tmp[k--] = arr[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k--] = arr[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= left) tmp[k--] = arr[i--];</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= mid + <span class="number">1</span>) tmp[k--] = arr[j--];</span><br><span class="line">        k = left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) arr[left++] = tmp[k++];</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> mergeSort(arr, left, mid, tmp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> mergeSort(arr, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> merge(arr, left, mid, right, tmp);</span><br><span class="line">            <span class="keyword">return</span> part1 + part2 + part3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inversePairs</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = new int[]&#123;7,5,6,4&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(inversePairs(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个链表的第一个公共结点">两个链表的第一个公共结点</h3>
<p><strong>思路：</strong></p>
<p>从结点的定义看，两个链表为单链表，如果两个链表有公共结点，那么从第一公共结点开始，之后它们的所有结点都是重合的，不可能在出现分叉。所以两个有公共结点而部分重合的链表，其拓扑形状看起来像一个 Y，而不可能像 X。</p>
<p>这道题的关键是当两个链表的长度不相同时，如何同时遍历到两个链表的第一个公共结点，利用两个辅助栈可以实现从链表尾部开始同时遍历到第一个公共结点，但是我们有更简单的方法：</p>
<ul>
<li>首先遍历两个链表得到它们的长度</li>
<li>在第二次遍历的时候，在较长的链表上先走若干步，使得剩余步数与另一链表一致</li>
<li>接着同时在两个链表遍历，找到的第一个相同的结点即为它们的第一个公共结点</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(m+n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindFirstCommonNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getListLength</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span> || pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getListLength(pHead1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> getListLength(pHead2);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode1</span> <span class="operator">=</span> pHead1, pNode2 = pHead2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.abs(len1 - len2);</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (t-- != <span class="number">0</span>) pNode2 = pNode2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (t-- != <span class="number">0</span>) pNode1 = pNode1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode1 != pNode2)&#123;</span><br><span class="line">            pNode1 = pNode1.next;</span><br><span class="line">            pNode2 = pNode2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">        node6.next = node7;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">        node3.next = node6;</span><br><span class="line">        node5.next = node6;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        node4.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        System.out.println(findFirstCommonNode(node1, node4).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试中的各项能力">面试中的各项能力</h1>
<h2 id="知识迁移能力">知识迁移能力</h2>
<h3 id="数字在排序数组中出现的次数">数字在排序数组中出现的次数</h3>
<p><strong>思路：</strong></p>
<p>因为数组是有序的，要快速统计数字 k 出现的次数的关键是如何找到第一个 k 和最后一个 k，<code>最后一个k的索引 - 第一个k的索引 + 1</code> 即为 k 出现的次数。而第一个 k 和最后一个 k 的查找可以使用二分查找得到。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNumberOfK</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFirstK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == left || arr[mid-<span class="number">1</span>] != k) <span class="keyword">return</span> mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLastK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] != k) <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> getFirstK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastK</span> <span class="operator">=</span> getLastK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">if</span> (firstK == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(getNumberOfK(arr, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的第-k-大结点">二叉搜索树的第 k 大结点</h3>
<p><strong>思路：</strong></p>
<p>如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KthNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kthNode</span><span class="params">(TreeNode pRoot, ArrayList&lt;TreeNode&gt; nodes)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot.left != <span class="literal">null</span>) kthNode(pRoot.left, nodes);</span><br><span class="line">        nodes.add(pRoot);</span><br><span class="line">        <span class="keyword">if</span> (pRoot.right != <span class="literal">null</span>) kthNode(pRoot.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">kthNode</span><span class="params">(TreeNode pRoot, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        kthNode(pRoot, nodes);</span><br><span class="line">        <span class="keyword">return</span> k &gt; nodes.size() ? <span class="literal">null</span> : nodes.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的深度">二叉树的深度</h3>
<p><strong>思路：</strong></p>
<p>可以从另一个角度来理解树的深度。如果一棵树只有一个结点，它的深度为 1。如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加 1；同样如果根结点只有右子树而没有左子树，那么树的深度就是其左、右子树深度的较大值再加 1。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn) \sim O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDepth</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(treeDepth(root.left) + <span class="number">1</span>, treeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        node5.left = node7;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        node2.left = node4;</span><br><span class="line">        node2.right = node5;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        node3.right = node6;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line"></span><br><span class="line">        System.out.println(treeDepth(node1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断平衡二叉树">判断平衡二叉树</h3>
<p><strong>思路：</strong></p>
<p>如果某二叉树中任意结点的左右子树的深度相差不超过 1，那么它就是一颗平衡二叉树。</p>
<p>利用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的深度，我们就可以一边遍历一边判断每个结点是不是平衡的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsAVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        System.out.println(isBalanced(node1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字">数组中只出现一次的数字</h3>
<p>要求时间复杂度是 <span class="math inline">\(O(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>思路：</strong></p>
<p>异或运算的一个性质：<strong>任何一个数字异或它自己都等于 0</strong></p>
<p>如果数组里只有一个数字出现 1 次，其它都出现偶数次，那么从头到尾异或数组中的每一个数字，最后将得到那个只出现一次的数字。所以解决问题的关键变成了如何把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其它数字都出现偶数次。</p>
<blockquote>
<p>并不需要额外的辅助空间保存两个子数组，这里只是在逻辑上进行划分而已。</p>
</blockquote>
<ul>
<li>首先，从头到尾依次异或数组中的每一个数字，最终得到的结果就是那两个只出现一次的数字异或的结果。</li>
<li>因为这两个数字肯定不一样，那么异或的结果肯定不为 0，也就是说在这个结果数字的二进制表示中至少有一位为 1。</li>
<li>在结果数字中找到第一个为 1 的位置，记为第 n 位。</li>
<li>接着，以第 n 位是不是 1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 n 位都是 1，第二个子数组中每一个数字的第 n 位都是 0。</li>
</ul>
<blockquote>
<p>由于分组的标准是数字中的某一位是 1 还是 0，那么出现了偶数次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的。</p>
</blockquote>
<p>例如：</p>
<p>假设输入数组 {2,4,3,6,3,2,5,5}，对数组中的每个数字异或运算后得到结果的二进制表示为 0010。</p>
<p>异或得到结果中的倒数第二位是 1，于是我们根据数字的倒数第二位是不是 1 分为两个子数组。</p>
<p>第一个子数组 {2,3,6,3,2} 中所有数字的倒数第二位都是 1；而第二个子数组 {4,5,5} 中所有数字的倒数第二位都是 0。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindNumsAppearOnce</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findFirstBitIsOne</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>) counter++;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBitOne</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> indexBit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt;&gt;&gt; indexBit &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findNumsAppearOnce</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] num1, <span class="type">int</span>[] num2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resExclusiveOr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) resExclusiveOr ^= e;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexBit</span> <span class="operator">=</span> findFirstBitIsOne(resExclusiveOr);</span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBitOne(e, indexBit)) num1[<span class="number">0</span>] ^= e;</span><br><span class="line">            <span class="keyword">else</span> num2[<span class="number">0</span>] ^= e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>], num2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        findNumsAppearOnce(arr, num1, num2);</span><br><span class="line">        System.out.println(<span class="string">&quot;num1=&quot;</span> + num1[<span class="number">0</span>] + <span class="string">&quot; num2=&quot;</span> + num2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的两个数字">和为S的两个数字</h3>
<p><strong>思路：</strong></p>
<p>因为数组有序，所以如果找到的两个数字小于 S，则考虑选择较小数字后面的数字，因为排在后面的数字更大一些，那么两个数字的和也更大一些，就有可能等于 S 了；同样，当两个数字的和大于 S，可以选择较大数字前面的数字，因为排在数组前面的数字要小一些。</p>
<p>以数组 {1,2,4,7,11,15} 及 S=15 为例：</p>
<ul>
<li>首先定义两个指针，第一个指向数组的第一个（也是最小的）数字 1；第二个指向数组的最后一个（也是最大的）数字 15。</li>
<li>这两个数字的和 16 大于 15，因此把第二个指针向前移动一个数字，让它指向 11。</li>
<li>这时两个数字 1 与 11 的和是 12，小于 15，所以把第一个指针向后移动一个数字指向 2。</li>
<li>此时两个数字 2 与 11 的和是 13，还是小于 15，所以再次把第一个指针向后移动一个数字指向 4。</li>
<li>此时数字 4 与 11 的和是 15，正是我们期待的结果。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindNumbersWithSum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findNumbers</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] num1, <span class="type">int</span>[] num2, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">1</span> || num1 == <span class="literal">null</span> || num2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">curSum</span> <span class="operator">=</span> arr[left] + arr[right];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                num1[<span class="number">0</span>] = arr[left];</span><br><span class="line">                num2[<span class="number">0</span>] = arr[right];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; sum) right--;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">findNumbersWithSum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>], num2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (findNumbers(arr, num1, num2, sum)) &#123;</span><br><span class="line">            numsList.add(num1[<span class="number">0</span>]);</span><br><span class="line">            numsList.add(num2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(findNumbersWithSum(arr, <span class="number">15</span>).toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">和为S的连续正数序列</h3>
<p><strong>思路：</strong></p>
<p>考虑用两个数 small 和 big 分别表示序列的最小值和最大值。</p>
<ul>
<li>首先把 small 初始化为 1，big 初始化为 2</li>
<li>如果从 small 到 big 的序列的和大于 S，我们可以从序列中去掉较小的值，也就是增大 small 的值</li>
<li>如果从 small 到 big 的序列的和小于 S，我们可以增大 big，让这个序列包含更多的数字</li>
<li>因为这个序列至少要有两个数字，所以 small 需要一直增加到 S/2 为止</li>
</ul>
<p>以 S=9 为例，求取和为 9 的连续序列的过程：</p>
<table>
<thead>
<tr class="header">
<th>步骤</th>
<th>small</th>
<th>big</th>
<th>序列</th>
<th>序列和</th>
<th>与 S 相比</th>
<th>下一步</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>1,2</td>
<td>3</td>
<td>小于</td>
<td>增加 big</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>3</td>
<td>1,2,3</td>
<td>6</td>
<td>小于</td>
<td>增加 big</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>4</td>
<td>1,2,3,4</td>
<td>10</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>4</td>
<td>2,3,4</td>
<td>9</td>
<td>等于</td>
<td>保存序列，增加 big</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>5</td>
<td>2,3,4,5</td>
<td>14</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="even">
<td>6</td>
<td>3</td>
<td>5</td>
<td>3,4,5</td>
<td>12</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="odd">
<td>7</td>
<td>4</td>
<td>5</td>
<td>4,5</td>
<td>9</td>
<td>等于</td>
<td>保存序列</td>
</tr>
</tbody>
</table>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindContinuousSequence</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">getSequence</span><span class="params">(<span class="type">int</span> small, <span class="type">int</span> big)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; sequence = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> small; i &lt;= big; i++) sequence.add(i);</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">findContinuousSequence</span><span class="params">(<span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; sequencesList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">3</span>) <span class="keyword">return</span> sequencesList;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">1</span>, big = <span class="number">2</span>, mid = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> small + big;</span><br><span class="line">        <span class="keyword">while</span> (small &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum)&#123;</span><br><span class="line">                sequencesList.add(getSequence(small, big));</span><br><span class="line">                curSum += (++big);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; sum) curSum -= (small++);</span><br><span class="line">            <span class="keyword">else</span> curSum += (++big);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sequencesList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; sequencesList = findContinuousSequence(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;Integer&gt; e: sequencesList) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(e.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转单词顺序">翻转单词顺序</h3>
<p><strong>思路：</strong></p>
<p>第一步翻转句子中所有的字符。比如翻转 "I am a student." 中所有的字符得到 ".tneduts a ma I"，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。</p>
<p>第二步再翻转每个单词中字符的顺序，就得到了 "student. a am I"。</p>
<p>这种思路的关键在于实现一个函数以翻转字符串中的一段。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseSentence</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left++] = arr[right];</span><br><span class="line">            arr[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseSentence</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                reverse(arr, left, i - <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(arr, left, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(reverseSentence(<span class="string">&quot;I am a student.&quot;</span>));</span><br><span class="line">        System.out.println(reverseSentence(<span class="string">&quot;Wonderful&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋转字符串">左旋转字符串</h3>
<p><strong>思路：</strong></p>
<p>利用三次逆序操作可以实现循环左移：</p>
<ul>
<li>将字符串分成两部分，一部分是需要循环左移（也即移到字符串尾部）的序列，另一部分是剩余的序列</li>
<li>对这两部分序列分别进行逆序操作</li>
<li>对整个字符串进行逆序操作，即得到循环左移的结果</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftRotateString</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left++] = arr[right];</span><br><span class="line">            arr[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">leftRotateString</span><span class="params">(String str, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || n &lt; <span class="number">0</span> || n &gt; str.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">        reverse(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, n, arr.length - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的最大值">6.1.10 队列的最大值</h3>
<p>滑动窗口的最大值</p>
<p><strong>思路：</strong></p>
<p>使用一个双端队列，用来保存有可能是滑动窗口最大值的数字的下标。</p>
<ul>
<li>在存入一个数字的下标之前，首先判断队列里已有数字是否小于待存入的数字。</li>
<li>如果已有的数字小于待存入的数字，那么这些数字已经不可能是滑动窗口的最大值，因此它们将会被依次从队列尾部删除。</li>
<li>同时，如果队列头部的数字已经从窗口里滑出，那么滑出的数字也需要从队列的头部删除。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxInWindows</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="literal">null</span> || size &lt; <span class="number">1</span> || size &gt; num.length) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; num[i] &gt;= num[deque.peekLast()])</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; num.length; i++)&#123;</span><br><span class="line">            res.add(num[deque.peek()]);</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; num[i] &gt;= num[deque.peekLast()])</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peek() &lt;= (i - size))</span><br><span class="line">                deque.poll();</span><br><span class="line">            deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(num[deque.peek()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象建模能力">抽象建模能力</h2>
<h3 id="n-个骰子的点数">n 个骰子的点数</h3>
<p><strong>思路：</strong></p>
<p>考虑用两个数组来存储骰子点数的每一个总数出现的次数。</p>
<ul>
<li>在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。</li>
<li>在下一循环中，我们加上一个新的骰子，此时和为n的骰子出现的次数等于上一次循环中骰子点数和为 n-1、n-2、n-3、n-4、n-5 与 n-6 的次数的总和</li>
<li>所以我们把另一个数组的第 n 个数字设为前一个数组对应的第 n-1、n-2、n-3、n-4、n-5 与 n-6 个数之和</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PointsOfNDice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printProbability</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//骰子最大面值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diceMaxVal</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//count[][n]: 点数和为n出现的次数</span></span><br><span class="line">        <span class="type">int</span>[][] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][diceMaxVal * num + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= diceMaxVal; i++) count[flag][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= num; k++) &#123;</span><br><span class="line">            <span class="comment">//有k个骰子时，最小点数和为k，不存在出现点数和小于k的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) count[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt;= diceMaxVal * k; i++) &#123;</span><br><span class="line">                count[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i &amp;&amp; j &lt;= diceMaxVal; j++) &#123;</span><br><span class="line">                    count[<span class="number">1</span> - flag][i] += count[flag][i - j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在下一轮中，交换两个数组，通过改变flag实现</span></span><br><span class="line">            flag = <span class="number">1</span> - flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> Math.pow(diceMaxVal, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i &lt;= diceMaxVal * num; i++) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%d : %.6f&quot;</span>, i, count[flag][i] / total));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PointsOfNDice</span>().printProbability(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扑克牌的顺子">扑克牌的顺子</h3>
<p><strong>思路：</strong></p>
<p>建模：把 5 张牌看成由 5 个数字组成的数组。大、小王定义为 0；A 为 1，J 为 11，Q 为 12，K 为 13。</p>
<ul>
<li>首先把数组排序</li>
<li>然后统计数组中 0 的个数</li>
<li>最后统计排序后的数组中相邻数字之间的空缺总数</li>
</ul>
<p>如果空缺总数小于或者等于 0 的个数，那么这个数组就是连续的；反之则不连续。</p>
<blockquote>
<p>注意：如果数组中的非 0 数字重复出现，则该数组不是连续的。也即如果一副牌里含有对子，则不可能是顺子。</p>
</blockquote>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsContinuous</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isContinuous</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numOfZero</span> <span class="operator">=</span> <span class="number">0</span>, numOfGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length &amp;&amp; arr[i] == <span class="number">0</span>; i++) numOfZero++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> numOfZero, big = numOfZero + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (big &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[small] == arr[big]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            numOfGap += arr[big] - arr[small] - <span class="number">1</span>;</span><br><span class="line">            small = big++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numOfZero &gt;= numOfGap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(isContinuous(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆圈中最后剩下的数字">圆圈中最后剩下的数字</h3>
<p><strong>思路：</strong></p>
<p>利用递推公式（推导过程详见《剑指Offer》）</p>
<p><span class="math display">\[
f(n,m) = \left\{\begin{aligned}
&amp; 0 &amp;  &amp; {n=1}\\
&amp; (f(n-1,m)+m)\%n &amp; &amp; {n \gt 1}
\end{aligned}\right.
\]</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastRemaining</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            last = (last + m) % i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(lastRemaining(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发散思维能力">发散思维能力</h2>
<h3 id="求-12...n">求 1+2+...+n</h3>
<p><strong>思路：</strong></p>
<p>利用短路与的特性实现递归终止</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneToNSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumSolution</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += sumSolution(n-<span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(sumSolution(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不用加减乘除做加法">不用加减乘除做加法</h3>
<p><strong>思路：</strong></p>
<p>分析 5+17=22，实际上可以分成三步进行：</p>
<ul>
<li>第一步只做各位相加不进位，此时相加结果是 12（个位 5 和 7 相加不进位是 2，十位 0 和 1 相加不进位是 1 ）</li>
<li>第二步做进位，5+7 中有进位，进位值是 10</li>
<li>第三步把前面两个结果加起来，12+10=22，刚好为 5+17 的结果</li>
</ul>
<p>这样的策略同样适用于二进制，所以可以了利用二进制的移位实现加法，具体的做法就是对二进制数进行以上三步操作，直至不产生进位（也即进位值等于 0 ），此时第一步的结果就是最终的结果。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum, carry;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span> (num2 != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">构建乘积数组</h3>
<p><strong>思路：</strong></p>
<p>B[i] 的值可以看作如下矩阵中每行的乘积。先算下三角乘积，再算上三角乘积。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/79529c6a002030ccb5807c770f1b330d.png" alt="create-product-array"></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateProductArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] multiply(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            tmp *= arr[i+<span class="number">1</span>];</span><br><span class="line">            res[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(multiply(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
        <div class="popular-posts-date">2019-05-24</div>
      <div class="popular-posts-title"><a href="/posts/e8eb0481/" rel="bookmark">二分查找</a></div>
        <div class="popular-posts-excerpt"><p></p><p>二分查找也称 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">折半查找（Binary Search）</a>，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><p></p></div>
    </li>
    <li class="popular-posts-item">
        <div class="popular-posts-date">2019-05-24</div>
      <div class="popular-posts-title"><a href="/posts/89cdb724/" rel="bookmark">筛法求素数</a></div>
        <div class="popular-posts-excerpt"><p></p><p>本文将介绍 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">埃拉托斯特尼筛法</a> 和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler&#39;s_sieve">欧拉线性筛法</a> 的基本原理，并以此思路实现这两种求素数的算法。</p><p></p></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>lu wenye
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://wylu.me/posts/338d1bcc/" title="剑指Offer总结">https://wylu.me/posts/338d1bcc/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag"><i class="fa fa-tag"></i> 剑指Offer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/eed37a90/" rel="prev" title="Ubuntu 18.04 安装shadowsocks">
                  <i class="fa fa-chevron-left"></i> Ubuntu 18.04 安装shadowsocks
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/e45df9a/" rel="next" title="2048AI设计与实现">
                  2048AI设计与实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-changyan">changyan</a></li>
            <li class="tab"><a href="#comment-disqus">disqus</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane changyan" id="comment-changyan">
              <div class="comments" id="SOHUCS" sid="cbe9eaa0f2352a3a17957d6e75299be2"></div>
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wylu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">129k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:50</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/wylu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywofsGy5","appkey":"81e9ec55ee07f76c5500fc2df8517c62","count":false}</script>
<script src="/js/third-party/comments/changyan.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"wylu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
