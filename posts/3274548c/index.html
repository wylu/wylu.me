<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="TWTqGRcdm7qMQZ1XqfQLJEwhOaDcUy81paYiE7e3tyw">
  <meta name="msvalidate.01" content="05EA84E81FBC0002CD044701E7E4E569">
  <meta name="baidu-site-verification" content="uuaszSSnES">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.wylu.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":false,"nav":null,"activeClass":"changyan"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文主要介绍了算法的一些特性和常见算法的实现方法。其中，时间复杂度是算法效率的重要指标，递归是一种常见的算法实现方式，分治法、动态规划、贪心算法和回溯法是常见的算法设计思想。此外，还介绍了哈夫曼编码、单源最短路径、最小生成树、并查集和优先队列等常见算法的实现方法和应用场景。这些算法在计算机科学和工程领域中都有广泛的应用，对于提高算法效率和解决实际问题具有重要意义。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与分析">
<meta property="og:url" content="https://www.wylu.me/posts/3274548c/index.html">
<meta property="og:site_name" content="wylu">
<meta property="og:description" content="本文主要介绍了算法的一些特性和常见算法的实现方法。其中，时间复杂度是算法效率的重要指标，递归是一种常见的算法实现方式，分治法、动态规划、贪心算法和回溯法是常见的算法设计思想。此外，还介绍了哈夫曼编码、单源最短路径、最小生成树、并查集和优先队列等常见算法的实现方法和应用场景。这些算法在计算机科学和工程领域中都有广泛的应用，对于提高算法效率和解决实际问题具有重要意义。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/891129703366840b1bac668d27b5cd11.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wylu/img/af9941f332989278833bd160b2a58181.png">
<meta property="article:published_time" content="2020-05-17T10:18:26.000Z">
<meta property="article:modified_time" content="2023-04-08T13:31:09.753Z">
<meta property="article:author" content="lu wenye">
<meta property="article:tag" content="data-structure">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wylu/img/891129703366840b1bac668d27b5cd11.png">


<link rel="canonical" href="https://www.wylu.me/posts/3274548c/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.wylu.me/posts/3274548c/","path":"posts/3274548c/","title":"算法设计与分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>算法设计与分析 | wylu</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155154294-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-155154294-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "enj9prl9r6");
</script>



<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5699403938610067" crossorigin="anonymous"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="wylu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wylu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Keep It Simple, Stupid</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">67</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">37</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-commenting fa-fw"></i>留言</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-text">算法设计与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">算法的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7-1"><span class="nav-text">算法的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86"><span class="nav-text">算法的性能标准</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">常见算法时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-text">算法复杂性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92"><span class="nav-text">二分查找（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">二分查找（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92-1"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">非递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-text">分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-text">适用条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0"><span class="nav-text">求逆序对数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-text">快速选择算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9bfprt"><span class="nav-text">线性时间选择（BFPRT）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98"><span class="nav-text">矩阵连乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-text">重叠子问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lis%E6%9C%80%E9%95%BF%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">LIS最长单调递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lcs%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">LCS最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">分治法与动态规划的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="nav-text">活动安排问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="nav-text">最优子结构性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8"><span class="nav-text">贪心选择性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">贪心算法求解背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="nav-text">最优装载问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">构造哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">单源最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-text">单源最短路问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-text">Dijkstra 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-text">最小生成树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kruskal-%E7%AE%97%E6%B3%95"><span class="nav-text">Kruskal 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="nav-text">主要操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C-1"><span class="nav-text">主要操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">回溯法的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF"><span class="nav-text">递归回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF"><span class="nav-text">迭代回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82s%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E5%B0%8F%E4%BA%8E4%E7%9A%84%E5%AD%90%E9%9B%86"><span class="nav-text">求S的所有元素个数小于4的子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82s%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E8%E7%9A%84%E5%AD%90%E9%9B%86"><span class="nav-text">求S的所有元素和小于8的子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82s%E6%BB%A1%E8%B6%B3%E5%85%83%E7%B4%A0%E5%A5%87%E5%81%B6%E6%80%A7%E7%9B%B8%E5%90%8C%E4%B8%94%E5%92%8C%E5%B0%8F%E4%BA%8E8%E7%9A%84%E5%AD%90%E9%9B%86"><span class="nav-text">求S满足元素奇偶性相同且和小于8的子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82s%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97"><span class="nav-text">求S的所有排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82s%E7%9A%84%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%E5%A5%87%E5%81%B6%E6%95%B0%E7%9B%B8%E9%97%B4%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-text">求S的所有满足奇偶数相间出现的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">0-1 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="nav-text">装载问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-text">n皇后问题</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lu wenye" src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">lu wenye</p>
  <div class="site-description" itemprop="description">Hard work, Dedication and Discipline</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wylu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wylu" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15wylu@gmail.com" title="E-Mail → mailto:15wylu@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32767041" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32767041" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-book fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    相关文章
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/posts/56db4dd4/" rel="bookmark">
        <time class="popular-posts-time">2019-06-04</time>
        <br>
      多边形游戏
      </a>
    </li>
  </ul>

          </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wylu.me/posts/3274548c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="lu wenye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wylu">
      <meta itemprop="description" content="Hard work, Dedication and Discipline">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="算法设计与分析 | wylu">
      <meta itemprop="description" content>
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法设计与分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-17 18:18:26" itemprop="dateCreated datePublished" datetime="2020-05-17T18:18:26+08:00">2020-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-08 21:31:09" itemprop="dateModified" datetime="2023-04-08T21:31:09+08:00">2023-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cs/" itemprop="url" rel="index"><span itemprop="name">cs</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cs/data-structure/" itemprop="url" rel="index"><span itemprop="name">data-structure</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文主要介绍了算法的一些特性和常见算法的实现方法。其中，时间复杂度是算法效率的重要指标，递归是一种常见的算法实现方式，分治法、动态规划、贪心算法和回溯法是常见的算法设计思想。此外，还介绍了哈夫曼编码、单源最短路径、最小生成树、并查集和优先队列等常见算法的实现方法和应用场景。这些算法在计算机科学和工程领域中都有广泛的应用，对于提高算法效率和解决实际问题具有重要意义。</p>
<span id="more"></span>
<h1 id="算法设计与分析">算法设计与分析</h1>
<h2 id="算法的特性">算法的特性</h2>
<h3 id="定义">定义</h3>
<p>为了解决某类问题而规定的一个有限长的操作序列。</p>
<h3 id="算法的特性-1">算法的特性</h3>
<p>有穷性，确定性，可行性，输入，输出</p>
<h3 id="算法的性能标准">算法的性能标准</h3>
<p>正确性、可读性、健壮性、高效率和低存储需求</p>
<h2 id="时间复杂度">时间复杂度</h2>
<h3 id="常见算法时间复杂度">常见算法时间复杂度</h3>
<ul>
<li><span class="math inline">\(O(1)\)</span>: 表示算法的运行时间为常量</li>
<li><span class="math inline">\(O(n)\)</span>: 表示该算法是线性算法</li>
<li><span class="math inline">\(O(logn)\)</span>: 二分查找算法</li>
<li><span class="math inline">\(O(n^2)\)</span>: 对数组进行排序的简单算法，如直接插入排序。</li>
<li><span class="math inline">\(O(n^3)\)</span>: 做两个n阶矩阵的乘法运算</li>
<li><span class="math inline">\(O(2^n)\)</span>: 求具有n个元素集合的所有子集的算法</li>
<li><span class="math inline">\(O(n!)\)</span>: 求具有n个元素的全排列的算法</li>
</ul>
<h3 id="算法复杂性分析">算法复杂性分析</h3>
<p><span class="math display">\[
f(n)=O(g(n)) \qquad f(n)的阶≤g(n)的阶\\
f(n)=Ω(g(n)) \qquad f(n)的阶≥g(n)的阶\\
f(n)=θ(g(n)) \qquad f(n)的阶＝g(n)的阶\\
f(n)=o(g(n)) \qquad f(n)的阶＜g(n)的阶\\
\]</span></p>
<h2 id="递归">递归</h2>
<h3 id="二分查找递归">二分查找（递归）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; target) <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找非递归">二分查找（非递归）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<ul>
<li>选择划分基准 a(p)</li>
<li>将数组 a 划分成两个子数组，使得 <code>a[l...p-1] &lt;= a(p)</code>，<code>a[p+1...r] &gt;= a(p)</code></li>
<li>递归调用快速排序算法，对 <code>a[l...p-1]</code> 和 <code>a[p+1...r]</code> 进行排序</li>
</ul>
<h4 id="递归-1">递归</h4>
<p>C参考实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right, base = a[left], tmp;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt;= base &amp;&amp; i &lt; j) j--;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= base &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) tmp = a[i], a[i] = a[j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[i], a[i] = base;</span><br><span class="line">    quickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java参考实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            sort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            sort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: arr) System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归">非递归</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(left);</span><br><span class="line">        stack.push(right);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, begin, end);</span><br><span class="line">                stack.push(begin);</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">                stack.push(end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) System.out.print(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治法">分治法</h2>
<h3 id="基本思想">基本思想</h3>
<p>将求解的较大规模的问题分割成 k 个更小规模的子问题。对这 k 个子问题分别求解。如果子问题的规模仍然不够小，则再划分为 k 个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。</p>
<h3 id="适用条件">适用条件</h3>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决；</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<p>其基本思想是：将待排序元素分成大小大致相同的 2 个子集合，分别对 2 个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> mid, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = x, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= y) tmp[t++] = a[i] &lt;= a[j] ? a[i++] : a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= y) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= y) a[x++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (x + y) / <span class="number">2</span>;</span><br><span class="line">        sort(a, x, mid, tmp);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, y, tmp);</span><br><span class="line">        merge(a, x, mid, y, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求逆序对数">求逆序对数</h3>
<p>考虑 <span class="math inline">\(1,2,…,n\)</span> 的排列 <span class="math inline">\(i1，i2，…，in\)</span>，如果其中存在 <span class="math inline">\(j,k\)</span>，满足 <span class="math inline">\(j &lt; k\)</span> 且 <span class="math inline">\(i_j &gt; i_k\)</span>， 那么就称 <span class="math inline">\((i_j,i_k)\)</span> 是这个排列的一个逆序。</p>
<p>一个排列含有逆序的个数称为这个排列的逆序数。例如排列 263451 含有8个逆序 (2,1),(6,3),(6,4),(6,5),(6,1),(3,1),(4,1),(5,1)，因此该排列的逆序数就是 8。显然，由 1,2,…,n 构成的所有 n! 个排列中，最小的逆序数是 0，对应的排列就是 1,2,…,n；最大的逆序数是 n(n-1)/2，对应的排列就是 n,(n-1),…,2,1。逆序数越大的排列与原始排列的差异度就越大。</p>
<p>基本思路：</p>
<p>1.使用二分归并（分治法）进行求解； 2.将序列依此划分为两两相等的子序列； 3.对每个子序列进行排序（比较 <code>a[i] &gt; a[j]</code>，如果满足条件，则求该子序列的逆序数 <code>count = mid - i + 1</code>，其中 <code>mid = (left + right) / 2</code>） 4.接着合并子序列即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[t++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[t++] = a[j++];</span><br><span class="line">            count += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) a[left++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, left, mid, tmp);</span><br><span class="line">        mergeSort(a, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">        merge(a, left, mid, right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速选择算法">快速选择算法</h3>
<p>基本思想：</p>
<p>快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(nlogn)\)</span> 至 <span class="math inline">\(O(n)\)</span>，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;  <span class="comment">// 选择a[right]作为划分基准</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quick_select</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> a[left];</span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> quick_select(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_select(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性时间选择bfprt">线性时间选择（BFPRT）</h3>
<p>基本思路：</p>
<ul>
<li>首先把数组按 5 个数为一组进行分组，最后不足 5 个的忽略。对每组数进行排序（如插入排序）求取其中位数。</li>
<li>把上一步的所有中位数移到数组的前面，对这些中位数递归调用 BFPRT 算法求得他们的中位数。</li>
<li>将上一步得到的中位数作为划分的主元进行整个数组的划分。</li>
<li>判断第k个数在划分结果的左边、右边还是恰好是划分结果本身，前两者递归处理，后者直接返回答案。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = right; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) tmp = a[j], a[j] = a[j<span class="number">-1</span>], a[j<span class="number">-1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> baseIdx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;</span><br><span class="line">    <span class="comment">// 将基准放于数组尾部</span></span><br><span class="line">    tmp = a[right], a[right] = a[baseIdx], a[baseIdx] = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfprt</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt;= <span class="number">5</span>)&#123;  <span class="comment">// 小于等于5个数，直接排序得到结果</span></span><br><span class="line">        bubble_sort(a, left, right);</span><br><span class="line">        <span class="keyword">return</span> a[left + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = left - <span class="number">1</span>, tmp;  <span class="comment">// t:当前替换到前面的中位数的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st = left, ed; (ed = st + <span class="number">4</span>) &lt;= right; st += <span class="number">5</span>)&#123;</span><br><span class="line">        bubble_sort(a, st, ed);</span><br><span class="line">        <span class="comment">// 将中位数替换到数组前面，便于递归求取中位数的中位数</span></span><br><span class="line">        tmp = a[++t], a[t] = a[st+<span class="number">2</span>], a[st+<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> baseIdx = (left + t) &gt;&gt; <span class="number">1</span>; <span class="comment">// left到t的中位数的下标，作为主元的下标</span></span><br><span class="line">    bfprt(a, left, t, baseIdx - left + <span class="number">1</span>); <span class="comment">// 不关心中位数的值，保证中位数在正确的位置</span></span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right, baseIdx), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> bfprt(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> bfprt(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h3 id="基本步骤">基本步骤</h3>
<ul>
<li>找出最优解的性质，并刻划其结构特征。</li>
<li>递归地定义最优值。</li>
<li>以自底向上的方式计算出最优值。</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ul>
<h3 id="矩阵连乘">矩阵连乘</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">matrixChain</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span>[][] m, <span class="type">int</span>[][] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + r - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最优子结构">最优子结构</h3>
<p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<p>例如，矩阵连乘计算次序问题的最优解包含着其子问题的最优解，这种性质称为最优子结构性质。</p>
<p><strong>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</strong></p>
<h3 id="重叠子问题">重叠子问题</h3>
<p>在递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。</p>
<p>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</p>
<h3 id="lis最长单调递增子序列">LIS最长单调递增子序列</h3>
<p>设序列为 a[0:n-1]，记 b[i]：以 a[i] 为结尾元素的最长递增子序列的长度。</p>
<p>则序列 a 的最长递增子序列长度为：<code>max&#123;b[i]&#125;, 0&lt;=i&lt;n</code></p>
<p>如何求 b[i] ?</p>
<p><code>b[0] = 1</code>，<code>b[i] = max&#123;b[k]&#125; + 1, (0&lt;=k&lt;i, a[k]&lt;=a[i])</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">LIS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, b[<span class="number">0</span>] = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt;= a[i] &amp;&amp; k &lt; b[j]) k = b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] = k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lcs最长公共子序列">LCS最长公共子序列</h3>
<p>给定 2 个序列，<span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span>，找出 X 和 Y 的最长公共子序列。</p>
<p>设序列 <span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span> 的最长公共子序列为 <span class="math inline">\(Z={z_1,z_2,…,z_k}\)</span>，则</p>
<p>1)若 <span class="math inline">\(x_m=y_n\)</span>，则 <span class="math inline">\(z_k=x_m=y_n\)</span>，且 <span class="math inline">\(Z_{k-1}\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列。</p>
<p>2)若 <span class="math inline">\(x_m≠y_n\)</span>，则 <span class="math inline">\(Z\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y\)</span> 的最长公共子序列，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列，中较长的序列。</p>
<p><strong>2 个序列的最长公共子序列包含了这 2 个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。</strong></p>
<p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用 <span class="math inline">\(c[i][j]\)</span> 记录序列的最长公共子序列的长度。其中，<span class="math inline">\(X_i={x_1,x_2,…,x_i}\)</span>；<span class="math inline">\(Y_j={y_1,y_2,…,y_j}\)</span>。当 <span class="math inline">\(i=0\)</span> 或 <span class="math inline">\(j=0\)</span> 时，空序列是 <span class="math inline">\(X_i\)</span> 和 <span class="math inline">\(Y_j\)</span> 的最长公共子序列。故此时 <span class="math inline">\(c[i][j]=0\)</span>。其他情况下，由最优子结构性质可建立递归关系如下：</p>
<ul>
<li><code>i=0,j=0</code>：<code>c[i][j]=0</code></li>
<li><code>i,j&gt;0; x[i]==y[i]</code>：<code>c[i][j]=c[i-1][j-1]+1</code></li>
<li><code>i,j&gt;0; x[i]!=y[i]</code>：<code>c[i][j]=max&#123;c[i][j-1],c[i-1][j]&#125;</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(b); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Algorithm <span class="title">lcsLength</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">    m = x.length - <span class="number">1</span>;</span><br><span class="line">    n = y.length - <span class="number">1</span>;</span><br><span class="line">    c[i][<span class="number">0</span>] = <span class="number">0</span>; c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Algorithm <span class="title">lcs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> [] x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == y[i])&#123;</span><br><span class="line">        <span class="built_in">lcs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, x);</span><br><span class="line">        <span class="built_in">print</span>(x[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) <span class="built_in">lcs</span>(i<span class="number">-1</span>, j, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">lcs</span>(i, j<span class="number">-1</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治法与动态规划的区别">分治法与动态规划的区别</h3>
<ul>
<li>分治法与动态规划有何共同点？提示：从所适用问题的特点，解决问题的方式上阐述
<ul>
<li>两者所解决的问题，都能划分为若干个规模较小的子问题</li>
<li>这些子问题具有最优子结构性质</li>
<li>能通过子问题的最优解自底向上地得到问题的最优解</li>
</ul></li>
<li>分治法与动态规划又有何不同？提示：从子问题的角度阐述
<ul>
<li>分治法适用于子问题相互独立的情况，即子问题之间不存在公共子问题</li>
<li>动态规划适用于子问题存在重叠的情况，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果</li>
</ul></li>
</ul>
<h2 id="贪心算法">贪心算法</h2>
<h3 id="基本思想-1">基本思想</h3>
<p>贪心算法总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<h3 id="活动安排问题">活动安排问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列</span></span><br><span class="line"><span class="comment"> * a数组记录是否安排相应活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">greedySelector</span><span class="params">(<span class="type">int</span> [] s, <span class="type">int</span> [] f, <span class="type">boolean</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            a[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> a[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最优子结构性质">最优子结构性质</h3>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p>
<h3 id="贪心选择性质">贪心选择性质</h3>
<p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p>
<p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择。然后再去解做出这个选择后产生的相应的子问题。</p>
<p><strong>贪心算法和动态规划算法都要求问题具有最优子结构性质，这是两类算法的一个共同点。</strong></p>
<p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。（即证明有解必有贪心解）</p>
<h3 id="贪心算法求解背包问题">贪心算法求解背包问题</h3>
<p>基本步骤：</p>
<ul>
<li>首先计算每种物品单位重量的价值 <span class="math inline">\(V_i/W_i\)</span></li>
<li>然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包</li>
<li>若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。</li>
<li>依此策略一直地进行下去，直到背包装满为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">float</span>[] v,<span class="type">float</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], v[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i].w &gt; c) <span class="keyword">break</span>;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].v;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)&#123;</span><br><span class="line">        x[d[i].i] = c / d[i].w;</span><br><span class="line">        opt += x[d[i].i] * d[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 0-1 背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。</p>
<p>事实上，在考虑 0-1 背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。</p>
<h3 id="最优装载问题">最优装载问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">loading</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">int</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; d[i].w &lt;= c; i++) &#123;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].w;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼编码">哈夫曼编码</h2>
<h3 id="应用">应用</h3>
<p>哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<h3 id="构造哈夫曼编码">构造哈夫曼编码</h3>
<ul>
<li>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树 T。</li>
<li>算法以 C 个叶结点开始，执行 C-1 次的“合并”运算后产生最终所要求的树 T。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/891129703366840b1bac668d27b5cd11.png" alt="huffman-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/af9941f332989278833bd160b2a58181.png" alt="huffman-2"></p>
<h2 id="单源最短路径">单源最短路径</h2>
<h3 id="单源最短路问题">单源最短路问题</h3>
<p>给定带权有向图 G=(V,E)，其中每条边的权是非负实数。另外，还给定 V 中的一个顶点，称为源。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。</p>
<h3 id="dijkstra-算法">Dijkstra 算法</h3>
<p>Dijkstra 算法是解单源最短路径问题的贪心算法。其基本思想是，设置顶点集合 S 并不断地作贪心选择来扩充这个集合。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。</p>
<p>基本步骤：</p>
<ul>
<li>初始时，S 中仅含有源。</li>
<li>设 u 是 G 的某一个顶点，把从源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路径，并用数组 dist 记录当前每个顶点所对应的最短特殊路径长度。</li>
<li>Dijkstra 算法每次从 V-S 中取出具有最短特殊路长度的顶点 u，将 u 添加到 S 中，同时对数组 dist 作必要的修改。</li>
<li>一旦 S 包含了所有 V 中顶点，dist 就记录了从源到所有其他顶点之间的最短路径长度。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> dist[MAX_V];  <span class="comment">// 顶点s出发的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 已经使用过的图</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求从起点s出发到各个顶点的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + V, INF);</span><br><span class="line">    <span class="built_in">fill</span>(used, used + V, <span class="literal">false</span>);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从尚未使用过的顶点中选择一个距离最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || dist[u] &lt; dist[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            dist[u] = <span class="built_in">min</span>(dist[u], dist[v] + cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="定义-1">定义</h3>
<p>设 <span class="math inline">\(G =(V,E)\)</span> 是无向连通带权图，即一个网络。<span class="math inline">\(E\)</span> 中每条边 <span class="math inline">\((v,w)\)</span> 的权为 <span class="math inline">\(c[v][w]\)</span>。如果 <span class="math inline">\(G\)</span> 的子图 <span class="math inline">\(G’\)</span> 是一棵包含 <span class="math inline">\(G\)</span> 的所有顶点的树，则称 <span class="math inline">\(G’\)</span> 为 <span class="math inline">\(G\)</span> 的生成树。生成树上各边权的总和称为该生成树的耗费。在 <span class="math inline">\(G\)</span> 的所有生成树中，耗费最小的生成树称为 <span class="math inline">\(G\)</span> 的最小生成树。</p>
<h3 id="最小生成树性质">最小生成树性质</h3>
<p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的真子集。如果 <span class="math inline">\((u,v) \in E\)</span>，且 <span class="math inline">\(u \in U\)</span>，<span class="math inline">\(v \in V-U\)</span>，且在所有这样的边中，<span class="math inline">\((u,v)\)</span> 的权 <span class="math inline">\(c[u][v]\)</span> 最小，那么一定存在 <span class="math inline">\(G\)</span> 的一棵最小生成树，它以 <span class="math inline">\((u,v)\)</span> 为其中一条边。这个性质有时也称为 MST 性质。</p>
<h3 id="prim算法">Prim算法</h3>
<p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(V={1,2,…,n}\)</span>。构造 <span class="math inline">\(G\)</span> 的最小生成树的 Prim 算法的基本思想是：</p>
<ul>
<li>首先置 <span class="math inline">\(S=\{1\}\)</span>，</li>
<li>然后，只要 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(V\)</span> 的真子集，就作如下的贪心选择</li>
<li>选取满足条件 <span class="math inline">\(i \in S\)</span>，<span class="math inline">\(j \in V-S\)</span>，且 <span class="math inline">\(c[i][j]\)</span> 最小的边，将顶点j添加到 <span class="math inline">\(S\)</span> 中。</li>
<li>这个过程一直进行到 <span class="math inline">\(S=V\)</span> 时为止。在这个过程中选取到的所有边恰好构成 G 的一棵最小生成树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> mistcost[MAX_V];  <span class="comment">// 从集合X出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 顶点i是否包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从不属于X的顶点中选取从X到其权值最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;  <span class="comment">// 把顶点v加入X</span></span><br><span class="line">        res += mincost[v];  <span class="comment">// 把边的长度加到结果里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kruskal-算法">Kruskal 算法</h3>
<p>Kruskal 算法构造 <span class="math inline">\(G\)</span> 的最小生成树的基本思想是：</p>
<ul>
<li>首先将 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(n\)</span> 个顶点看成 <span class="math inline">\(n\)</span> 个孤立的连通分支。</li>
<li>将所有的边按权从小到大排序。</li>
<li>然后从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接 2 个不同的连通分支</li>
<li>当查看到第 <span class="math inline">\(k\)</span> 条边 <span class="math inline">\((v,w)\)</span> 时，如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 分别是当前 2 个不同的连通分支 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 中的顶点时，就用边 <span class="math inline">\((v,w)\)</span> 将 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 连接成一个连通分支，然后继续查看第 <span class="math inline">\(k+1\)</span> 条边；</li>
<li>如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 在当前的同一个连通分支中，就直接再查看第 <span class="math inline">\(k+1\)</span> 条边。</li>
<li>这个过程一直进行到只剩下一个连通分支时为止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge &amp;e1, <span class="type">const</span> edge &amp;e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V, E;  <span class="comment">// 顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">krustral</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(es, es + E, comp);  <span class="comment">// 按照edge.cost的顺序从小到大排列</span></span><br><span class="line">    <span class="built_in">init_union_find</span>(V);  <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">        edge e = es[i];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">same</span>(e.u, e.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">并查集</h2>
<h3 id="主要操作">主要操作</h3>
<ul>
<li>初始化 集合中每个元素单独作为一个子集。</li>
<li>查找 查找元素 x 所在的子集序号。常用来判断元素 x 和 y 是否在同一子集中。</li>
<li>合并 将元素 x 和 y 分别所在的子集合并为一个子集。</li>
</ul>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用编号代表每个元素，数组par表示父亲的编号，当par[x]=x时，x是所在树的树根</span></span><br><span class="line"><span class="type">int</span> par[MAX_N];  <span class="comment">// 父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N];  <span class="comment">// 树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优先队列">优先队列</h2>
<h3 id="主要操作-1">主要操作</h3>
<ul>
<li>初始化 将给定多个元素初始化为优先队列。</li>
<li>出队 将优先权最大的元素x出队，并调整结构为优先队列。</li>
<li>入队 加入元素x，并调整结构为优先队列。</li>
</ul>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点从0开始编号</span></span><br><span class="line"><span class="type">int</span> heap[MAX_N], sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己节点的编号</span></span><br><span class="line">    <span class="type">int</span> i = sz++;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父亲节点的编号</span></span><br><span class="line">        <span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把父亲节点的数组放下来，而把自己提上去</span></span><br><span class="line">        heap[i] = heap[p];</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    <span class="type">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 要提到根的数值</span></span><br><span class="line">    <span class="type">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">// 从根开始向下交换</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">// 比较儿子的值</span></span><br><span class="line">        <span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把儿子的数值提上来</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i = a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯法">回溯法</h2>
<h3 id="定义-2">定义</h3>
<p>为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法。</p>
<h3 id="基本思想-2">基本思想</h3>
<ul>
<li>针对所给问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构；</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>
<p><strong>常用剪枝函数：用约束函数在扩展结点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。</strong> 这种方法适用于解一些组合数相当大的问题。</p>
<h3 id="回溯法的特征">回溯法的特征</h3>
<p>用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为 <span class="math inline">\(h(n)\)</span>，则回溯法所需的计算空间通常为 <span class="math inline">\(O(h(n))\)</span>。</p>
<h3 id="递归回溯">递归回溯</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">            x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代回溯">迭代回溯</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterativeBacktrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(n,t) &lt;= <span class="built_in">g</span>(n,t))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">                x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">solution</span>(t)) <span class="built_in">output</span>(x);</span><br><span class="line">                    <span class="keyword">else</span> t++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求s的所有元素个数小于4的子集">求S的所有元素个数小于4的子集</h3>
<p>已知集合 <span class="math inline">\(S=\{a,b,c,d,e,f,g\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素个数小于 4 的子集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;a,b,c,d,e,f,g&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(x, t) &lt; <span class="number">4</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求s的所有元素和小于8的子集">求S的所有元素和小于8的子集</h3>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素和小于 8 的子集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sum</span>(x, t) &lt; <span class="number">8</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求s满足元素奇偶性相同且和小于8的子集">求S满足元素奇偶性相同且和小于8的子集</h3>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有满足下列条件的子集：元素奇偶性相同，且和小于 8。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t, <span class="type">int</span> sum, <span class="type">int</span> prior)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x[t] = <span class="number">0</span>, <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, prior);</span><br><span class="line">        x[t] = <span class="number">1</span>;</span><br><span class="line">        sum += s[t];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">8</span> &amp;&amp; (prior == <span class="number">-1</span> || (s[t] - s[prior]) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求s的所有排列">求S的所有排列</h3>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 S 的所有排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求s的所有满足奇偶数相间出现的排列">求S的所有满足奇偶数相间出现的排列</h3>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7,8\}\)</span>，请编程输出 S 的所有满足下列条件的排列：奇偶数相间出现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>) bRet &amp;&amp;= ((s[t - <span class="number">1</span>] - s[t]) % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题">0-1 背包问题</h3>
<p>重量 <span class="math inline">\(w=\{2,2,3,4,5,5,6\}\)</span>， 价值 <span class="math inline">\(v=\{3,4,3,4,5,8,7\}\)</span>，<span class="math inline">\(C=16\)</span>，求背包的最大价值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">int</span> C = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> w[n] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> v[n] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>], Max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">process</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        sum += x[i] * w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += x[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Max &lt; sum) Max = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装载问题">装载问题</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="comment">// 搜索第i层结点</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) &#123;  <span class="comment">//到达叶结点更新最优解bestx</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r -= w[i];</span><br><span class="line">    <span class="keyword">if</span> (cw + w[i] &lt;= c) &#123;  <span class="comment">// 搜索左子树</span></span><br><span class="line">        x[i] = <span class="number">1</span>;</span><br><span class="line">        cw += w[i];</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cw + r &gt; bestw)  &#123;  <span class="comment">// 搜索右子树</span></span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r += w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n皇后问题">n皇后问题</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">place</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(k - j) == <span class="built_in">abs</span>(x[j] - x[k])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">place</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>lu wenye
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.wylu.me/posts/3274548c/" title="算法设计与分析">https://www.wylu.me/posts/3274548c/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/data-structure/" rel="tag"><i class="fa fa-tag"></i> data-structure</a>
              <a href="/tags/algorithm/" rel="tag"><i class="fa fa-tag"></i> algorithm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/6a7a0bd6/" rel="prev" title="CentOS7下Firewall的设置与使用">
                  <i class="fa fa-chevron-left"></i> CentOS7下Firewall的设置与使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/85807abd/" rel="next" title="RabbitMQ高可用集群搭建">
                  RabbitMQ高可用集群搭建 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-changyan">changyan</a></li>
            <li class="tab"><a href="#comment-disqus">disqus</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane changyan" id="comment-changyan">
              <div class="comments" id="SOHUCS" sid="6238ab2a1873b0cbfea0259992e5d4a9"></div>
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wylu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">131k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:58</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/wylu" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywofsGy5","appkey":"81e9ec55ee07f76c5500fc2df8517c62","count":false}</script>
<script src="/js/third-party/comments/changyan.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"wylu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
