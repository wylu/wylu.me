<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>wylu blog</title>
    <url>/posts/f6bd2bb1/</url>
    <content><![CDATA[<div class="note info no-icon"><h3 id="welcome-to-wylus-blog">Welcome to wylu's Blog</h3>
</div>
]]></content>
  </entry>
  <entry>
    <title>二进制部署 k8s 集群 1.23.6 版本</title>
    <url>/posts/b4d8958f/</url>
    <content><![CDATA[<p>通过本文的指导，读者可以了解如何通过二进制的方式部署 Kubernetes 1.23.6 版本集群。二进制部署可以加深对 Kubernetes 各组件的理解，可以灵活地将各个组件部署到不同的机器，以满足自身的要求。但是需要注意的是，二进制部署需要手动配置各个组件，需要一定的技术水平和经验。</p>
<span id="more"></span>
<h1 id="二进制部署-k8s-集群-1.23.6-版本">二进制部署 k8s 集群 1.23.6 版本</h1>
<h2 id="环境介绍">1. 环境介绍</h2>
<p>虽然 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/">kubeadm</a>, <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kops/">kops</a>, <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubespray/">kubespray</a> 以及 <a href="https://docs.rancher.cn/rke/">rke</a>, <a href="https://kubesphere.io/zh/docs/">kubesphere</a> 等工具可以快速部署 K8s 集群，但是依然会有很多人热衷与使用二进制部署 K8s 集群。</p>
<p>二进制部署可以加深对 K8s 各组件的理解，可以灵活地将各个组件部署到不同的机器，以满足自身的要求。还可以生成一个超长时间自签证书，比如 99 年，免去忘记更新证书过期带来的生产事故。</p>
<h3 id="书写约定">1.1 书写约定</h3>
<ul>
<li>命令行输入，均以 <code>➜</code> 符号表示</li>
<li>注释使用 <code>#</code> 或 <code>//</code> 表示</li>
<li>执行命令输出结果，以空行分隔</li>
</ul>
<h3 id="规划">1.2 规划</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>角色</th>
<th>主机名</th>
<th>IP</th>
<th>组件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>master</td>
<td>cnode0</td>
<td>10.128.170.20</td>
<td>etcd, kube-apiserver, kube-controller-manager, kube-scheduler, kube-proxy, kubelet</td>
</tr>
<tr class="even">
<td>node1</td>
<td>cnode1</td>
<td>10.128.170.21</td>
<td>kubelet, kube-proxy</td>
</tr>
</tbody>
</table>
<h3 id="环境配置">1.3 环境配置</h3>
<ul>
<li><p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl stop firewalld</span><br><span class="line">➜ systemctl disable firewalld</span><br></pre></td></tr></table></figure></li>
<li><p>关闭 selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ setenforce 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure></li>
<li><p>关闭 swap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>
<p>使用 <code>-r</code> 选项可以使用扩展正则表达式，这提供了一种更强大和灵活的方式来匹配文本中的模式。</p>
<p>使用正则表达式 <code>.*swap.*</code> 匹配包含 swap 字符串的行，并在行首添加 # 符号，&amp; 表示匹配到的整个字符串。</p></li>
<li><p>设置主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.20 主机</span></span><br><span class="line">➜ hostnamectl set-hostname cnode0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.21 主机</span></span><br><span class="line">➜ hostnamectl set-hostname cnode1</span><br></pre></td></tr></table></figure></li>
<li><p>时间同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">➜ timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装时间同步服务</span></span><br><span class="line">➜ yum install chrony -y</span><br><span class="line">➜ systemctl enable --now chronyd</span><br></pre></td></tr></table></figure></li>
<li><p>主机名解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">10.128.170.20 cnode0 cnode0.com</span><br><span class="line">10.128.170.21 cnode1 cnode1.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li><p>将桥接的 IPv4 流量传递到 iptables 的链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">➜ sysctl --system</span><br></pre></td></tr></table></figure></li>
<li><p>设置文件描述符限制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ ulimit -SHn 65535</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ echo &quot;*      -      nofile   65535&quot; &gt;&gt;/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>用于设置当前用户的最大文件描述符数限制。具体来说，它的作用是将当前用户的软限制和硬限制都设置为 65535。</p></li>
<li><p>更新 epel 源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ yum install epel-release -y</span><br></pre></td></tr></table></figure>
<p>如需换源，请参考：<a href="https://developer.aliyun.com/mirror/epel" class="uri">https://developer.aliyun.com/mirror/epel</a></p></li>
<li><p>加载 ipvs 模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ yum install ipset ipvsadm -y</span><br><span class="line">➜ cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt; &quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">➜ chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">➜ /bin/bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">➜ lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<ul>
<li>modprobe -- ip_vs: 加载 ip_vs 内核模块，该模块提供了 Linux 内核中的 IP 负载均衡功能。</li>
<li>modprobe -- ip_vs_rr: 加载 ip_vs_rr 内核模块，该模块提供了基于轮询算法的 IP 负载均衡策略。</li>
<li>modprobe -- ip_vs_wrr: 加载 ip_vs_wrr 内核模块，该模块提供了基于加权轮询算法的 IP 负载均衡策略。</li>
<li>modprobe -- ip_vs_sh: 加载 ip_vs_sh 内核模块，该模块提供了基于哈希算法的 IP 负载均衡策略。</li>
<li>modprobe -- nf_conntrack_ipv4: 加载 nf_conntrack_ipv4 内核模块，该模块提供了 Linux 内核中的网络连接跟踪功能，用于跟踪网络连接的状态。</li>
</ul>
<p>这些命令通常用于配置 Linux 系统中的负载均衡和网络连接跟踪功能。在加载这些内核模块之后，就可以使用相应的工具和命令来配置和管理负载均衡和网络连接跟踪。例如，可以使用 ipvsadm 命令来配置 IP 负载均衡，使用 conntrack 命令来查看和管理网络连接跟踪表。</p>
<p>如果提示如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;modprobe: FATAL: Module nf_conntrack_ipv4 not found in directory /lib/modules/4.18.0-372.9.1.el8.x86_64&quot;</span><br></pre></td></tr></table></figure>
<p>则需要将 <code>nf_conntrack_ipv4</code> 修改为 <code>nf_conntrack</code>，然后重新执行命令，因为在高版本内核中已经把 nf_conntrack_ipv4 替换为 nf_conntrack。</p>
<p>nf_conntrack_ipv4 和 nf_conntrack 都是 Linux 内核中的网络连接跟踪模块，用于跟踪网络连接的状态。它们的区别在于：</p>
<ul>
<li>nf_conntrack_ipv4 模块只能跟踪 IPv4 协议的网络连接，而 nf_conntrack 模块可以跟踪 IPv4 和 IPv6 协议的网络连接。</li>
<li>nf_conntrack_ipv4 模块是 nf_conntrack 模块的一个子模块，它提供了 IPv4 协议的网络连接跟踪功能。因此，如果要使用 nf_conntrack_ipv4 模块，必须先加载 nf_conntrack 模块。</li>
</ul>
<p>这两个模块通常用于 Linux 系统中的网络安全和网络性能优化。它们可以被用于防火墙、负载均衡、网络流量分析等场景中，以便对网络连接进行跟踪、监控和控制。例如，可以使用 iptables 命令和 nf_conntrack 模块来实现基于连接状态的防火墙规则，或者使用 ipvsadm 命令和 nf_conntrack 模块来实现 IP 负载均衡。</p>
<ul>
<li><a href="https://www.cnblogs.com/xiangsikai/p/9525287.html">Linux 跟踪连接netfilter 调优</a></li>
<li><a href="https://clodfisher.github.io/2018/09/nf_conntrack/">Iptables之nf_conntrack模块</a></li>
</ul></li>
<li><p>免密登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了便捷操作,在 cnode0 上创建免密登录其他节点</span></span><br><span class="line">➜ ssh-keygen -t rsa</span><br><span class="line">➜ ssh-copy-id cnode1</span><br><span class="line">➜ ssh-copy-id cnode2</span><br><span class="line">➜ ssh-copy-id cnode3</span><br></pre></td></tr></table></figure></li>
<li><p>创建 kubernetes 证书存放目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ mkdir -p /etc/kubernetes/pki</span><br></pre></td></tr></table></figure></li>
<li><p>重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ reboot</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="下载-k8s-二进制程序">1.4 下载 k8s 二进制程序</h3>
<p>从官方发布地址下载二进制包 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md">下载地址</a></p>
<p>下载 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md#server-binaries">Server Binaries</a> 即可，这个包含了所有所需的二进制文件。解压后，复制二进制 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-proxy</code>,<code>kubelet</code>, <code>kubectl</code> 到 master 节点 <code>/usr/local/bin</code> 目录下，复制二进制 <code>kube-proxy</code>,<code>kubelet</code> 到 worker 节点 <code>/usr/local/bin</code> 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ll /usr/local/bin/kube*</span><br><span class="line"></span><br><span class="line">-rwxr-xr-x 1 root root 128516096 Dec 29 14:59 /usr/local/bin/kube-apiserver</span><br><span class="line">-rwxr-xr-x 1 root root 118489088 Dec 29 14:59 /usr/local/bin/kube-controller-manager</span><br><span class="line">-rwxr-xr-x 1 root root  46202880 Dec 29 14:59 /usr/local/bin/kubectl</span><br><span class="line">-rwxr-xr-x 1 root root 122352824 Dec 29 14:59 /usr/local/bin/kubelet</span><br><span class="line">-rwxr-xr-x 1 root root  43581440 Dec 29 14:59 /usr/local/bin/kube-proxy</span><br><span class="line">-rwxr-xr-x 1 root root  49020928 Dec 29 14:59 /usr/local/bin/kube-scheduler</span><br></pre></td></tr></table></figure>
<h2 id="安装-docker">2. 安装 docker</h2>
<p>参考地址 <a href="https://docs.docker.com/engine/install/centos/">安装docker</a>，Docker 需要在各个节点上安装</p>
<ul>
<li><p>切换镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前镜像源中支持的 docker 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates</span><br></pre></td></tr></table></figure></li>
<li><p>安装特定版本的 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install --setopt=obsoletes=0 docker-ce-20.10.14 -y</span><br></pre></td></tr></table></figure>
<p><code>--setopt=obsoletes=0</code> 是 yum 包管理器的一个选项，它的作用是禁用软件包依赖关系中的版本升级。</p></li>
<li><p>添加配置文件</p>
<p>Docker 在默认情况下使用的 Cgroup Driver 为 cgroupfs，而 Kubernetes 推荐使用 systemd 来替代 cgroupfs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li><p>启动 dokcer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建-ca-证书">3. 创建 ca 证书</h2>
<h3 id="安装-cfssl">3.1 安装 cfssl</h3>
<p>cfssl 是一款证书签署工具，使用 cfssl 工具可以很简化证书签署过程，方便颁发自签证书。</p>
<p>CloudFlare's distributes <a href="https://github.com/cloudflare/cfssl">cfssl</a> source code on github page and binaries on <a href="https://pkg.cfssl.org/">cfssl website</a>.</p>
<p>Our documentation assumes that you will run <a href="https://github.com/cloudflare/cfssl">cfssl</a> on your local x86_64 Linux host.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s -L -o /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">curl -s -L -o /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">chmod +x /usr/local/bin/&#123;cfssl,cfssljson&#125;</span><br></pre></td></tr></table></figure>
<p>离线安装的情况，直接把两个文件下载下来重命名即可</p>
<h3 id="创建-ca-证书-1">3.2 创建 ca 证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建的证书统一放到 /etc/kubernetes/ssl 目录，创建后复制到 /etc/kubernetes/pki 目录</span></span><br><span class="line">➜ mkdir /etc/kubernetes/ssl</span><br><span class="line"></span><br><span class="line">➜ cd /etc/kubernetes/ssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca 证书创建申请</span></span><br><span class="line">➜ cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ca&quot;: &#123;</span><br><span class="line">        &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 ca 证书</span></span><br><span class="line">➜ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll ca*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:32 ca-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1314 Dec 30 11:32 ca.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 ca 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp ca*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<p>ca-csr.json 这个文件是 Kubernetes 集群中使用的证书颁发机构 (CA) 证书签名请求 (CSR) 配置文件，用于定义 CA 的证书签名请求配置。</p>
<p>在这个配置文件中，CN 字段指定了证书的通用名称为 kubernetes，key 字段指定了证书的密钥算法为 RSA，密钥长度为 2048 位。names 字段定义了证书的其他信息，如国家、省份、城市、组织和组织单位等。ca 字段指定了证书的过期时间为 87600 小时（即 10 年）。</p>
<p>这个配置文件用于创建 Kubernetes 集群中的 CA 证书，以便对集群中的其他证书进行签名和认证。</p>
<ul>
<li>CN(Common Name): kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)</li>
<li>names[].O(Organization): kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)</li>
</ul>
<p>由于这里是 CA 证书，是签发其它证书的根证书，这个证书密钥不会分发出去作为 client 证书，所有组件使用的 client 证书都是由 CA 证书签发而来，所以 CA 证书的 CN 和 O 的名称并不重要，后续其它签发出来的证书的 CN 和 O 的名称才是有用的。</p>
<h3 id="创建签发配置文件">3.3 创建签发配置文件</h3>
<p>由于各个组件都需要配置证书，并且依赖 CA 证书来签发证书，所以我们首先要生成好 CA 证书以及后续的签发配置文件。</p>
<p>创建用于签发其它证书的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">证书签发配置文件</span></span><br><span class="line">➜ cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;signing&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &#123;</span><br><span class="line">            &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;kubernetes&quot;: &#123;</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">                    &quot;signing&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;server auth&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>ca-config.json 这个文件是签发其它证书的配置文件，用于定义签名配置和证书配置。其中，signing 字段定义了签名配置，profiles 字段定义了不同场景下的证书配置。</p>
<p>在这个配置文件中，default 配置指定了默认的证书过期时间为 87600 小时（即 10 年），profiles 配置定义了一个名为 kubernetes 的证书配置，它指定了证书的用途（签名、密钥加密、服务器认证和客户端认证）和过期时间。</p>
<p>这个配置文件用于创建 Kubernetes 集群中的证书和密钥，以便对集群进行安全认证和加密通信。</p>
<ul>
<li>signing：定义了签名配置，包括默认的签名过期时间和各个证书配置的签名过期时间。</li>
<li>profiles：定义了不同场景下的证书配置，包括证书的用途、过期时间和其他属性。</li>
</ul>
<p>在使用 cfssl gencert 命令生成证书时，可以使用 <code>-config</code> 参数指定配置文件，以便根据配置文件中的规则生成符合要求的证书。如果不指定 <code>-config</code> 参数，则 cfssl gencert 命令将使用默认的配置文件。</p>
<h2 id="部署-etcd">4. 部署 etcd</h2>
<p>etcd 版本选择的是最新版本 3.5.1，下载二进制 <a href="https://github.com/etcd-io/etcd/releases/tag/v3.5.1">etcd下载链接</a></p>
<h3 id="颁发证书">4.1 颁发证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">etcd 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有 etcd 集群节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。</span></span><br><span class="line">➜ cat &gt; etcd-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 etcd 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll etcd*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 11:32 etcd-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1440 Dec 30 11:32 etcd.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 etcd 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp etcd*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<h3 id="部署-etcd-1">4.2 部署 etcd</h3>
<p>下载二进制 <a href="https://github.com/etcd-io/etcd/releases/tag/v3.5.1">etcd下载链接</a>并解压，将二进制程序 <code>etcd</code> <code>etcdctl</code> 复制到 <code>/usr/local/bin</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ll /usr/local/bin/etcd*</span><br><span class="line"></span><br><span class="line">-rwxrwxr-x 1 root root 21823488 Dec 29 14:13 /usr/local/bin/etcd</span><br><span class="line">-rwxrwxr-x 1 root root 16711680 Dec 29 14:13 /usr/local/bin/etcdctl</span><br></pre></td></tr></table></figure>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ mkdir /etc/etcd</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/etcd/etcd.conf &lt;&lt; EOF</span><br><span class="line">ETCD_NAME=&quot;etcd1&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://10.128.170.20:2379&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://10.128.170.20:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd1=https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件解释</span></span><br><span class="line">ETCD_NAME：节点名称，集群中唯一</span><br><span class="line">ETCD_DATA_DIR： 数据保存目录</span><br><span class="line">ETCD_LISTEN_PEER_URLS：集群内部通信监听地址</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</span><br><span class="line">ETCD_INITIAL_CLUSTER：集群节点地址列表</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN：集群通信token</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群</span><br></pre></td></tr></table></figure>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据目录</span></span><br><span class="line">➜ mkdir -p /var/lib/etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建系统服务</span></span><br><span class="line">➜ cat &gt; /lib/systemd/system/etcd.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=etcd server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/etc/etcd/etcd.conf</span><br><span class="line">WorkingDirectory=/var/lib/etcd</span><br><span class="line">ExecStart=/usr/local/bin/etcd \</span><br><span class="line">  --cert-file=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --key-file=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --trusted-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --peer-cert-file=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --peer-key-file=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --peer-trusted-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --peer-client-cert-auth \</span><br><span class="line">  --client-cert-auth</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 etcd 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u etcd</span><br></pre></td></tr></table></figure>
<h2 id="部署-kube-apiserver">5. 部署 kube-apiserver</h2>
<h3 id="颁发证书-1">5.1 颁发证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-apiserver 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有 kube-apiserver 节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.20 10.128.170.21 10.128.170.22 10.128.170.23 10.128.170.24 10.128.170.25</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.96.0.1 是 service 网段的第一个 IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes.default.svc.cluster.local 这一串是 kube-apiserver 的 service 域名</span></span><br><span class="line">➜ cat &gt; kube-apiserver-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;,</span><br><span class="line">        &quot;10.96.0.1&quot;,</span><br><span class="line">        &quot;kubernetes&quot;,</span><br><span class="line">        &quot;kubernetes.default&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-apiserver 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-apiserver-csr.json | cfssljson -bare kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-apiserver*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:33 kube-apiserver-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1590 Dec 30 11:33 kube-apiserver.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-apiserver 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-apiserver*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<h3 id="部署-kube-apiserver-1">5.2 部署 kube-apiserver</h3>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-apiserver.conf &lt;&lt; EOF</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=0.0.0.0 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --insecure-port=0 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/etc/kubernetes/token.csv \</span><br><span class="line">  --service-node-port-range=30000-32767 \</span><br><span class="line">  --tls-cert-file=/etc/kubernetes/pki/kube-apiserver.pem \</span><br><span class="line">  --tls-private-key-file=/etc/kubernetes/pki/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/etc/kubernetes/pki/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/etc/kubernetes/pki/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --service-account-issuer=https://kubernetes.default.svc.cluster.local \</span><br><span class="line">  --etcd-cafile=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --etcd-certfile=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://10.128.170.21:2379 \</span><br><span class="line">  --enable-swagger-ui=true \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=1 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/var/log/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 etcd 是一个集群，则 <code>--etcd-servers</code> 可以添加多个，例如：<code>--etcd-servers=https://10.128.170.21:2379,https://10.128.170.22:2379,https://10.128.170.23:2379</code></p>
</blockquote>
<p>生成 token 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/token.csv &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">head</span> -c 16 /dev/urandom | <span class="built_in">od</span> -An -t x | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>),kubelet-bootstrap,10001,<span class="string">&quot;system:node-bootstrapper&quot;</span></span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个命令中，<code>head -c 16 /dev/urandom | od -An -t x | tr -d ' '</code> 生成了一个 16 字节的随机字符串，并将其转换为十六进制格式。这个字符串将作为令牌的值。</p>
<ul>
<li>kubelet-bootstrap 是令牌的用户名</li>
<li>10001 是令牌的 UID，</li>
<li>system:node-bootstrapper 是令牌的组名。</li>
</ul>
<p>这些值将用于 kubelet 节点的身份验证和授权。</p>
</blockquote>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-apiserver.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-apiserver $KUBE_APISERVER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 kube-apiserver 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-apiserver</span><br></pre></td></tr></table></figure>
<h2 id="部署-kubectl">6. 部署 kubectl</h2>
<p>部署完 kube-apiserver 后，就可以部署 kubectl 了，因为 kubectl 可以验证 kube-apiserver 是否已经正常工作了。</p>
<h3 id="颁发证书-2">6.1 颁发证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">O 参数的值必须为 system:masters，因为这是 kube-apiserver 一个内置好的角色，拥有集群管理的权限</span></span><br><span class="line">➜ cat &gt; kubectl-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;clusteradmin&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:masters&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kubectl 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubectl-csr.json | cfssljson -bare kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kubectl*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:34 kubectl-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1415 Dec 30 11:34 kubectl.pem</span><br></pre></td></tr></table></figure>
<h3 id="生成配置文件">6.2 生成配置文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials clusteradmin --client-certificate=kubectl.pem --client-key=kubectl-key.pem --embed-certs=true --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context kubernetes --cluster=kubernetes --user=clusteradmin --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context kubernetes --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ mkdir -p ~/.kube</span><br><span class="line"></span><br><span class="line">➜ cp kube.config ~/.kube/config</span><br></pre></td></tr></table></figure>
<p>以上命令用于在本地创建一个 Kubernetes 配置文件 kube.config，并将其复制到 ~/.kube/config 文件中，以便使用 kubectl 命令与 Kubernetes 集群进行交互。</p>
<blockquote>
<p>kubectl config set-cluster 命令设置了一个名为 kubernetes 的集群，指定了以下参数：</p>
<ul>
<li>--certificate-authority=ca.pem：指定 CA 证书文件的路径。</li>
<li>--embed-certs=true：将 CA 证书嵌入到配置文件中。</li>
<li>--server=https://10.128.170.20:6443：指定 API Server 的地址和端口。</li>
<li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li>
</ul>
<p>这些参数将用于创建一个名为 kubernetes 的集群配置，并将其写入到 kube.config 文件中。</p>
<p>kubectl config set-credentials 命令设置了一个名为 clusteradmin 的用户，指定了以下参数：</p>
<ul>
<li>--client-certificate=kubectl.pem：指定客户端证书文件的路径。</li>
<li>--client-key=kubectl-key.pem：指定客户端私钥文件的路径。</li>
<li>--embed-certs=true：将客户端证书和私钥嵌入到配置文件中。</li>
<li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li>
</ul>
<p>这些参数将用于创建一个名为 clusteradmin 的用户配置，并将其写入到 kube.config 文件中。</p>
<p>kubectl config set-context 命令设置了一个名为 kubernetes 的上下文，指定了以下参数：</p>
<ul>
<li>--cluster=kubernetes：指定要使用的集群。</li>
<li>--user=clusteradmin：指定要使用的用户。</li>
<li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li>
</ul>
<p>这些参数将用于创建一个名为 kubernetes 的上下文配置，并将其写入到 kube.config 文件中。</p>
<p>kubectl config use-context 命令将当前上下文设置为 kubernetes，指定了以下参数：</p>
<ul>
<li>--kubeconfig=kube.config：指定要使用的配置文件路径。</li>
</ul>
<p>这个命令将当前上下文设置为 kubernetes，以便 kubectl 命令可以使用 kube.config 文件与 Kubernetes 集群进行交互。</p>
</blockquote>
<h3 id="获取集群信息">6.3 获取集群信息</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl cluster-info</span><br><span class="line"></span><br><span class="line">Kubernetes control plane is running at https://10.128.170.20:6443</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br><span class="line"></span><br><span class="line">➜ kubectl get all -A</span><br><span class="line"></span><br><span class="line">NAMESPACE   NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">default     service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   22m</span><br><span class="line"></span><br><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                        ERROR</span><br><span class="line">scheduler            Unhealthy   Get &quot;https://127.0.0.1:10259/healthz&quot;: dial tcp 127.0.0.1:10259: connect: connection refused</span><br><span class="line">controller-manager   Unhealthy   Get &quot;https://127.0.0.1:10257/healthz&quot;: dial tcp 127.0.0.1:10257: connect: connection refused</span><br><span class="line">etcd-0               Healthy     &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置-kubectl-自动补全">6.4 设置 kubectl 自动补全</h3>
<p>查看 kubectl 命令自动补全帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl completion --help</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">安装 bash-completion：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">yum install bash-completion -y</span><br></pre></td></tr></table></figure>
<p>设置 kubectl 自动补全配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">````</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 7. 部署 kube-controller-manager</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 7.1 颁发证书</span></span></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-controller-manager 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line">➜ cat &gt; kube-controller-manager-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-controller-manager 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-controller-manager*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 12:13 kube-controller-manager-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1513 Dec 30 12:13 kube-controller-manager.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-controler-manager 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-controller-manager*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<p>system:kube-controller-manager 是 Kubernetes 中的一个预定义 RBAC 角色，用于授权 kube-controller-manager 组件对 Kubernetes API 的访问。详细介绍请参考官方文档：<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings" class="uri">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings</a></p>
<h3 id="部署-kube-controller-manager">7.2 部署 kube-controller-manager</h3>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-controller-manager.conf &lt;&lt; EOF</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--port=0 \</span><br><span class="line">  --secure-port=10257 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --cluster-signing-duration=87600h \</span><br><span class="line">  --tls-cert-file=/etc/kubernetes/pki/kube-controller-manager.pem \</span><br><span class="line">  --tls-private-key-file=/etc/kubernetes/pki/kube-controller-manager-key.pem \</span><br><span class="line">  --service-account-private-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --root-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --controllers=*,bootstrapsigner,tokencleaner \</span><br><span class="line">  --use-service-account-credentials=true \</span><br><span class="line">  --horizontal-pod-autoscaler-sync-period=10s \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line">  --cluster-cidr=10.240.0.0/12 \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>生成 kubeconfig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-controller-manager --client-certificate=kube-controller-manager.pem --client-key=kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-controller-manager.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes controller manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-controller-manager.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 kube-controller-manager 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-controller-manager</span><br></pre></td></tr></table></figure>
<p>查看组件状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                        ERROR</span><br><span class="line">scheduler            Unhealthy   Get &quot;https://127.0.0.1:10259/healthz&quot;: dial tcp 127.0.0.1:10259: connect: connection refused</span><br><span class="line">controller-manager   Healthy     ok</span><br><span class="line">etcd-0               Healthy     &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署-kube-scheduler">8. 部署 kube-scheduler</h2>
<h3 id="颁发证书-3">8.1 颁发证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-scheduler 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line">➜ cat &gt; kube-scheduler-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-scheduler 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-scheduler*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 13:19 kube-scheduler-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1489 Dec 30 13:19 kube-scheduler.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-scheduler 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-scheduler*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<h3 id="部署-kube-scheduler-1">8.2 部署 kube-scheduler</h3>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-scheduler.conf &lt;&lt; EOF</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>生成 kubeconfig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-scheduler --client-certificate=kube-scheduler.pem --client-key=kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-scheduler --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-scheduler.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-scheduler.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-scheduler $KUBE_SCHEDULER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 kube-scheduler 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-scheduler</span><br></pre></td></tr></table></figure>
<p>查看组件状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署-kubelet">9. 部署 kubelet</h2>
<p>master 节点上部署 kubelet 是可选的，一旦部署 kubelet，master 节点也可以运行 Pod，如果不希望 master 节点上运行 Pod，则可以给 master 节点打上污点。</p>
<p>master 节点部署 kubelet 是有好处的，一是可以通过诸如 <code>kubectl get node</code> 等命令查看节点信息，二是可以在上面部署监控系统，日志采集系统等。</p>
<h3 id="授权-kubelet-允许请求证书">9.1 授权 kubelet 允许请求证书</h3>
<p>授权 kubelet-bootstrap 用户允许请求证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br><span class="line"></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubelet-bootstrap created</span><br></pre></td></tr></table></figure>
<h3 id="部署-kubelet-1">9.2 部署 kubelet</h3>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kubelet.conf &lt;&lt; EOF</span><br><span class="line">KUBELET_OPTS=&quot;--bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \</span><br><span class="line">  --config=/etc/kubernetes/kubelet.yaml \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \</span><br><span class="line">  --cert-dir=/etc/kubernetes/pki \</span><br><span class="line">  --network-plugin=cni \</span><br><span class="line">  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6 \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --v=4 \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --fail-swap-on=false&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/kubelet.yaml &lt;&lt; EOF</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10250</span><br><span class="line">readOnlyPort: 0</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 2m0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /etc/kubernetes/pki/ca.pem</span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 5m0s</span><br><span class="line">    cacheUnauthorizedTTL: 30s</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.96.0.10</span><br><span class="line">clusterDomain: cluster.local</span><br><span class="line">healthzBindAddress: 127.0.0.1</span><br><span class="line">healthzPort: 10248</span><br><span class="line">rotateCertificates: true</span><br><span class="line">evictionHard:</span><br><span class="line">  imagefs.available: 15%</span><br><span class="line">  memory.available: 100Mi</span><br><span class="line">  nodefs.available: 10%</span><br><span class="line">  nodefs.inodesFree: 5%</span><br><span class="line">maxOpenFiles: 1000000</span><br><span class="line">maxPods: 110</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>生成 kubeconfig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kubelet-bootstrap --token=$(awk -F, &#x27;&#123;print $1&#125;&#x27; /etc/kubernetes/token.csv) --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kubelet-bootstrap.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes kubelet</span><br><span class="line">After=network.target network-online.targer docker.service</span><br><span class="line">Wants=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kubelet.conf</span><br><span class="line">ExecStart=/usr/local/bin/kubelet $KUBELET_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 kubelet 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kubelet</span><br></pre></td></tr></table></figure>
<p>批准节点加入集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-dtprn   11s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Pending</span><br><span class="line"></span><br><span class="line">➜ kubectl certificate approve csr-dtprn</span><br><span class="line"></span><br><span class="line">certificatesigningrequest.certificates.k8s.io/csr-dtprn approved</span><br><span class="line"></span><br><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE    SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-dtprn   113s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Approved,Issued</span><br></pre></td></tr></table></figure>
<p>查看节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS     ROLES    AGE   VERSION</span><br><span class="line">cnode0   NotReady   &lt;none&gt;   57s   v1.23.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时节点状态还是 NotReady，因为还没有安装网络插件，正确安装网络插件后，状态会变为 Ready.</span></span><br></pre></td></tr></table></figure>
<h2 id="部署-kube-proxy">10. 部署 kube-proxy</h2>
<h3 id="颁发证书-4">10.1 颁发证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-proxy 证书签署申请</span></span><br><span class="line">➜ cat &gt; kube-proxy-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-proxy 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-proxy*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 31 10:26 kube-proxy-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1407 Dec 31 10:26 kube-proxy.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-proxy 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-proxy*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure>
<h3 id="部署-kube-proxy-1">10.2 部署 kube-proxy</h3>
<p>编写服务配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-proxy.conf &lt;&lt; EOF</span><br><span class="line">KUBE_PROXY_OPTS=&quot;--config=/etc/kubernetes/kube-proxy.yaml \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --v=4 \</span><br><span class="line">  --log-dir=/var/log/kubernetes&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/kube-proxy.yaml &lt;&lt; EOF</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig</span><br><span class="line">bindAddress: 0.0.0.0</span><br><span class="line">clusterCIDR: 10.240.0.0/12</span><br><span class="line">healthzBindAddress: 0.0.0.0:10256</span><br><span class="line">metricsBindAddress: 0.0.0.0:10249</span><br><span class="line">mode: ipvs</span><br><span class="line">ipvs:</span><br><span class="line">  scheduler: &quot;rr&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>生成 kubeconfig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-proxy.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure>
<p>编写服务启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Proxy</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/kubernetes/kube-proxy.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-proxy $KUBE_PROXY_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>启动 kube-proxy 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-proxy</span><br></pre></td></tr></table></figure>
<h2 id="部署网络">11. 部署网络</h2>
<h3 id="部署-calico">11.1 部署 calico</h3>
<p>参考地址 <a href="https://projectcalico.docs.tigera.io/getting-started/kubernetes/self-managed-onprem/onpremises">calico</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ curl https://projectcalico.docs.tigera.io/v3.23/manifests/calico.yaml -O</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Pod IP 地址段，找到 CALICO_IPV4POOL_CIDR 变量，取消注释并修改如下</span></span><br><span class="line">            - name: CALICO_IPV4POOL_CIDR</span><br><span class="line">              value: &quot;10.240.0.0/12&quot;</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f calico.yaml</span><br><span class="line"></span><br><span class="line">configmap/calico-config created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/caliconodestatuses.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipreservations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/kubecontrollersconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">daemonset.apps/calico-node created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">deployment.apps/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br><span class="line">poddisruptionbudget.policy/calico-kube-controllers created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络 pod</span></span><br><span class="line">➜ kubectl get deploy,pod -n kube-system</span><br><span class="line"></span><br><span class="line">NAME                                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/calico-kube-controllers   1/1     1            1           24m</span><br><span class="line"></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/calico-kube-controllers-6b77fff45-mxxkg   1/1     Running   0          24m</span><br><span class="line">pod/calico-node-ld4sg                         1/1     Running   0          24m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 node 状态</span></span><br><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">cnode0   Ready    &lt;none&gt;   38m   v1.23.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 ipvs 模式</span></span><br><span class="line">➜ ipvsadm -Ln</span><br><span class="line"></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  10.96.0.1:443 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.128.170.20:6443           Masq    1      5          0</span></span><br></pre></td></tr></table></figure>
<p><strong>如果 node 状态仍然是 NotReady，基本上是镜像未拉取完成或拉取失败导致的，如果一段时间后仍拉取失败，则尝试手动拉取镜像。</strong></p>
<h3 id="授权-kube-apiserver-访问-kubelet">11.2 授权 kube-apiserver 访问 kubelet</h3>
<p><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization</a></p>
<p>应用场景：例如 kubectl exec/run/logs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; apiserver-to-kubelet-rbac.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - nodes/proxy</span><br><span class="line">      - nodes/stats</span><br><span class="line">      - nodes/log</span><br><span class="line">      - nodes/spec</span><br><span class="line">      - nodes/metrics</span><br><span class="line">      - pods/log</span><br><span class="line">    verbs:</span><br><span class="line">      - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-apiserver</span><br><span class="line">  namespace: &quot;&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">subjects:</span><br><span class="line">  - apiGroup: rbac.authorization.k8s.io</span><br><span class="line">    kind: User</span><br><span class="line">    name: kubernetes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f apiserver-to-kubelet-rbac.yaml</span><br><span class="line"></span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:kube-apiserver-to-kubelet created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/system:kube-apiserver created</span><br><span class="line"></span><br><span class="line">➜ kubectl logs calico-kube-controllers-6b77fff45-mxxkg -n kube-system</span><br></pre></td></tr></table></figure>
<h3 id="部署-coredns">11.3 部署 coredns</h3>
<p>参考地址 <a href="https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed">coredns</a></p>
<p><strong>coredns.yaml.sed 原始文件见附录章节 "16.1 coredns.yaml.sed"，该 yaml 指定使用的 coredns 的版本是 1.9.2。</strong></p>
<p>下载 yaml 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ curl https://raw.githubusercontent.com/coredns/deployment/master/kubernetes/coredns.yaml.sed -o coredns.yaml</span><br></pre></td></tr></table></figure>
<p>对 yaml 文件做如下修改：</p>
<ul>
<li>CLUSTER_DOMAIN 改为 cluster.local</li>
<li>REVERSE_CIDRS 改为 in-addr.arpa ip6.arpa</li>
<li>UPSTREAMNAMESERVER 改为 /etc/resolv.conf，如果报错，则改成当前网络所使用的 DNS 地址</li>
<li>删除 STUBDOMAINS</li>
<li>CLUSTER_DNS_IP 改为 10.96.0.10（应与 /etc/kubernetes/kubelet.yaml 中配置的 clusterDNS 保持一致）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl apply -f coredns.yaml</span><br></pre></td></tr></table></figure>
<p>验证<strong>（如果 calico 的 pod 未就绪，请检查是否是镜像拉取未完成或镜像拉取失败）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get deploy,pod,svc -n kube-system</span><br><span class="line">NAME                                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/calico-kube-controllers   1/1     1            1           43m</span><br><span class="line">deployment.apps/coredns                   1/1     1            1           3m8s</span><br><span class="line"></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/calico-kube-controllers-6b77fff45-mxxkg   1/1     Running   0          43m</span><br><span class="line">pod/calico-node-ld4sg                         1/1     Running   0          43m</span><br><span class="line">pod/coredns-799bc9dbc6-qqh7h                  1/1     Running   0          3m8s</span><br><span class="line"></span><br><span class="line">NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">service/kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   3m8s</span><br></pre></td></tr></table></figure>
<p>dig 测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ yum install bind-utils -y</span><br><span class="line"></span><br><span class="line">➜ dig -t A www.baidu.com @10.96.0.10 +short</span><br><span class="line"></span><br><span class="line">www.a.shifen.com.</span><br><span class="line">182.61.200.6</span><br><span class="line">182.61.200.7</span><br></pre></td></tr></table></figure>
<p>pod 测试</p>
<p><a href="https://www.cnblogs.com/vincenshen/p/9751193.html">Kubernetes busybox nslookup问题</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl run -it --rm --image=busybox:1.28.3 -- sh</span><br><span class="line"></span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # cat /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br><span class="line">/ # nslookup kubernetes.default</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br><span class="line">/ # ping -c 4 www.baidu.com</span><br><span class="line">PING www.baidu.com (182.61.200.6): 56 data bytes</span><br><span class="line">64 bytes from 182.61.200.6: seq=0 ttl=52 time=6.860 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=1 ttl=52 time=6.592 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=2 ttl=52 time=6.488 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=3 ttl=52 time=7.288 ms</span><br><span class="line"></span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 6.488/6.807/7.288 ms</span><br></pre></td></tr></table></figure>
<h2 id="添加-worker-节点">12. 添加 worker 节点</h2>
<p>worker 节点需要部署两个组件 <code>kubelet</code>, <code>kube-proxy</code>.</p>
<p>（master 节点执行）从 master 节点上复制以下文件到 worker 节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ scp /etc/kubernetes/pki/ca.pem \</span><br><span class="line">       /etc/kubernetes/pki/kube-proxy.pem \</span><br><span class="line">       /etc/kubernetes/pki/kube-proxy-key.pem \</span><br><span class="line">       root@cnode1:/etc/kubernetes/pki/</span><br><span class="line"></span><br><span class="line">➜ scp /etc/kubernetes/kubelet.conf \</span><br><span class="line">       /etc/kubernetes/kubelet.yaml \</span><br><span class="line">       /etc/kubernetes/kubelet-bootstrap.kubeconfig \</span><br><span class="line">       /etc/kubernetes/kube-proxy.conf \</span><br><span class="line">       /etc/kubernetes/kube-proxy.yaml \</span><br><span class="line">       /etc/kubernetes/kube-proxy.kubeconfig \</span><br><span class="line">       root@cnode1:/etc/kubernetes/</span><br><span class="line"></span><br><span class="line">➜ scp /usr/lib/systemd/system/kubelet.service \</span><br><span class="line">       /usr/lib/systemd/system/kube-proxy.service \</span><br><span class="line">       root@cnode1:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure>
<p>（master 节点执行）复制 <code>kubelet</code>, <code>kube-proxy</code> 二进制程序到 /usr/local/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ scp /usr/local/bin/kubelet \</span><br><span class="line">       /usr/local/bin/kube-proxy \</span><br><span class="line">       root@cnode1:/usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>（worker 节点执行）worker 节点启动 kube-proxy 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-proxy</span><br></pre></td></tr></table></figure>
<p>（worker 节点执行）worker 节点启动 kubelet 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kubelet</span><br></pre></td></tr></table></figure>
<p>（master 节点执行）批准 worker 节点加入集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-9mvtn   23s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Pending</span><br><span class="line"></span><br><span class="line">➜ kubectl certificate approve csr-9mvtn</span><br><span class="line"></span><br><span class="line">certificatesigningrequest.certificates.k8s.io/csr-9mvtn approved</span><br><span class="line"></span><br><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE     SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-9mvtn   3m16s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Approved,Issued</span><br></pre></td></tr></table></figure>
<p>（master 节点执行）查看节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION</span><br><span class="line">cnode0   Ready    &lt;none&gt;   4h31m   v1.23.6</span><br><span class="line">cnode1   Ready    &lt;none&gt;   105m    v1.23.6</span><br></pre></td></tr></table></figure>
<p><strong>如果 cnode1 的状态仍是 NotReady，请检查是否是镜像拉取未完成或镜像拉取失败。</strong></p>
<h2 id="禁止-master-节点运行-pod">13. 禁止 master 节点运行 pod</h2>
<p>至此 1 master 1 worker 的 k8s 二进制集群已搭建完毕。</p>
<p>此外，还可以给节点打上角色标签，使得查看节点信息更加直观</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给 master 节点打上 controlplane,etcd 角色标签</span></span><br><span class="line">➜ kubectl label node cnode0 node-role.kubernetes.io/controlplane=true node-role.kubernetes.io/etcd=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给 worker 节点打上 worker 角色标签</span></span><br><span class="line">➜ kubectl label node cnode1 node-role.kubernetes.io/worker=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看节点标签</span></span><br><span class="line">➜ kubectl get node --show-labels</span><br></pre></td></tr></table></figure>
<p>如果不希望 master 节点运行 Pod，则给 master 打上污点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl taint node cnode0 node-role.kubernetes.io/controlplane=true:NoSchedule</span><br></pre></td></tr></table></figure>
<p>后续可以新增 2 个 etcd 节点组成 etcd 集群，新增 2 个控制平面，避免单点故障。</p>
<h2 id="测试应用服务部署">14. 测试应用服务部署</h2>
<p>创建 namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl create namespace dev</span><br><span class="line"></span><br><span class="line">namespace/dev created</span><br><span class="line"></span><br><span class="line">➜ kubectl get namespace</span><br><span class="line"></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   15h</span><br><span class="line">dev               Active   15s</span><br><span class="line">kube-node-lease   Active   15h</span><br><span class="line">kube-public       Active   15h</span><br><span class="line">kube-system       Active   15h</span><br></pre></td></tr></table></figure>
<p>创建 deployment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ mkdir -p /etc/kubernetes/resources</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/resources/nginx-deployment.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f /etc/kubernetes/resources/nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line">deployment.apps/nginx-deployment created</span><br><span class="line"></span><br><span class="line">➜ kubectl get pod -n dev</span><br><span class="line"></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-7d4578b56c-cndrb   1/1     Running   0          48s</span><br></pre></td></tr></table></figure>
<p>创建 service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/resources/nginx-service.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 30001</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f /etc/kubernetes/resources/nginx-service.yaml</span><br><span class="line"></span><br><span class="line">service/nginx-service created</span><br><span class="line"></span><br><span class="line">➜ kubectl get svc -n dev</span><br><span class="line"></span><br><span class="line">NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-service   NodePort   10.96.221.226   &lt;none&gt;        80:30001/TCP   17s</span><br></pre></td></tr></table></figure>
<p>测试服务访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ curl 10.128.170.20:30001 -I</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.21.5</span><br><span class="line">Date: Sat, 21 May 2022 08:06:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 615</span><br><span class="line">Last-Modified: Tue, 28 Dec 2021 15:28:38 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;61cb2d26-267&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="部署-dashboard">15. 部署 Dashboard</h2>
<p>在 Kubernetes 社区中，有一个很受欢迎的 Dashboard 项目，它可以给用户提供一个可视化的 Web 界面来查看当前集群的各种信息。用户可以用 Kubernetes Dashboard 部署容器化的应用、监控应用的状态、执行故障排查任务以及管理 Kubernetes 各种资源。</p>
<p>官方参考文档：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p>
<p>使用 nodeport 方式将 dashboard 服务暴露在集群外，指定使用 30443 端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载相关 yaml 文件</span></span><br><span class="line">➜ curl https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.0/aio/deploy/recommended.yaml -O</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Service 部分</span></span><br><span class="line">➜ vim recommended.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 新增</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30443  # 新增</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署</span></span><br><span class="line">➜ kubectl apply -f recommended.yaml</span><br><span class="line"></span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 kubernetes-dashboard 下的资源</span></span><br><span class="line">➜ kubectl get deploy -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">dashboard-metrics-scraper   1/1     1            1           12m</span><br><span class="line">kubernetes-dashboard        1/1     1            1           12m</span><br><span class="line"></span><br><span class="line">➜ kubectl get pod -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-799d786dbf-xpvcc   1/1     Running   0          13m</span><br><span class="line">kubernetes-dashboard-546cbc58cd-hzvhr        1/1     Running   0          13m</span><br><span class="line"></span><br><span class="line">➜ kubectl get svc -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.96.73.62     &lt;none&gt;        8000/TCP        13m</span><br><span class="line">kubernetes-dashboard        NodePort    10.96.148.106   &lt;none&gt;        443:30443/TCP   13m</span><br></pre></td></tr></table></figure>
<p><strong>如果 kubernetes-dashboard 下的资源一直未就绪，请检查是否是正在拉取镜像或者镜像一直拉取失败。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl describe pod kubernetes-dashboard-546cbc58cd-hzvhr -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  6m20s  default-scheduler  Successfully assigned kubernetes-dashboard/kubernetes-dashboard-546cbc58cd-hzvhr to cnode1</span><br><span class="line">  Normal  Pulling    6m20s  kubelet            Pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line"></span><br><span class="line">➜ kubectl describe pod kubernetes-dashboard-546cbc58cd-hzvhr -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason          Age                 From               Message</span><br><span class="line">  ----     ------          ----                ----               -------</span><br><span class="line">  Normal   Scheduled       10m                 default-scheduler  Successfully assigned kubernetes-dashboard/kubernetes-dashboard-546cbc58cd-hzvhr to cnode1</span><br><span class="line">  Warning  Failed          2m1s                kubelet            Failed to pull image &quot;kubernetesui/dashboard:v2.5.0&quot;: rpc error: code = Unknown desc = dial tcp 104.18.124.25:443: i/o timeout</span><br><span class="line">  Warning  Failed          2m1s                kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   SandboxChanged  2m                  kubelet            Pod sandbox changed, it will be killed and re-created.</span><br><span class="line">  Normal   BackOff         118s (x3 over 2m)   kubelet            Back-off pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line">  Warning  Failed          118s (x3 over 2m)   kubelet            Error: ImagePullBackOff</span><br><span class="line">  Normal   Pulling         106s (x2 over 10m)  kubelet            Pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line">  Normal   Pulled          25s                 kubelet            Successfully pulled image &quot;kubernetesui/dashboard:v2.5.0&quot; in 1m21.608630166s</span><br><span class="line">  Normal   Created         22s                 kubelet            Created container kubernetes-dashboard</span><br><span class="line">  Normal   Started         21s                 kubelet            Started container kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p>创建 service account 并绑定默认 cluster-admin 管理员集群角色</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面创建了一个叫 admin-user 的服务账号，放在 kubernetes-dashboard 命名空间下，并将 cluster-admin 角色绑定到 admin-user 账户，这样 admin-user 账户就有了管理员的权限。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，kubeadm 创建集群时已经创建了 cluster-admin 角色，我们直接绑定即可。</span></span><br><span class="line">➜ cat &gt; dashboard-admin-user.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用资源配置清单</span></span><br><span class="line">➜ kubectl apply -f dashboard-admin-user.yaml</span><br><span class="line"></span><br><span class="line">serviceaccount/admin-user created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/admin-user created</span><br></pre></td></tr></table></figure>
<p>查看 admin-user 账户的 token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">Name:         admin-user-token-vmbfm</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: admin-user</span><br><span class="line">              kubernetes.io/service-account.uid: bc3c111d-947e-4444-8fc0-2ff69abada00</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1367 bytes</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6Ikd6alY4Rm1QWFRiRk9VUDlta1U1QnFVM2VyUXpXSkUwRzRKek9QX2pxbUkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXZtYmZtIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiYzNjMTExZC05NDdlLTQ0NDQtOGZjMC0yZmY2OWFiYWRhMDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.e-fkl4gBppWnwMy5b1PvHNf5RiBL_uAT0o_QFTy4YWwkcBSnn9JqlCBJzy6Vblw2mIekkMwuOGux-vU8V9nPuAHczsKr1Kq2leZKR0rnNrFwqge-IO-U4pkY8sfWYWPo7j5Oop1dNAKt9q33WyenjpA6T_IF-TmdtsX4AhLeZp67RrDotq80dpSjmSBzDU2rZ6gwknCfCwum_Crn1uruNiGGP4dkFifIK78RfDyCIMdMvYuwoa9hYPTFVNPZQcTRecmdtOmfXyVHpS7FfKf3YTCm9vbyqrBLyzHinYf-dBBr5ivktJKOepuqbKSoQ68Q1KnxjeG9ouWaYa3jiukArw</span><br></pre></td></tr></table></figure>
<p>使用输出的 token 登录 Dashboard</p>
<h2 id="附录">16. 附录</h2>
<h3 id="coredns.yaml.sed">16.1 coredns.yaml.sed</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/bootstrapping:</span> <span class="string">rbac-defaults</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">discovery.k8s.io</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">endpointslices</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/bootstrapping:</span> <span class="string">rbac-defaults</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    .:53 &#123;</span></span><br><span class="line"><span class="string">        errors</span></span><br><span class="line"><span class="string">        health &#123;</span></span><br><span class="line"><span class="string">          lameduck 5s</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        ready</span></span><br><span class="line"><span class="string">        kubernetes CLUSTER_DOMAIN REVERSE_CIDRS &#123;</span></span><br><span class="line"><span class="string">          fallthrough in-addr.arpa ip6.arpa</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        prometheus :9153</span></span><br><span class="line"><span class="string">        forward . UPSTREAMNAMESERVER &#123;</span></span><br><span class="line"><span class="string">          max_concurrent 1000</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        cache 30</span></span><br><span class="line"><span class="string">        loop</span></span><br><span class="line"><span class="string">        reload</span></span><br><span class="line"><span class="string">        loadbalance</span></span><br><span class="line"><span class="string">    &#125;STUBDOMAINS</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">&quot;CoreDNS&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># replicas: not specified here:</span></span><br><span class="line">  <span class="comment"># 1. Default is 1.</span></span><br><span class="line">  <span class="comment"># 2. Will be tuned in real time if DNS horizontal auto-scaling is turned on.</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">coredns</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;CriticalAddonsOnly&quot;</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">         <span class="attr">podAntiAffinity:</span></span><br><span class="line">           <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">               <span class="attr">matchExpressions:</span></span><br><span class="line">               <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">k8s-app</span></span><br><span class="line">                 <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                 <span class="attr">values:</span> [<span class="string">&quot;kube-dns&quot;</span>]</span><br><span class="line">             <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">coredns/coredns:1.9.2</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">170Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">70Mi</span></span><br><span class="line">        <span class="attr">args:</span> [ <span class="string">&quot;-conf&quot;</span>, <span class="string">&quot;/etc/coredns/Corefile&quot;</span> ]</span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/coredns</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9153</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="attr">drop:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">all</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">Corefile</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">Corefile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;9153&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">&quot;CoreDNS&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">CLUSTER_DNS_IP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9153</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p><a href="https://www.haxi.cc/archives/setup-k8s-1-23-1-cluster-using-binary.html">二进制部署 K8s 集群 1.23.1 版本</a></p>
<p><a href="https://hebye.com/docs/k8s/k8s-1ct8ioki6h2qk#2nop09">部署一套完整的企业级K8s集群</a></p>
]]></content>
      <categories>
        <category>cloud</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GNU-make管理项目</title>
    <url>/posts/cec71891/</url>
    <content><![CDATA[<p>在本文中读者会看到有关 make 的介绍，make 是一种控制编译或者重复编译软件的工具。make 可以自动管理软件编译的内容、方式和时机，从而使程序员能够把精力集中在编写代码上。</p>
<span id="more"></span>
<h1 id="使用-gnu-make-管理项目">使用 GNU make 管理项目</h1>
<div class="note info"><p><strong>第 4 章 使用 GNU make 管理项目</strong> 原文出处：《GNU/Linux编程指南》第二版 原文作者： Kurt Wall 等著</p>
</div>
<h2 id="为何使用-make">1 为何使用 make</h2>
<p>除了最简单的软件项目，make 对于其他所有项目而言都很必要。首先，包含多个源代码文件的项月在编译时都有长而且复杂的命令行。而且，编程项目经常需要使用那些很少用到且难以记忆的特殊编译选项。make 可以通过把这些复杂而难记的命令行保存在 makefle 文件中来解决上述两个问题，makefile 将在下一小节讨论。</p>
<p>make 还能减少重复编译所需要的时间，因为它很聪明，能够判断哪些文件被修改过。进而只重新编译程序被修改过的部分。makefile 为项目构建了一个依赖信息数据库，因而可以让 make 在每次编译前检查是否可以找到所有需要的文件。make 还可以让你建立一个稳定的编译环境。最后，make 可以让编译过程自动执行，因为从 shell 脚本或者 cron (定时)作业调用 make 非常容易。</p>
<h2 id="编写-makefile">2 编写 makefile</h2>
<p>make 是怎样完成这些神奇工作的呢？是通过使用 makefile 文件做到的。</p>
<p>makefile 是一个文本形式的数据库文件，其中包含一些规则告诉 make 编译哪些文件、怎样编译以及在什么条件下去编译。每条规则包含以下内容：</p>
<ul>
<li>一个 "目标体" (target)，即 make 最终需要创建的东西。</li>
<li>包含一个或多个 "依赖体" (dependency)的列表，依赖体通常是编泽目标体需要 的其他文件。</li>
<li>为了从指定的依赖体创建出目标体所需执行的 "命令" (command) 的列表。</li>
</ul>
<p>虽然目标体通常都是程序，但它们可以是诸如文本文件、手册页面等任何东西。目标体甚至能测试和设置环境变量。类似地，也可以定义依赖体以确保编译开始前存在某个特殊的环境变量。最后，makefile 中的命令可以是编译器的命令或 shell 命令，它们能设置环境变量、删除文件,或者任何俞令行所能完成的功能,如从 FTP 站点下载文件等。GNU make 被调用后会顺序查找名为 GNUmakefile、makefile 或 Makefile 的文件。出于某种原因，可能只是习惯和长期形成的约定吧，大多数 Linux 程序员使用最后一种形式 Makefile。</p>
<p>Makefile 规则有下列通用形式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: dependency [dependency [...]</span></span><br><span class="line">	command</span><br><span class="line">	command</span><br><span class="line">	[...]</span><br></pre></td></tr></table></figure>
<p><strong>警告:</strong></p>
<p><strong>每一个命令的第一个字符必须是制表符</strong>，仗使用 8 个空格是不够的。这一点经常不被人们注意， 并且当所使用的编辑器友好的将制表符转换成 8 个空格时，会产生问题；因为如果用空格代替制表符，make 会在执行过程中显示 Missing Separator (缺少分隔符)并停止。</p>
<p>target 是需要创建的二进制文件或目标文件。dependency 是在创建 target 时需要输入的一个或多个文件的列表。命令序列是创建 target 文件所需要的步骤，如编译命令。此外，除非特别指定，否则 make 的工作目录就是当前目录。</p>
<h2 id="编写-makefile-的规则">3 编写 makefile 的规则</h2>
<p>如果上一节的内容对你来说太抽象， 那么本节使用程序清单 4.1 再具体讨论。这是用于编译第 3 章中出现的程序 howdy 和 hello 的 makefile 文件。</p>
<p>程序清单 4.1 演示目标体、依赖体和命令的简单 makefile 文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">howdy: howdy.o helper.o helper.h</span></span><br><span class="line">	gcc howdy.o helper.o -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c helper.h</span></span><br><span class="line">	gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">	gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">	gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm howdy hello *.o</span><br></pre></td></tr></table></figure>
<p>要编译 howdy，只需在 makefile 所在目录下输入 make 即可。就这么简单。</p>
<p>这个 makefile 文件包含 6 条规则。第一个目标体 howdy 称为默认(default) 目标体，这是 make 要创建的文件。howdy 有 3 个依赖体，分别为 howdy.o、helper.o 和 helper.h，要编译生成 howdy，必须要有这 3 个文件。第二行调用编译器的命令供 make 执行来创建 howdy。由对第 3 章内容的回忆可知，这条命令从两个目标文件创建名为 howdy 的可执行文件。把头文件 helper.h 作为一个依赖体列入是为了避免编译器调用未声明的函数产生出错信息。接下来的两条规则告诉 make 怎样生成单个目标文件，helper.o 和 howdy.o。这些规则使用了 gcc 的 <code>-c</code> 选项，只创建目标文件但跳过链接。如果只想生成两个目标文件而不生成 howdy 本身，可以使用下面两条命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make helper.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make howdy.o</span></span><br></pre></td></tr></table></figure>
<p>更简洁一点，只需使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make helper.o howdy.o</span></span><br></pre></td></tr></table></figure>
<p>正如你所看到的那样，make 允许把多个目标作为参数。这两种方法都能使用相应的规则和命令生成目标文件。图 4.1 给出了这个过程的图示。</p>
<p>图4.1 把生成 howdy 的步骤归结到第 3 章讨论的一般性的 预处理/编译/链接 过程上。howdy.c 和 helper.c 这两个源代码文件经预处理后编译成目标文件。然后链接器把来自文件 howdy.o 和 helper.o 的目标代码和标准库以及 C 启动代码链接到一起生成二进制文件 hello。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9fdf0734b6ed1ac256008456d12d2187.png" alt="compile" /></p>
<p>现在，make 的价值就体现出来了：通常情况下，如果试图在依赖体 helper.o 和 howdy.o 不存在的情况下使用所示的命令编译 howdy，则 gcc 会报错井退出。另一方面，在看到 howdy 需要这两个文件（和 helper.c）后，make 先确认它们是否存在，如果不存在则首先执行命令生成它们，然后再返回到第一条规则创建可执行文件 howdy。当然，如果 helper.h 不存在，make 也会放弃执行，因为它没有创建 helper.h 的规则。</p>
<p>"一切都很好"，也许你会这么想，"但是 make 怎样知道什么时候需要重新编译一个文件呢？" 答案极其简单：如果指定的目标文件 make 找不到，make 就会生成它。如果目标体存在，make 会对目标体文件和依赖体文件的时间戳进行比较。如果有一个或多个依赖体比目标体新，make 就重新编译生成目标体，因为 make 认为新的依赖体意味着对代码做过修改，必须把改动融入到目标体中去。</p>
<p>第四条规则相当简单。它定义了如何编译生成第 3 章介绍的简单程序 hello。第五条是创建 hello 和 howdy 的笼统规则，它还表明甚至二进制文件都能作依赖体。下一小节将讨论第六条规则，即伪目标。</p>
<h3 id="伪目标">3.1 伪目标</h3>
<p>除了一般的文件目标体， 比如 howdy 和 hello 之外，make 也允许指定伪目标。称其为伪目标是因为它们并不对应于实际的文件。程序清单 4.1 中最后一个目标体 clean 就是伪目标。伪目标体规定了 make 应该执行的命令。但是，因为 clean 没有依赖体，所以它的命令不会被自动执行。下面解释 make 是如何工作的：当遇到目标体 clean 时，make 先查看其是否有依赖体，因为 clean 没有依赖体，所以 make 认为目标体是最新的而不执行任何操作。为了编译这个目标体，必须输入make clean。在本例中，clean 删除了可执行文件 hello 和 howdy 以及构成 howdy 的目标文件。在创建和发行仅包含源代码的压缩包或者需要彻底重新编译时可能会用到这样一个目标体。</p>
<p>然而，如果恰巧有一个名为 clean 的文件存在，make 就会发现它。然后和前面一样，因为 clean 没有依赖体文件，make 就认为这个文件是最新的而不会执行相关命令。为了处理这类情况，需要使用特殊的 make 目标体 <code>.PH0NY</code>。 <code>.PHONY</code> 的依赖体文件的含义和通常一样， 但是 make 不检查是否存在有文件名和依赖体中的一个名字相匹配的文件，而是直接执行与之相关的命令。在使用了 <code>.PHONY</code> 之后，前面的例子如下：</p>
<p>程序清单 4.2 带有 PHONY 目标的 Makefile 文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">howdy: howdy.o helper.o helper.h</span></span><br><span class="line">	gcc howdy.o helper.o -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c helper.h</span></span><br><span class="line">	gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">	gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">	gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm howdy hello *.o</span><br></pre></td></tr></table></figure>
<h3 id="变量">3.2 变量</h3>
<p>为了简化编辑和维护 makefile，make 允许在 makefile 中创建和使用变量。所谓的变量其实是用指定文本串在 makefile 中定义的一个名字，这个文本串就是变量的值。下面是定义变量的一般方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VARNAME=some_text [...]</span><br></pre></td></tr></table></figure>
<p>把变量用括号括起来，井在前面加上 "$" 符号，就可以引用变量的值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(VARNAME)</span></span><br></pre></td></tr></table></figure>
<p>此时，VARNAME 在等式右端展开为它所代表的文本。变量一般都在 makefle 的头部定义，并且，按照惯例，所有的 makefle 变量都应该是大写( 虽然这不是必须的)。这样，如果变量的值发生变化，就只需要在一个地方修改，从而简化了 makefile 的维护。现在，继续现在修改程序清单 4.1，加入两个变量，结果如程序清单 4.3 所示。</p>
<p>程序清单 4.3 在 makefle 中使用变量</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = howdy.o helper.o</span><br><span class="line">HDRS = helper.h</span><br><span class="line"></span><br><span class="line"><span class="section">howdy: <span class="variable">$(OBJS)</span> <span class="variable">$(HDRS)</span></span></span><br><span class="line">	gcc <span class="variable">$(OBJS)</span> -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c <span class="variable">$(HDRS)</span></span></span><br><span class="line">	gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">	gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">	gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm howdy hello *.o</span><br></pre></td></tr></table></figure>
<p>OBJS 和 HDRS 在被引用的每个地方都展开成它的取值。编译时也是如此。</p>
<p>实际上，make 使用两种变量：<strong>递归展开变量和简单展开变量</strong>。递归展开变量在引用时逐层展开，即如果在展开式中包含了对其他变量的引用，则这些变量也将被展开，直到没有需要展开的变量为止，这就是所谓的递归展开。下面的例子有助于弄清这个概念。</p>
<p>假设变量 TOPDIR 和 SRCDIR 如下定义:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOPDIR = /home/kwall/myproject</span><br><span class="line">SRCDIR = <span class="variable">$(TOPDIR)</span>/src</span><br></pre></td></tr></table></figure>
<p>这样，SRCDIR 的值是 /home/kwall/myproject/src，则工作正常。但是，考虑下面的变量定义:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CC = <span class="variable">$(CC)</span> -o</span><br></pre></td></tr></table></figure>
<p>很清楚，定义者想要得到的结果是 "CC=gcc -o"。但是实际并非如此；CC 在被引用时递归展开，从而陷入一个无限循环中；CC 将扩展为 <code>$(CC)</code> 的值，从而永远也读不到 <code>-o</code> 选项。幸运的是，make 能够检测到这个问题并报告错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** Recursive variable &#x27;CC&#x27; references itself (eventually). Stop</span><br></pre></td></tr></table></figure>
<p>为了避免这个问题，可以使用<strong>简单展开变量</strong>。与<strong>递归展开变量</strong>在引用时展开不同，简单展开变量在定义处展开，并且只展开一次，从而消除了变量的嵌套引用。在定义时,其语法与递归展开变量有细微的不同：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC := gcc -o</span><br><span class="line">CC += -O2</span><br></pre></td></tr></table></figure>
<p>第一个定义使用 <code>:=</code> 设置 CC 的值为 <code>gcc -o</code>，第二个定义使用 "+=" 在前面定义的 CC 后附加了 <code>-O2</code>，从而 CC 最终的值是 <code>gcc -o -O2</code>。如果在使用 make 变量时遇到 "VARNAME references itself" 这类错误信息，就可以使用简单展开变量来解决。一些程序员仅使用简单展开变量，以避免出现意想不到的问题；但既然现在是在 Linux 上，你可以自由选择使用的方式。</p>
<p>除用户定义变量外, make 也允许使用环境变量、自动变量和预定义变量。使用环境变量非常简单。在启动时，make 读取己定义的环境变量，并且创建与之同名同值的变量。但是，如果 makefile 中有同名的变量，则这个变量将取代与之相应的环境变量，所以应当注意这一点。</p>
<p>此外，make 也提供一长串预定义变量和自动变量，但是它们看起来有些神秘。之所以称为自动变量是因为 make 自动用特定的、熟知的值替换它们。表 4.1 给出了部分自动变量。</p>
<h4 id="表-4.1-自动变量">表 4.1 自动变量</h4>
<table>
<thead>
<tr class="header">
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$@</td>
<td>规则的目标所对应的文件名</td>
</tr>
<tr class="even">
<td>$&lt;</td>
<td>规则中的第一个相关文件名</td>
</tr>
<tr class="odd">
<td>$^</td>
<td>规则中所有相关文件的列表，以空格为分隔符</td>
</tr>
<tr class="even">
<td>$?</td>
<td>规则中日期新于目标的所有相关文件的列表，以空格为分隔符</td>
</tr>
<tr class="odd">
<td>$(<span class="citation" data-cites="D">@D</span>)</td>
<td>目标文件的目录部分(如果目标在子目录中)</td>
</tr>
<tr class="even">
<td>$(<span class="citation" data-cites="F">@F</span>)</td>
<td>目标文件的文件名部分(如果目标在子目录中)</td>
</tr>
</tbody>
</table>
<p>除了表 4.1 列出的自动变量外，make 还预定义了许多其他变量，用于定义程序名或给这些程序传递标志和参数。这些预定义的变量看上去更像常规的 make 变量而不是像字符名称的自动变量。表 4.2 给出了一些有用的预定义变量。</p>
<h4 id="表4.2-用于程序名和标志的预定义变量">表4.2 用于程序名和标志的预定义变量</h4>
<table>
<thead>
<tr class="header">
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AR</td>
<td>归档维护程序，默认值=ar</td>
</tr>
<tr class="even">
<td>AS</td>
<td>汇编程序，默认值=as</td>
</tr>
<tr class="odd">
<td>CC</td>
<td>C 编译程序，默认值=cc</td>
</tr>
<tr class="even">
<td>CPP</td>
<td>C 预处理程序，默认值=cpp</td>
</tr>
<tr class="odd">
<td>RM</td>
<td>文件删除程序，默认值="rm -f"</td>
</tr>
<tr class="even">
<td>ARFLAGS</td>
<td>传给归档维护程序的标志，默认值=rv</td>
</tr>
<tr class="odd">
<td>ASFLAGS</td>
<td>传给汇编程序的标志，没有默认值</td>
</tr>
<tr class="even">
<td>CFLAGS</td>
<td>传给 C 编译器的标志，没有默认值</td>
</tr>
<tr class="odd">
<td>CPPFLAGS</td>
<td>传给 C 预处理程序的标志，没有默认值</td>
</tr>
<tr class="even">
<td>LDFLAGS</td>
<td>传给链接程序（Id）的标志，没有默认值</td>
</tr>
</tbody>
</table>
<p>如果需要，可以在 makefile 中重新定义这些变量，但是在大多数情况下，这些默认值都是合理的。</p>
<h3 id="隐式规则">3.3 隐式规则</h3>
<p>除了在 makefile 文件中显式指定的规则（称为显式规则）外，make 还有一整套隐式规则，或称为预定义规则。这些规则多数有特殊目的而且用途有限，所以在这里只介绍几种最常用的隐式规则。隐式规则简化了 makefile 的编写和维护。</p>
<p>假设有下面这样的一个 makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = editor.o screen.o keyboard.o</span><br><span class="line"></span><br><span class="line"><span class="section">editor: <span class="variable">$(OBJS)</span></span></span><br><span class="line">	cc -o editor <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm editor <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>默认目标 editor 所对应的命令提及了 editor.o，screen.o 和 keyboard.o，但是 makefile 中没有怎样编译生成这些目标的规则。此时，make 就使用所谓的隐式规则，实际上，对每一个名为 somefile.o 的目标（object）文件，make 首先找到与之相应的源代码 somefile.c，并且用 <code>gcc -c somefile.c -o somefile.o</code> 编译生成这个目标文件。所以，在本例中 make 先查找名 为 editor.c，screen.c 和 keyboard.c 的文件并将它们编译为目标文件（editor.o，screen.o 和 keyboard.o），然后，编译生成默认目标 editor。</p>
<p>实际的机制比这里所描述的要全面。目标文件（.o） 可以从 C、Pascal 和 Fortran 等源代码中生成，所以 make 也应去查找符合实际情况的相关文件。所以，如果在工作目录下有 editor.p，screen.p 和 keyboard.p 三个 Pascal 文件（p 通常被认为是 Pascal 源代码的扩展名），make 就会激活 Pascal 编译器来编译它们，而不用 C 编译器。因此，如果出于某种原因而在项目中需要使用多种语言时，就不能依靠隐式规则，因为此时使用该规则所得到的结果可能会与期望的有所不同。</p>
<h3 id="模式规则">3.4 模式规则</h3>
<p>通过定义用户自己的隐式规则，模式规则提供了扩展 make 的隐式规则的一种方法。模式规则类似于普通规则，但是它的目标必定含有符号 "%"，这个符号可以与任何非空字符串匹配；为与目标中的 "%" 匹配，这个规则的相关文件部分也必须使用 "%"。例如，下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br></pre></td></tr></table></figure>
<p>告诉 make 所有形为 somename.o 的目标（object）文件都应从源文件 somename.c 编译而来。</p>
<p>与隐式规则一样， make 预定义了一些模式规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>与前面的例子相同，make 定义了一条规则，即任何 x.o 的文件都从 x.c 编译而来。每次使用该规则时，该规则用自动变量 <code>$&lt;</code> 和 <code>$@</code> 来代替第一个依赖体和目标体。此外，变量 <code>$(CC)</code>，<code>$(CFLAGS)</code> 和 <code>$(CPPFLAGS)</code> 的默认值如表 4.2 所示。</p>
<h3 id="注释">3.5 注释</h3>
<p>在 makefile 中插入注释时，必须在注释前加上符号 "#"。make 读到 "#" 后，它忽略该符号以及这一行余下的字母。注释可以出现在 makefile 的所有地方。但是，因为多数 shell 把 "#" 看作是元符号（通常也是注释符），所以在命令中加入注释时要特别小心。此外，实际上就 make 本身而言，一个只含注释的行就是一个空行。</p>
<h2 id="命令行选项和参数">4 命令行选项和参数</h2>
<p>同多数 GNU 程序一样，make 也有丰富的命令行选项。表 4.3 列出了最常用的部分。</p>
<p>表 4.3 常用的 make 俞令行选项</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-f file</code></td>
<td>指定 makefile 的文件名</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>打印将需要执行的命令，但实际上并不执行这些命令</td>
</tr>
<tr class="odd">
<td><code>-Idirname</code></td>
<td>指定被包含的 makefile 所在的目录</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>在执行时不打印命令名</td>
</tr>
<tr class="odd">
<td><code>-w</code></td>
<td>如果 make 在执行时改变目录，打印当前目录名</td>
</tr>
<tr class="even">
<td><code>-Wfile</code></td>
<td>如果文件己修改，则使用 <code>-n</code> 来显示 make 将要执行的命令</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>禁止使用所有 make 的内置规则</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>打印调试信息</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>忽略 makefile 规则中的命令执行后返回的非零错误码。此时，即使某个命令返回非零的退出状态值，make 仍将继续执行</td>
</tr>
<tr class="even">
<td><code>-k</code></td>
<td>如果某个目标编译失败，继续编译其他目标。通常，make 在一个目标编译失败后终止</td>
</tr>
<tr class="odd">
<td><code>jN</code></td>
<td>每次运行 N 条命令，这里 N 是非零整数</td>
</tr>
</tbody>
</table>
<h2 id="调试-make">5 调试 make</h2>
<p>如果在使用 make 时遇到问题，<code>-d</code> 选项能够使 make 在执行命令时打印大量的额外调试信息。此时，因为需要显示 make 内部所做的每一件事以及为什么做这些事的调试信息，将会产生大量的输出。其中包括如下信息：</p>
<ul>
<li>在重新编译时 make 需要检查的文件</li>
<li>被比较的文件以及比较的结果</li>
<li>需要被重新生成的文件</li>
<li>make 想要使用的隐式规则</li>
<li>make 实际使用的隐式规则以及所执行的命令</li>
</ul>
<h2 id="常见的-make-出错信息">6 常见的 make 出错信息</h2>
<p>这里列出使用 make 时可能遇到的最常用的出错信息，完整文档诮参见 make 使用手册或其信息页。</p>
<ul>
<li>No rule to make target 'target'. Stop makefile 中没有包含创建指定的 target 所需要的规则，而且也没有合适的默认规则可用。</li>
<li>'target' is up to date 指定 target 的相关文件没有变化。</li>
<li>Target 'target' not remade because of errors 在编译 target 时出错，这一消息仅在使用make的 -k 选项时才会出现。</li>
<li>command: Command not found make 找不到命令。递常是因为命令被拼写错误或者不在路径 <code>$PATH</code> 下。</li>
<li>Illegal option -option 在调用 make 时包含了不能被 make 识别的选项。</li>
</ul>
<h2 id="有用的-makefile-目标">7 有用的 makefile 目标</h2>
<p>除了前面提及的 clean，编写 makefile 时还有一些常用的目标。名为 install 的目标把最终的二进制文件，所支持的库文件或 shell 脚本，以及相关的文档移动到文件系统中与之相应的最终位置，并适当设置文件的权限和属主。此外，install 通常也编译程序，以及运行简单的测试以确认程序已正确编译。uninstall 目标则删除由 install 目标所安装的那些文件。如果需要，在设置 install 目标前存储系统当前的设置。</p>
<p>dist 目标可以用来生成准备发布的软件包。最低限度，dist 目标将删除编译工作目录中旧的二进制文件和目标文件并创建一个归档文件（如普通的压缩包），以便上传到万维网页或FTP站点。</p>
<p>为了方便其他开发者，可以用一个 tags 目标来创建或更新程序的标记表。如果程序的验证过程比较复杂，也可以创建一个 单独的 test 或 check 目标来执行这一过程并显示适当的诊断信息。与之类似，installtest 或 installcheck 目标，通常被用来验证安装过程。当然，在此之前，install 目标必须已经成功地编译和安装了所需的程序。</p>
]]></content>
      <categories>
        <category>programming-language</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>差分序列</title>
    <url>/posts/eaa75cf0/</url>
    <content><![CDATA[<p>本文将介绍差分序列的定义及其应用。</p>
<span id="more"></span>
<h1 id="差分序列数组">差分序列（数组）</h1>
<h2 id="差分序列的定义">差分序列的定义</h2>
<p>给定一个序列 a, a[i] 表示序列的第 i 个元素（编号从 0 开始），则其差分序列为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d[0] = a[0]  (i == 0)</span><br><span class="line">d[i] = a[i] - a[i-1]  (i &gt; 0)</span><br></pre></td></tr></table></figure>
<h2 id="差分序列示例">差分序列示例</h2>
<table>
<thead>
<tr class="header">
<th>索引 i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原始序列 a[i]</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
<td>9</td>
<td>7</td>
<td>10</td>
<td>0</td>
</tr>
<tr class="even">
<td>差分序列 d[i]</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>-1</td>
<td>5</td>
<td>-2</td>
<td>3</td>
<td>-10</td>
</tr>
</tbody>
</table>
<p>现在假设将区间 a[1, 4] 所有的数都加上 3，则：</p>
<table>
<thead>
<tr class="header">
<th>索引 i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原始序列 a[i]</td>
<td>0</td>
<td>2+3=5</td>
<td>5+3=8</td>
<td>4+3=7</td>
<td>9+3=12</td>
<td>7</td>
<td>10</td>
<td>0</td>
</tr>
<tr class="even">
<td>差分序列 d[i]</td>
<td>0</td>
<td>2+3=5</td>
<td>3</td>
<td>-1</td>
<td>5</td>
<td>-2-3=-5</td>
<td>3</td>
<td>-10</td>
</tr>
</tbody>
</table>
<p>然后将区间 a[3, 5] 所有的数都减去 5，则：</p>
<table>
<thead>
<tr class="header">
<th>索引 i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原始序列 a[i]</td>
<td>0</td>
<td>2+3=5</td>
<td>5+3=8</td>
<td>4+3=7-5=2</td>
<td>9+3=12-5=7</td>
<td>7-5=2</td>
<td>10</td>
<td>0</td>
</tr>
<tr class="even">
<td>差分序列 d[i]</td>
<td>0</td>
<td>2+3=5</td>
<td>3</td>
<td>-1-5=-6</td>
<td>5</td>
<td>-2-3=-5</td>
<td>3+5=8</td>
<td>-10</td>
</tr>
</tbody>
</table>
<h2 id="差分序列的性质">差分序列的性质</h2>
<p>仔细观察上面的示例，可以发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[2] = d[2] + a[1]</span><br><span class="line">     = d[2] + d[1] + a[0]</span><br><span class="line">     = d[2] + d[1] + d[0]</span><br></pre></td></tr></table></figure>
<p>根据定义，对原序列区间操作后，原序列最终各项值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[0] = d[0]  (i == 0)</span><br><span class="line">a[i] = d[i] + a[i-1]  (i &gt; 0)</span><br></pre></td></tr></table></figure>
<p>也即 a[i] 为 d[i] 的前缀和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[i] = d[0] + ... + d[i]</span><br></pre></td></tr></table></figure>
<h2 id="差分序列的应用">差分序列的应用</h2>
<p><strong>基于差分序列的性质，它主要用于快速处理区间加减操作和单点查询</strong></p>
<h3 id="快速处理区间加减操作">快速处理区间加减操作</h3>
<p>假如现在对 a[L, R] 区间上所有的数加上 delta，由以上的性质可知，第一个受影响的差分数组中的元素为 d[L]，即令 d[L] += delta，那么后面数列元素在计算过程中都会加上 delta；最后一个受影响的差分数组中的元素为d[R]，所以令 d[R+1] -= delta，即可保证不会影响到 R 以后数列元素的计算。这样我们不必对区间内每一个数进行处理，只需处理两个差分后的数即可。</p>
<p>简单来说，当对 a[L, R] 区间所有数进行加 delta 操作时，只需:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d[L] += delta</span><br><span class="line">d[R+1] -= delta</span><br></pre></td></tr></table></figure>
<p>那么此时计算 a[L] ... a[R] 都会加上 delta，这里用 (d[L] + delta) 表示归约后的 d[L]，则有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[L] = (d[L] + delta) + a[L-1]</span><br><span class="line">a[L+1] = d[L+1] + a[L] = d[L+1] + (d[L] + delta) + a[L-1]</span><br><span class="line">...</span><br><span class="line">a[R] = d[R] + a[R-1] = d[R] + ... + (d[L] + delta) + a[L-1]</span><br></pre></td></tr></table></figure>
<h3 id="单点查询求差分序列前缀和">单点查询（求差分序列前缀和）</h3>
<h4 id="改变-d-数组">改变 d 数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    d[i] += d[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="改变-a-数组">改变 a 数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = d[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    a[i] = d[i] + a[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html">https://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/c517589e/</url>
    <content><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作：</p>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<p>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。</p>
<span id="more"></span>
<h1 id="并查集">并查集</h1>
<h2 id="并查集是什么">并查集是什么</h2>
<p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。不过需要注意并查集虽然可以进行合并操作，但是却无法进行分割操作。</p>
<ul>
<li>查询元素 a 和元素 b 是否属于同一组。</li>
<li>合并元素 a 和元素 b 所在的组。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1e24844edcc38ebe52397ba94cf382d.png" alt="uf-func" /></p>
<h2 id="并查集的结构">并查集的结构</h2>
<p>并查集也是树形结构实现的。不过，不是二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d695760169a280d25e7442f96d7afdbf.png" alt="uf-struct" /></p>
<p>每个元素对应一个节点，每个组对应一棵树。在并查集中，哪个节点是哪个节点的父亲以及树的形状等信息无需多加关注，整体组成一个树形结构才是重要的。</p>
<p>（1）初始化</p>
<p>我们准备 n 个节点来表示 n 个元素。最开始时没有边。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b61b4b34b1278c478fadf7ceddef0a17.png" alt="uf-initial-state" /></p>
<p>（2）合并</p>
<p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树，也就把两个组合并为一个组了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c1fa7ad7ca0c1a199c4e1ef16edac35a.png" alt="uf-union" /></p>
<p>（3）查询</p>
<p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p>
<p>在下图中，元素 2 和元素 5 都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2 或元素 5 属于不同组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/81241fe164c49bca00235dffb8269cb7.png" alt="uf-find" /></p>
<h2 id="并查集实现中的注意点">并查集实现中的注意点</h2>
<p>在树形数据结构里，如果发生了退化的情况，那么复杂度就会变得很高。因此，有必要想办法避免退化的发生。在并查集中，只需按照如下方法就可以避免退化。</p>
<ul>
<li>对于每棵树，记录这棵树的高度(rank)。</li>
<li>合并时如果两棵树的 rank 不同，那么从 rank 小的向 rank 大的连边。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4844beffb80851e3db14bdf1e095e8e7.png" alt="uf-union-based-rank" /></p>
<p>此外，通过路径压缩，可以使得并查集更加高效。对于每个节点，一旦向上走到了一次根节点，就把这个点到父亲的边改为直接连向根。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3f76bfcaad7e4c16ee1e14035a15a234.png" alt="uf-path-compress-1" /></p>
<p>在此之上，不仅仅是所查询的节点，在查询过程中向上经过的所有的节点，都改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0946c0e632dac3e08e1581769f85708a.png" alt="uf-path-compress-2" /></p>
<p>在使用这种简化的方法时，为了简单起见，即使树的高度发生了变化，我们也不修改 rank 的值。</p>
<h2 id="并查集的复杂度">并查集的复杂度</h2>
<p>加入了这两个优化之后的并查集效率非常高。对 n 个元素的并查集进行一次操作的复杂度是 <span class="math inline">\(O(\alpha(n))\)</span>。在这里，<span class="math inline">\(\alpha(n)\)</span> 是阿克曼( Ackermann )函数的反函数。这比 <span class="math inline">\(O(log(n))\)</span> 还要快。</p>
<p>不过，这是“均摊复杂度”。也就是说，并不是每一次操作都满足这个复杂度，而是多次操作之后平均每一次操作的复杂度是 <span class="math inline">\(O(\alpha(n))\)</span> 的意思。</p>
<h2 id="并查集的实现">并查集的实现</h2>
<p>下面是并查集的实现的例子。在例子中，我们用编号代表每个元素。数组 par 表示的是父亲的编号，par[x] = x 时, x 是所在的树的根。</p>
<h3 id="路径压缩">路径压缩</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        self.par = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩-按秩rank合并">路径压缩 + 按秩（rank）合并</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 初始化 n 个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        self.par = <span class="built_in">list</span>(<span class="built_in">range</span>(n))  <span class="comment"># 祖先结点</span></span><br><span class="line">        self.rank = [<span class="number">0</span>] * n  <span class="comment"># 树的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询树的根</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并 x 和 y 所属的集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x = self.find(x)</span><br><span class="line">        y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.rank[x] &lt; self.rank[y]:</span><br><span class="line">            self.par[x] = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[y] = x</span><br><span class="line">            <span class="keyword">if</span> self.rank[x] == self.rank[y]:</span><br><span class="line">                self.rank[x] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a></p>
<p>&lt;&lt;挑战程序设计竞赛(第2版)&gt;&gt; 巫泽俊 2.4 并查集 p84-88</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>data-structure</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ高可用集群搭建</title>
    <url>/posts/85807abd/</url>
    <content><![CDATA[<p>RabbitMQ + HAProxy 高可用镜像模式集群部署</p>
<ul>
<li>为什么搭建 RabbitMQ 集群？</li>
<li>RabbitMQ 集群模式有哪些？</li>
<li>如何搭建 RabbitMQ 集群？</li>
<li>RabbitMQ 镜像模式的策略如何配置？</li>
</ul>
<span id="more"></span>
<h1 id="部署说明">部署说明</h1>
<p>下面将以一个示例说明多机部署一个高可用 RabbitMQ 集群的流程。</p>
<h2 id="前提">前提</h2>
<p>在部署集群前，必须在将成为集群成员的每个节点上安装 RabbitMQ，并确保每个节点之间能相互访问。</p>
<h2 id="rabbitmq-集群模式">RabbitMQ 集群模式</h2>
<ul>
<li><p>普通模式（默认的集群模式）</p>
<p>以两个节点 node1、node2 为例来进行说明。</p>
<p>对于 queue 来说，消息实体只存在于其中一个节点（node1 或 node2），node1 和 node2 两个节点仅有相同的元数据，即队列的结构。当消息进入 node1 节点的 queue 后，consumer 从 node2 节点消费时，RabbitMQ 会临时在 node1、node2 间进行消息传输，把 node1 中的消息实体取出并经过 node2 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 queue。否则无论 consumer 连接 node1 或 node2，出口总在 node1，会产生瓶颈。</p>
<p>当 node1 节点故障后，node2 节点无法取到 node1 节点中还未消费的消息实体。如果做了消息持久化，那么得等 node1 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</p></li>
<li><p>镜像模式</p>
<p>把需要的队列做成镜像队列，存在于多个节点，属于 RabbiMQ 的 HA 方案，在对业务可靠性要求较高的场合中比较适用。</p>
<p>该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。</p>
<p>要实现镜像模式，需要先搭建一个普通集群模式，在这个模式的基础上再配置策略以实现高可用。</p></li>
</ul>
<h2 id="集群节点类型">集群节点类型</h2>
<ul>
<li>内存（ram）节点</li>
<li>磁盘（disk）节点</li>
</ul>
<p>RAM 节点仅将内部数据库表存储在 RAM 中。这不包括消息，消息存储索引，队列索引和其他节点状态。</p>
<p>在大多数情况下，您希望所有节点都是磁盘节点。 RAM 节点是一种特殊情况，可用于提高 queue、exchange 或 binding 流失率较高的群集的性能。 RAM 节点不提供更高的消息速率。如有疑问，请仅使用磁盘节点。</p>
<p>由于 RAM 节点仅将内部数据库表存储在RAM中，因此它们必须在启动时从对等节点同步它们。这意味着一个群集必须至少包含一个磁盘节点。因此，不可能手动删除集群中最后剩余的磁盘节点。</p>
<p>在 RabbitMQ 集群中，当磁盘节点宕掉且集群中无其他可用的磁盘节点时，集群将无法写入新的队列元数据信息。</p>
<h2 id="环境准备">环境准备</h2>
<ul>
<li><p>系统系统：CentOS7 64位</p></li>
<li><p>三台服务器：192.168.0.231/232/233</p></li>
<li><p>服务器规划</p>
<table>
<thead>
<tr class="header">
<th>服务器</th>
<th>用途</th>
<th>主机名</th>
<th>节点类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.0.231</td>
<td>RabbitMQ 集群节点 1</td>
<td>node231</td>
<td>磁盘节点</td>
</tr>
<tr class="even">
<td>192.168.0.232</td>
<td>RabbitMQ 集群节点 2</td>
<td>node232</td>
<td>磁盘节点</td>
</tr>
<tr class="odd">
<td>192.168.0.233</td>
<td>RabbitMQ 集群节点 3</td>
<td>node233</td>
<td>磁盘节点</td>
</tr>
</tbody>
</table></li>
</ul>
<h1 id="集群搭建">集群搭建</h1>
<h2 id="普通模式">普通模式</h2>
<h3 id="配置-hosts">配置 hosts</h3>
<p><code>vim /etc/hosts</code> 编辑三个节点的 hosts 文件，在文件末尾添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.0.231 node231</span><br><span class="line">192.168.0.232 node232</span><br><span class="line">192.168.0.233 node233</span><br></pre></td></tr></table></figure>
<h3 id="配置-hostname">配置 hostname</h3>
<ul>
<li><p>node231</p>
<p><code>vim /etc/hostname</code> 编辑主机名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node231</span><br></pre></td></tr></table></figure>
<p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node231</span><br></pre></td></tr></table></figure>
<p>重启 network</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li>
<li><p>node232</p>
<p><code>vim /etc/hostname</code> 编辑主机名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node232</span><br></pre></td></tr></table></figure>
<p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node232</span><br></pre></td></tr></table></figure>
<p>重启 network</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li>
<li><p>node233</p>
<p><code>vim /etc/hostname</code> 编辑主机名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node233</span><br></pre></td></tr></table></figure>
<p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node233</span><br></pre></td></tr></table></figure>
<p>重启 network</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置-erlang-cookie">配置 erlang cookie</h3>
<p>RabbitMQ 集群是基于 erlang 进行同步的，在 erlang 的集群中各节点同步需要一个相同的 cookie，所以必须保证各节点 cookie 一致，不然节点之间就无法通信。这个 cookie 默认存放在 <code>/var/lib/rabbitmq/.erlang.cookie</code> 中。</p>
<p>在任意一个节点中 copy <code>.erlang.cookie</code> 文件到其它所有节点，如在 node1 上进行 copy :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.0.232:/var/lib/rabbitmq/</span><br><span class="line">[root@node231 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.0.233:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure>
<h3 id="重启节点">重启节点</h3>
<p><strong>如果后面执行 <code>rabbitmqctl stop_app</code> 失败，需要重启 node231、node232、node233 使配置生效。</strong></p>
<h3 id="启动-rabbitmq-server">启动 rabbitmq-server</h3>
<p>分别启动 node231、node232、node233 的 rabbitmq-server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# systemctl start rabbitmq-server</span><br><span class="line">[root@node232 ~]# systemctl start rabbitmq-server</span><br><span class="line">[root@node233 ~]# systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>
<h3 id="将节点加入集群">将节点加入集群</h3>
<p>将 node232、node233 节点加入 node231 节点集群中，<strong>在 node232、node233 中分别执行以下命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl join_cluster rabbit@node231</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>默认 RabbitMQ 启动后是磁盘节点，在这个 cluster 下，node231、node232 和 node233 都是是磁盘节点。</p></li>
<li><p>如果要使 node232、node233 都是内存节点，加上 <code>--ram</code> 参数即可，如 <code>rabbitmqctl join_cluster --ram rabbit@node232</code>。</p></li>
<li><p>如果想要更改节点类型，可以使用命令 <code>rabbitmqctl change_cluster_node_type disc(ram)</code>，修改节点类型前需要先 <code>rabbitmqctl stop_app</code>。</p>
<p>(Note: disk and disc are used interchangeably)</p></li>
</ul>
<h3 id="查看集群状态">查看集群状态</h3>
<p>任意节点执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure>
<h3 id="创建管理用户">创建管理用户</h3>
<p>如果在主机名变更前就已经创建过用户的，仍需要重新重新创建，因为主机名的变更，之前创建的用户无法登录 web 管理系统。</p>
<p>以下操作在 node231 下执行：</p>
<ul>
<li><p>创建 vhost（可选，默认使用 "/" vhost）</p>
<p>这里创建一个 vhost 用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# rabbitmqctl add_vhost testvhost</span><br></pre></td></tr></table></figure></li>
<li><p>创建用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# add_user admin password</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户角色</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# set_permissions -p testvhost admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启用-rabbitmq-management">启用 rabbitmq management</h3>
<p>在 node231 上启用 rabbitmq management</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node231 ~]# rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 http://192.168.0.231:15672，使用 "admin/password" 即可登录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/aa2b806e6f5fe277c99c51f62c909671.png" alt="web-management" /></p>
<h2 id="镜像模式">镜像模式</h2>
<p>上面已经完成 RabbitMQ 默认集群模式，但并不保证队列的高可用性，尽管 Exchanges、Bindings 这些可以复制到集群里的任何一个节点，但是队列内容不会复制。所以集群中的节点宕机后将直接导致队列无法应用或消息丢失，要想队列在节点宕机或故障时也能正常应用，需要复制队列内容到集群中的每个节点，这就要使用镜像队列了。</p>
<h3 id="镜像队列">镜像队列</h3>
<p>默认情况下，RabbitMQ 集群中 queue 的内容位于单个节点（声明该 queue 的节点）上。这与 exchanges 和 bindings 相反，exchanges 和 bindings 始终可以被视为在所有节点上。可以选择使 queue 跨多个节点进行镜像。</p>
<p>每个镜像队列由一个 master 和一个或多个镜像（mirrors）组成。master 托管在一个通常称为主节点的节点上。每个队列都有其自己的主节点。给定队列的所有操作都首先应用于队列的主节点，然后传播到镜像节点。这涉及排队发布，向消费者传递消息，跟踪来自消费者的确认等。</p>
<p>队列镜像意味着节点的集群。发布到队列的消息将复制到所有镜像。无论消费者连接到哪个节点，最终都会被连接到主节点，镜像节点都会丢弃已在主节点上确认的消息。因此，队列镜像可提高可用性，但不会在节点之间分配负载（所有参与的节点均完成所有工作）。</p>
<p>如果承载队列主节点发生故障，则最早的镜像将在同步后提升为新的主节点。根据队列镜像参数，也可以升级不同步的镜像。</p>
<h3 id="配置镜像策略">配置镜像策略</h3>
<p>使用策略（policiy）配置镜像参数。 一个策略按名称（使用正则表达式模式）匹配一个或多个队列，并且包含一个定义（可选参数的映射），该定义被添加到匹配队列的全部属性中。</p>
<h4 id="通过控制台添加策略">通过控制台添加策略</h4>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f690c8e9ed28c2bc2c120bdd360d6db9.png" alt="add-policy" /></p>
<p>如果其他节点也启用了 <code>rabbitmq_management</code>，此时其他节点的控制台，可以看到上面添加的这个策略，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9f8d54c88f312999ebda6a3563895be5.png" alt="show-policies" /></p>
<p>参数说明：</p>
<ul>
<li><p>Virtual host：策略应用的 vhost。</p></li>
<li><p>Name：为策略名称，可以是任何东西，但建议使用不带空格的基于ASCII的名称。</p></li>
<li><p>Pattern：与一个或多个 queue（exchange） 名称匹配的正则表达式，可以使用任何正则表达式。只有一个 <code>^</code> 代表匹配所有，<code>^test</code> 为匹配名称为 "test" 的 exchanges 或者 queue。</p></li>
<li><p>Apply to：Pattern 应用对象。</p></li>
<li><p>Priority：配置了多个策略时候的优先级，值越大，优先级越高。</p>
<p>（没有指定优先级的消息会以0优先级对待。对于超过队列所定最大优先级的消息，优先级以最大优先级对待）</p></li>
<li><p>Definition：一组键/值对（例如 JSON 文档），将被插入匹配 queues and exchanges 的可选参数映射中</p>
<p><code>ha-mode</code>：策略键，分为3种模式</p>
<ul>
<li><code>all</code> - 所有（所有的 queue）</li>
<li><code>exctly</code> - 部分（需配置 <code>ha-params</code> 参数，此参数为 int 类型。比如 3，众多集群中的随机 3 台机器）</li>
<li><code>nodes</code> - 指定（需配置 <code>ha-params</code> 参数，此参数为数组类型。比如 ["rabbit@node2", "rabbit@node3"] 这样指定为 node2 与 node3 这两台机器）</li>
</ul>
<p><code>ha-sync-mode</code>：队列同步</p>
<ul>
<li><code>manual</code>：手动（默认模式）。新的队列镜像将不会收到现有的消息，它只会接收新的消息</li>
<li><code>automatic</code>：自动同步。当一个新镜像加入时，队列会自动同步。队列同步是一个阻塞操作。</li>
</ul></li>
</ul>
<h4 id="通过命令行添加策略">通过命令行添加策略</h4>
<ul>
<li><p>设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>清除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_policy [-p &lt;vhost&gt;] &lt;name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_policies [-p &lt;vhost&gt;]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl set_policy -p testvhost testha <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span></span><br><span class="line">Setting policy &quot;testha&quot; for pattern &quot;^&quot; to &quot;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&quot; with priority &quot;0&quot; for vhost &quot;testvhost&quot; ...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_policies -p testvhost</span></span><br><span class="line">Listing policies for vhost &quot;testvhost&quot; ...</span><br><span class="line">vhost   name    pattern apply-to        definition      priority</span><br><span class="line">testvhost       testha  ^       all     &#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;    0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl clear_policy -p testvhost testha</span></span><br><span class="line">Clearing policy &quot;testha&quot; on vhost &quot;testvhost&quot; ...</span><br></pre></td></tr></table></figure>
<h3 id="测试策略是否生效">测试策略是否生效</h3>
<p>在控制台的队列页面上，镜像队列将展示策略名称和其他副本（镜像）数量。以下是一个名为 three_replicas 的队列的示例，该队列具有一个 master（主节点）和两个镜像节点。</p>
<p>添加队列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f87d9375a9966279b88a875b17f7a0f6.png" alt="add-queue" /></p>
<p>查看队列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/68f6f3b13a8ac482762e9ebc18bcb15c.png" alt="show-queues" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a898790949e41995ed079ca741392e54.png" alt="queue-detail" /></p>
<h1 id="haproxy-负载均衡">HAProxy 负载均衡</h1>
<p>HAProxy 是由 C 语言编写的免费的开源软件，它快速而高效，可为基于TCP和HTTP的应用程序提供高可用、高性能的负载平衡器和代理服务器。</p>
<h2 id="环境准备-1">环境准备</h2>
<table>
<thead>
<tr class="header">
<th>服务器</th>
<th>用途</th>
<th>系统</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.0.235</td>
<td>负载均衡服务器</td>
<td>Ubuntu 20.04</td>
<td>haproxy 2.0</td>
</tr>
</tbody>
</table>
<h2 id="安装">安装</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install haproxy</span></span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>
<p><code>vim /etc/haproxy/haproxy.cfg</code> 编辑 haproxy 配置文件，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    maxconn 512</span><br><span class="line">    stats socket /tmp/haproxy</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    mode http</span><br><span class="line">    option abortonclose</span><br><span class="line">    compression algo gzip</span><br><span class="line">    compression type text/html text/plain application/json</span><br><span class="line">    timeout connect 5000ms</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">    bind *:8888</span><br><span class="line">    mode http</span><br><span class="line">    log 127.0.0.1 local3 err</span><br><span class="line">    stats refresh 60s</span><br><span class="line">    stats uri /stats</span><br><span class="line">    stats realm Haproxy\ Manager</span><br><span class="line">    stats auth admin:password</span><br><span class="line">    stats hide-version</span><br><span class="line">    stats admin if TRUE</span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">    bind *:5672</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcpka</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server rabbit1 192.168.0.231:5672 check inter 1000 rise 2 fall 3 weight 1</span><br><span class="line">    server rabbit2 192.168.0.232:5672 check inter 1000 rise 2 fall 3 weight 1</span><br><span class="line">    server rabbit3 192.168.0.233:5672 check inter 1000 rise 2 fall 3 weight 1</span><br></pre></td></tr></table></figure>
<h2 id="验证-haproxy-配置">验证 HAProxy 配置</h2>
<p>修改配置后，在启动 HAProxy 前，应先运行以下命令验证配置文件语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">haproxy -f /etc/haproxy/haproxy.cfg -c -V</span></span><br><span class="line">Configuration file is valid</span><br></pre></td></tr></table></figure>
<p>如果收到错误消，请务必先修复，然后再继续。</p>
<h2 id="运行-haproxy">运行 HAProxy</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl restart haproxy</span></span><br></pre></td></tr></table></figure>
<p>查看状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status haproxy</span></span><br></pre></td></tr></table></figure>
<h2 id="haproxy-statistics">HAProxy Statistics</h2>
<p>浏览器访问 http://192.168.0.235:8888/stats，输入配置中的用户名和密码登录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/610268fb2fd2c6b3c7e5d46182643a3a.png" alt="haproxy-statistics" /></p>
<h1 id="references">References</h1>
<p><a href="https://www.rabbitmq.com/clustering.html">https://www.rabbitmq.com/clustering.html</a></p>
<p><a href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html</a></p>
<p><a href="https://www.rabbitmq.com/parameters.html#policies">https://www.rabbitmq.com/parameters.html#policies</a></p>
<p><a href="http://www.haproxy.org/">http://www.haproxy.org/</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>mq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析</title>
    <url>/posts/3274548c/</url>
    <content><![CDATA[<ul>
<li>算法的特性</li>
<li>时间复杂度</li>
<li>递归</li>
<li>分治法</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>哈夫曼编码</li>
<li>单源最短路径</li>
<li>最小生成树</li>
<li>并查集</li>
<li>优先队列</li>
<li>回溯法</li>
</ul>
<span id="more"></span>
<h1 id="算法的特性">算法的特性</h1>
<h2 id="定义">定义</h2>
<p>为了解决某类问题而规定的一个有限长的操作序列。</p>
<h2 id="算法的特性-1">算法的特性</h2>
<p>有穷性，确定性，可行性，输入，输出</p>
<h2 id="算法的性能标准">算法的性能标准</h2>
<p>正确性、可读性、健壮性、高效率和低存储需求</p>
<h1 id="时间复杂度">时间复杂度</h1>
<h2 id="常见算法时间复杂度">常见算法时间复杂度</h2>
<ul>
<li><span class="math inline">\(O(1)\)</span>: 表示算法的运行时间为常量</li>
<li><span class="math inline">\(O(n)\)</span>: 表示该算法是线性算法</li>
<li><span class="math inline">\(O(logn)\)</span>: 二分查找算法</li>
<li><span class="math inline">\(O(n^2)\)</span>: 对数组进行排序的简单算法，如直接插入排序。</li>
<li><span class="math inline">\(O(n^3)\)</span>: 做两个n阶矩阵的乘法运算</li>
<li><span class="math inline">\(O(2^n)\)</span>: 求具有n个元素集合的所有子集的算法</li>
<li><span class="math inline">\(O(n!)\)</span>: 求具有n个元素的全排列的算法</li>
</ul>
<h2 id="算法复杂性分析">算法复杂性分析</h2>
<p><span class="math display">\[
f(n)=O(g(n)) \qquad f(n)的阶≤g(n)的阶\\
f(n)=Ω(g(n)) \qquad f(n)的阶≥g(n)的阶\\
f(n)=θ(g(n)) \qquad f(n)的阶＝g(n)的阶\\
f(n)=o(g(n)) \qquad f(n)的阶＜g(n)的阶\\
\]</span></p>
<h1 id="递归">递归</h1>
<h2 id="二分查找递归">二分查找（递归）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; target) <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找非递归">二分查找（非递归）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序</h2>
<ul>
<li>选择划分基准 a(p)</li>
<li>将数组 a 划分成两个子数组，使得 <code>a[l...p-1] &lt;= a(p)</code>，<code>a[p+1...r] &gt;= a(p)</code></li>
<li>递归调用快速排序算法，对 <code>a[l...p-1]</code> 和 <code>a[p+1...r]</code> 进行排序</li>
</ul>
<h3 id="递归-1">递归</h3>
<p>C参考实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right, base = a[left], tmp;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt;= base &amp;&amp; i &lt; j) j--;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= base &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) tmp = a[i], a[i] = a[j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[i], a[i] = base;</span><br><span class="line">    quickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java参考实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            sort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            sort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: arr) System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归">非递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(left);</span><br><span class="line">        stack.push(right);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, begin, end);</span><br><span class="line">                stack.push(begin);</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">                stack.push(end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) System.out.print(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分治法">分治法</h1>
<h2 id="基本思想">基本思想</h2>
<p>将求解的较大规模的问题分割成 k 个更小规模的子问题。对这 k 个子问题分别求解。如果子问题的规模仍然不够小，则再划分为 k 个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。</p>
<h2 id="适用条件">适用条件</h2>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决；</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<h2 id="归并排序">归并排序</h2>
<p>其基本思想是：将待排序元素分成大小大致相同的 2 个子集合，分别对 2 个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> mid, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = x, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= y) tmp[t++] = a[i] &lt;= a[j] ? a[i++] : a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= y) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= y) a[x++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (x + y) / <span class="number">2</span>;</span><br><span class="line">        sort(a, x, mid, tmp);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, y, tmp);</span><br><span class="line">        merge(a, x, mid, y, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求逆序对数">求逆序对数</h2>
<p>考虑 <span class="math inline">\(1,2,…,n\)</span> 的排列 <span class="math inline">\(i1，i2，…，in\)</span>，如果其中存在 <span class="math inline">\(j,k\)</span>，满足 <span class="math inline">\(j &lt; k\)</span> 且 <span class="math inline">\(i_j &gt; i_k\)</span>， 那么就称 <span class="math inline">\((i_j,i_k)\)</span> 是这个排列的一个逆序。</p>
<p>一个排列含有逆序的个数称为这个排列的逆序数。例如排列 263451 含有8个逆序 (2,1),(6,3),(6,4),(6,5),(6,1),(3,1),(4,1),(5,1)，因此该排列的逆序数就是 8。显然，由 1,2,…,n 构成的所有 n! 个排列中，最小的逆序数是 0，对应的排列就是 1,2,…,n；最大的逆序数是 n(n-1)/2，对应的排列就是 n,(n-1),…,2,1。逆序数越大的排列与原始排列的差异度就越大。</p>
<p>基本思路：</p>
<p>1.使用二分归并（分治法）进行求解； 2.将序列依此划分为两两相等的子序列； 3.对每个子序列进行排序（比较 <code>a[i] &gt; a[j]</code>，如果满足条件，则求该子序列的逆序数 <code>count = mid - i + 1</code>，其中 <code>mid = (left + right) / 2</code>） 4.接着合并子序列即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[t++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[t++] = a[j++];</span><br><span class="line">            count += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) a[left++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, left, mid, tmp);</span><br><span class="line">        mergeSort(a, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">        merge(a, left, mid, right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速选择算法">快速选择算法</h2>
<p>基本思想：</p>
<p>快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(nlogn)\)</span> 至 <span class="math inline">\(O(n)\)</span>，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;  <span class="comment">// 选择a[right]作为划分基准</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quick_select</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> a[left];</span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> quick_select(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_select(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性时间选择bfprt">线性时间选择（BFPRT）</h2>
<p>基本思路：</p>
<ul>
<li>首先把数组按 5 个数为一组进行分组，最后不足 5 个的忽略。对每组数进行排序（如插入排序）求取其中位数。</li>
<li>把上一步的所有中位数移到数组的前面，对这些中位数递归调用 BFPRT 算法求得他们的中位数。</li>
<li>将上一步得到的中位数作为划分的主元进行整个数组的划分。</li>
<li>判断第k个数在划分结果的左边、右边还是恰好是划分结果本身，前两者递归处理，后者直接返回答案。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = right; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) tmp = a[j], a[j] = a[j<span class="number">-1</span>], a[j<span class="number">-1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> baseIdx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;</span><br><span class="line">    <span class="comment">// 将基准放于数组尾部</span></span><br><span class="line">    tmp = a[right], a[right] = a[baseIdx], a[baseIdx] = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfprt</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt;= <span class="number">5</span>)&#123;  <span class="comment">// 小于等于5个数，直接排序得到结果</span></span><br><span class="line">        bubble_sort(a, left, right);</span><br><span class="line">        <span class="keyword">return</span> a[left + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = left - <span class="number">1</span>, tmp;  <span class="comment">// t:当前替换到前面的中位数的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st = left, ed; (ed = st + <span class="number">4</span>) &lt;= right; st += <span class="number">5</span>)&#123;</span><br><span class="line">        bubble_sort(a, st, ed);</span><br><span class="line">        <span class="comment">// 将中位数替换到数组前面，便于递归求取中位数的中位数</span></span><br><span class="line">        tmp = a[++t], a[t] = a[st+<span class="number">2</span>], a[st+<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> baseIdx = (left + t) &gt;&gt; <span class="number">1</span>; <span class="comment">// left到t的中位数的下标，作为主元的下标</span></span><br><span class="line">    bfprt(a, left, t, baseIdx - left + <span class="number">1</span>); <span class="comment">// 不关心中位数的值，保证中位数在正确的位置</span></span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right, baseIdx), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> bfprt(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> bfprt(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划">动态规划</h1>
<h2 id="基本步骤">基本步骤</h2>
<ul>
<li>找出最优解的性质，并刻划其结构特征。</li>
<li>递归地定义最优值。</li>
<li>以自底向上的方式计算出最优值。</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ul>
<h2 id="矩阵连乘">矩阵连乘</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">matrixChain</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span>[][] m, <span class="type">int</span>[][] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + r - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最优子结构">最优子结构</h2>
<p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<p>例如，矩阵连乘计算次序问题的最优解包含着其子问题的最优解，这种性质称为最优子结构性质。</p>
<p><strong>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</strong></p>
<h2 id="重叠子问题">重叠子问题</h2>
<p>在递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。</p>
<p>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</p>
<h2 id="lis最长单调递增子序列">LIS最长单调递增子序列</h2>
<p>设序列为 a[0:n-1]，记 b[i]：以 a[i] 为结尾元素的最长递增子序列的长度。</p>
<p>则序列 a 的最长递增子序列长度为：<code>max&#123;b[i]&#125;, 0&lt;=i&lt;n</code></p>
<p>如何求 b[i] ?</p>
<p><code>b[0] = 1</code>，<code>b[i] = max&#123;b[k]&#125; + 1, (0&lt;=k&lt;i, a[k]&lt;=a[i])</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">LIS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, b[<span class="number">0</span>] = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt;= a[i] &amp;&amp; k &lt; b[j]) k = b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] = k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lcs最长公共子序列">LCS最长公共子序列</h2>
<p>给定 2 个序列，<span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span>，找出 X 和 Y 的最长公共子序列。</p>
<p>设序列 <span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span> 的最长公共子序列为 <span class="math inline">\(Z={z_1,z_2,…,z_k}\)</span>，则</p>
<p>1)若 <span class="math inline">\(x_m=y_n\)</span>，则 <span class="math inline">\(z_k=x_m=y_n\)</span>，且 <span class="math inline">\(Z_{k-1}\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列。</p>
<p>2)若 <span class="math inline">\(x_m≠y_n\)</span>，则 <span class="math inline">\(Z\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y\)</span> 的最长公共子序列，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列，中较长的序列。</p>
<p><strong>2 个序列的最长公共子序列包含了这 2 个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。</strong></p>
<p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用 <span class="math inline">\(c[i][j]\)</span> 记录序列的最长公共子序列的长度。其中，<span class="math inline">\(X_i={x_1,x_2,…,x_i}\)</span>；<span class="math inline">\(Y_j={y_1,y_2,…,y_j}\)</span>。当 <span class="math inline">\(i=0\)</span> 或 <span class="math inline">\(j=0\)</span> 时，空序列是 <span class="math inline">\(X_i\)</span> 和 <span class="math inline">\(Y_j\)</span> 的最长公共子序列。故此时 <span class="math inline">\(c[i][j]=0\)</span>。其他情况下，由最优子结构性质可建立递归关系如下：</p>
<ul>
<li><code>i=0,j=0</code>：<code>c[i][j]=0</code></li>
<li><code>i,j&gt;0; x[i]==y[i]</code>：<code>c[i][j]=c[i-1][j-1]+1</code></li>
<li><code>i,j&gt;0; x[i]!=y[i]</code>：<code>c[i][j]=max&#123;c[i][j-1],c[i-1][j]&#125;</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(b); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Algorithm <span class="title">lcsLength</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">    m = x.length - <span class="number">1</span>;</span><br><span class="line">    n = y.length - <span class="number">1</span>;</span><br><span class="line">    c[i][<span class="number">0</span>] = <span class="number">0</span>; c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Algorithm <span class="title">lcs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> [] x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == y[i])&#123;</span><br><span class="line">        <span class="built_in">lcs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, x);</span><br><span class="line">        <span class="built_in">print</span>(x[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) <span class="built_in">lcs</span>(i<span class="number">-1</span>, j, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">lcs</span>(i, j<span class="number">-1</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治法与动态规划的区别">分治法与动态规划的区别</h2>
<ul>
<li>分治法与动态规划有何共同点？提示：从所适用问题的特点，解决问题的方式上阐述
<ul>
<li>两者所解决的问题，都能划分为若干个规模较小的子问题</li>
<li>这些子问题具有最优子结构性质</li>
<li>能通过子问题的最优解自底向上地得到问题的最优解</li>
</ul></li>
<li>分治法与动态规划又有何不同？提示：从子问题的角度阐述
<ul>
<li>分治法适用于子问题相互独立的情况，即子问题之间不存在公共子问题</li>
<li>动态规划适用于子问题存在重叠的情况，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果</li>
</ul></li>
</ul>
<h1 id="贪心算法">贪心算法</h1>
<h2 id="基本思想-1">基本思想</h2>
<p>贪心算法总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<h2 id="活动安排问题">活动安排问题</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列</span></span><br><span class="line"><span class="comment"> * a数组记录是否安排相应活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">greedySelector</span><span class="params">(<span class="type">int</span> [] s, <span class="type">int</span> [] f, <span class="type">boolean</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            a[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> a[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最优子结构性质">最优子结构性质</h2>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p>
<h2 id="贪心选择性质">贪心选择性质</h2>
<p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p>
<p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择。然后再去解做出这个选择后产生的相应的子问题。</p>
<p><strong>贪心算法和动态规划算法都要求问题具有最优子结构性质，这是两类算法的一个共同点。</strong></p>
<p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。（即证明有解必有贪心解）</p>
<h2 id="贪心算法求解背包问题">贪心算法求解背包问题</h2>
<p>基本步骤：</p>
<ul>
<li>首先计算每种物品单位重量的价值 <span class="math inline">\(V_i/W_i\)</span></li>
<li>然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包</li>
<li>若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。</li>
<li>依此策略一直地进行下去，直到背包装满为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">float</span>[] v,<span class="type">float</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], v[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i].w &gt; c) <span class="keyword">break</span>;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].v;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)&#123;</span><br><span class="line">        x[d[i].i] = c / d[i].w;</span><br><span class="line">        opt += x[d[i].i] * d[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 0-1 背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。</p>
<p>事实上，在考虑 0-1 背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。</p>
<h2 id="最优装载问题">最优装载问题</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">loading</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">int</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; d[i].w &lt;= c; i++) &#123;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].w;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼编码">哈夫曼编码</h1>
<h2 id="应用">应用</h2>
<p>哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<h2 id="构造哈夫曼编码">构造哈夫曼编码</h2>
<ul>
<li>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树 T。</li>
<li>算法以 C 个叶结点开始，执行 C-1 次的“合并”运算后产生最终所要求的树 T。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/891129703366840b1bac668d27b5cd11.png" alt="huffman-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/af9941f332989278833bd160b2a58181.png" alt="huffman-2" /></p>
<h1 id="单源最短路径">单源最短路径</h1>
<h2 id="单源最短路问题">单源最短路问题</h2>
<p>给定带权有向图 G=(V,E)，其中每条边的权是非负实数。另外，还给定 V 中的一个顶点，称为源。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。</p>
<h2 id="dijkstra-算法">Dijkstra 算法</h2>
<p>Dijkstra 算法是解单源最短路径问题的贪心算法。其基本思想是，设置顶点集合 S 并不断地作贪心选择来扩充这个集合。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。</p>
<p>基本步骤：</p>
<ul>
<li>初始时，S 中仅含有源。</li>
<li>设 u 是 G 的某一个顶点，把从源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路径，并用数组 dist 记录当前每个顶点所对应的最短特殊路径长度。</li>
<li>Dijkstra 算法每次从 V-S 中取出具有最短特殊路长度的顶点 u，将 u 添加到 S 中，同时对数组 dist 作必要的修改。</li>
<li>一旦 S 包含了所有 V 中顶点，dist 就记录了从源到所有其他顶点之间的最短路径长度。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> dist[MAX_V];  <span class="comment">// 顶点s出发的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 已经使用过的图</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求从起点s出发到各个顶点的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + V, INF);</span><br><span class="line">    <span class="built_in">fill</span>(used, used + V, <span class="literal">false</span>);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从尚未使用过的顶点中选择一个距离最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || dist[u] &lt; dist[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            dist[u] = <span class="built_in">min</span>(dist[u], dist[v] + cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树">最小生成树</h1>
<h2 id="定义-1">定义</h2>
<p>设 <span class="math inline">\(G =(V,E)\)</span> 是无向连通带权图，即一个网络。<span class="math inline">\(E\)</span> 中每条边 <span class="math inline">\((v,w)\)</span> 的权为 <span class="math inline">\(c[v][w]\)</span>。如果 <span class="math inline">\(G\)</span> 的子图 <span class="math inline">\(G’\)</span> 是一棵包含 <span class="math inline">\(G\)</span> 的所有顶点的树，则称 <span class="math inline">\(G’\)</span> 为 <span class="math inline">\(G\)</span> 的生成树。生成树上各边权的总和称为该生成树的耗费。在 <span class="math inline">\(G\)</span> 的所有生成树中，耗费最小的生成树称为 <span class="math inline">\(G\)</span> 的最小生成树。</p>
<h2 id="最小生成树性质">最小生成树性质</h2>
<p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的真子集。如果 <span class="math inline">\((u,v) \in E\)</span>，且 <span class="math inline">\(u \in U\)</span>，<span class="math inline">\(v \in V-U\)</span>，且在所有这样的边中，<span class="math inline">\((u,v)\)</span> 的权 <span class="math inline">\(c[u][v]\)</span> 最小，那么一定存在 <span class="math inline">\(G\)</span> 的一棵最小生成树，它以 <span class="math inline">\((u,v)\)</span> 为其中一条边。这个性质有时也称为 MST 性质。</p>
<h2 id="prim算法">Prim算法</h2>
<p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(V={1,2,…,n}\)</span>。构造 <span class="math inline">\(G\)</span> 的最小生成树的 Prim 算法的基本思想是：</p>
<ul>
<li>首先置 <span class="math inline">\(S=\{1\}\)</span>，</li>
<li>然后，只要 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(V\)</span> 的真子集，就作如下的贪心选择</li>
<li>选取满足条件 <span class="math inline">\(i \in S\)</span>，<span class="math inline">\(j \in V-S\)</span>，且 <span class="math inline">\(c[i][j]\)</span> 最小的边，将顶点j添加到 <span class="math inline">\(S\)</span> 中。</li>
<li>这个过程一直进行到 <span class="math inline">\(S=V\)</span> 时为止。在这个过程中选取到的所有边恰好构成 G 的一棵最小生成树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> mistcost[MAX_V];  <span class="comment">// 从集合X出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 顶点i是否包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从不属于X的顶点中选取从X到其权值最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;  <span class="comment">// 把顶点v加入X</span></span><br><span class="line">        res += mincost[v];  <span class="comment">// 把边的长度加到结果里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kruskal-算法">Kruskal 算法</h2>
<p>Kruskal 算法构造 <span class="math inline">\(G\)</span> 的最小生成树的基本思想是：</p>
<ul>
<li>首先将 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(n\)</span> 个顶点看成 <span class="math inline">\(n\)</span> 个孤立的连通分支。</li>
<li>将所有的边按权从小到大排序。</li>
<li>然后从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接 2 个不同的连通分支</li>
<li>当查看到第 <span class="math inline">\(k\)</span> 条边 <span class="math inline">\((v,w)\)</span> 时，如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 分别是当前 2 个不同的连通分支 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 中的顶点时，就用边 <span class="math inline">\((v,w)\)</span> 将 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 连接成一个连通分支，然后继续查看第 <span class="math inline">\(k+1\)</span> 条边；</li>
<li>如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 在当前的同一个连通分支中，就直接再查看第 <span class="math inline">\(k+1\)</span> 条边。</li>
<li>这个过程一直进行到只剩下一个连通分支时为止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge &amp;e1, <span class="type">const</span> edge &amp;e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V, E;  <span class="comment">// 顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">krustral</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(es, es + E, comp);  <span class="comment">// 按照edge.cost的顺序从小到大排列</span></span><br><span class="line">    <span class="built_in">init_union_find</span>(V);  <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">        edge e = es[i];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">same</span>(e.u, e.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集">并查集</h1>
<h2 id="主要操作">主要操作</h2>
<ul>
<li>初始化 集合中每个元素单独作为一个子集。</li>
<li>查找 查找元素 x 所在的子集序号。常用来判断元素 x 和 y 是否在同一子集中。</li>
<li>合并 将元素 x 和 y 分别所在的子集合并为一个子集。</li>
</ul>
<h2 id="算法实现">算法实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用编号代表每个元素，数组par表示父亲的编号，当par[x]=x时，x是所在树的树根</span></span><br><span class="line"><span class="type">int</span> par[MAX_N];  <span class="comment">// 父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N];  <span class="comment">// 树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先队列">优先队列</h1>
<h2 id="主要操作-1">主要操作</h2>
<ul>
<li>初始化 将给定多个元素初始化为优先队列。</li>
<li>出队 将优先权最大的元素x出队，并调整结构为优先队列。</li>
<li>入队 加入元素x，并调整结构为优先队列。</li>
</ul>
<h2 id="算法实现-1">算法实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点从0开始编号</span></span><br><span class="line"><span class="type">int</span> heap[MAX_N], sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己节点的编号</span></span><br><span class="line">    <span class="type">int</span> i = sz++;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父亲节点的编号</span></span><br><span class="line">        <span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把父亲节点的数组放下来，而把自己提上去</span></span><br><span class="line">        heap[i] = heap[p];</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    <span class="type">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 要提到根的数值</span></span><br><span class="line">    <span class="type">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">// 从根开始向下交换</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">// 比较儿子的值</span></span><br><span class="line">        <span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把儿子的数值提上来</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i = a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="回溯法">回溯法</h1>
<h2 id="定义-2">定义</h2>
<p>为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法。</p>
<h2 id="基本思想-2">基本思想</h2>
<ul>
<li>针对所给问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构；</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>
<p><strong>常用剪枝函数：用约束函数在扩展结点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。</strong> 这种方法适用于解一些组合数相当大的问题。</p>
<h2 id="回溯法的特征">回溯法的特征</h2>
<p>用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为 <span class="math inline">\(h(n)\)</span>，则回溯法所需的计算空间通常为 <span class="math inline">\(O(h(n))\)</span>。</p>
<h2 id="递归回溯">递归回溯</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">            x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代回溯">迭代回溯</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterativeBacktrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(n,t) &lt;= <span class="built_in">g</span>(n,t))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">                x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">solution</span>(t)) <span class="built_in">output</span>(x);</span><br><span class="line">                    <span class="keyword">else</span> t++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求s的所有元素个数小于4的子集">求S的所有元素个数小于4的子集</h2>
<p>已知集合 <span class="math inline">\(S=\{a,b,c,d,e,f,g\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素个数小于 4 的子集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;a,b,c,d,e,f,g&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(x, t) &lt; <span class="number">4</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求s的所有元素和小于8的子集">求S的所有元素和小于8的子集</h2>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素和小于 8 的子集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sum</span>(x, t) &lt; <span class="number">8</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求s满足元素奇偶性相同且和小于8的子集">求S满足元素奇偶性相同且和小于8的子集</h2>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有满足下列条件的子集：元素奇偶性相同，且和小于 8。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t, <span class="type">int</span> sum, <span class="type">int</span> prior)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x[t] = <span class="number">0</span>, <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, prior);</span><br><span class="line">        x[t] = <span class="number">1</span>;</span><br><span class="line">        sum += s[t];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">8</span> &amp;&amp; (prior == <span class="number">-1</span> || (s[t] - s[prior]) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求s的所有排列">求S的所有排列</h2>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 S 的所有排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求s的所有满足奇偶数相间出现的排列">求S的所有满足奇偶数相间出现的排列</h2>
<p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7,8\}\)</span>，请编程输出 S 的所有满足下列条件的排列：奇偶数相间出现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>) bRet &amp;&amp;= ((s[t - <span class="number">1</span>] - s[t]) % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题">0-1 背包问题</h2>
<p>重量 <span class="math inline">\(w=\{2,2,3,4,5,5,6\}\)</span>， 价值 <span class="math inline">\(v=\{3,4,3,4,5,8,7\}\)</span>，<span class="math inline">\(C=16\)</span>，求背包的最大价值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">int</span> C = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> w[n] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> v[n] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>], Max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">process</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        sum += x[i] * w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += x[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Max &lt; sum) Max = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装载问题">装载问题</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="comment">// 搜索第i层结点</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) &#123;  <span class="comment">//到达叶结点更新最优解bestx</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r -= w[i];</span><br><span class="line">    <span class="keyword">if</span> (cw + w[i] &lt;= c) &#123;  <span class="comment">// 搜索左子树</span></span><br><span class="line">        x[i] = <span class="number">1</span>;</span><br><span class="line">        cw += w[i];</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cw + r &gt; bestw)  &#123;  <span class="comment">// 搜索右子树</span></span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r += w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n皇后问题">n皇后问题</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">place</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(k - j) == <span class="built_in">abs</span>(x[j] - x[k])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">place</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cs</category>
        <category>data-structure</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下Firewall的设置与使用</title>
    <url>/posts/6a7a0bd6/</url>
    <content><![CDATA[<p>防火墙 firewalld 守护服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。</p>
<span id="more"></span>
<div class="note info"><p><strong>[译]CentOS7下Firewall的设置与使用</strong> 原文出处：<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a> 原本作者：Justin Ellingwood 译者：wylu</p>
</div>
<h1 id="如何在centos7上使用firewalld设置防火墙">如何在CentOS7上使用FirewallD设置防火墙</h1>
<h2 id="简介">简介</h2>
<p>Firewalld 是可用于许多 Linux 发行版的防火墙管理解决方案，它充当 Linux 内核提供的 iptables 数据包过滤系统的前端。在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用 <code>firewall-cmd</code> 管理工具管理防火墙的基本知识（如果您希望在 CentOS中 使用 <code>iptables</code>，请遵循<a href="https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7">本指南</a>）。</p>
<p>注意：有可能您正在使用比撰写本文时可用的新版本的 firewalld，或者您的服务器设置与本指南中使用的示例服务器略有不同。因此，本指南中说明的某些命令的行为可能会因您的特定配置而异。</p>
<h2 id="firewalld中的基本概念">Firewalld中的基本概念</h2>
<p>在开始讨论如何实际使用 <code>firewall-cmd</code> 实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。</p>
<h3 id="zones">Zones</h3>
<p><code>firewalld</code> 守护程序使用称为 "zones" 的实体管理规则组。区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。为网络接口分配了一个区域，以指示防火墙应允许的行为。</p>
<p>对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改（如果有的话）。</p>
<p>无论您的网络环境有多动态，熟悉防火墙的每个预定义区域背后的一般概念仍然很有用。按从 <strong>最不信任</strong> 到 <strong>最受信任</strong> 的顺序，<code>firewalld</code> 中的预定义区域为：</p>
<ul>
<li>drop：最低级别的信任。所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。</li>
<li>block：与上述类似，但不仅仅是丢弃连接，而是使用 <code>icmp-host-prohibited</code> 或 <code>icmp6-adm-prohibited</code> 消息拒绝传入的请求。</li>
<li>public：代表公共的，不受信任的网络。您不信任其他计算机，但可能会视情况允许选择的传入连接。</li>
<li>external：如果您使用防火墙作为网关，则为外部网络。将其配置为伪装NAT，以便您的内部网络保持私有但可访问。</li>
<li>internal：外部区域的另一侧，用于网关的内部。这些计算机相当值得信赖，并且可以使用一些其他服务。</li>
<li>dmz：用于DMZ中的计算机（将无法访问网络其余部分的隔离计算机）。仅允许某些传入连接。</li>
<li>work：用于工作机。信任网络中的大多数计算机。可能还允许其他一些服务。</li>
<li>home：家庭环境。通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。</li>
<li>trusted：信任网络中的所有计算机。可用选项中最开放的，应谨慎使用。</li>
</ul>
<p>要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口分配给最合适的区域。</p>
<h3 id="规则永久性">规则永久性</h3>
<p>在 firewalld 中，可以将规则指定为 <strong>永久规则</strong> 或 <strong>立即规则</strong>。如果添加或修改规则，则默认情况下，将修改当前运行的防火墙的行为。在下次启动时，旧规则将恢复。</p>
<p>大多数 <code>firewall-cmd</code> 操作都可以使用 <code>--permanent</code> 标志来指示应将非临时防火墙作为目标。这将影响在引导时重新加载的规则集。这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。您还可以使用 <code>--permanent</code> 标志随着时间的推移建立一套完整的规则，这些规则将在发出 reload 命令时立即应用。</p>
<h2 id="安装并启用防火墙以在启动时启动">安装并启用防火墙以在启动时启动</h2>
<p>默认情况下，firewalld 是在某些 Linux 发行版上安装的，包括许多 CentOS 7 映像。但是，您可能需要自己安装 firewalld：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install firewalld</span></span><br></pre></td></tr></table></figure>
<p>安装 firewalld 之后，您可以启用该服务并重新启动服务器。请记住，启用 firewalld 将导致该服务在服务器启动时启动。最佳实践是在配置此行为之前创建防火墙规则并借此机会对其进行测试，以避免潜在的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> firewalld</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo reboot</span></span><br></pre></td></tr></table></figure>
<p>服务器重新启动时，防火墙会随之启动，然后将网络接口放入配置的区域（或退回到配置的默认区域），并且与该区域关联的所有规则都将应用于关联的接口。</p>
<p>我们可以通过键入以下内容来验证该服务正在运行并且可以访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --state</span></span><br><span class="line">running</span><br></pre></td></tr></table></figure>
<p>这表明我们的防火墙已启动并以默认配置运行。</p>
<h2 id="熟悉当前的防火墙规则">熟悉当前的防火墙规则</h2>
<p>在开始进行修改之前，我们应该熟悉守护程序提供的默认环境和规则。</p>
<h3 id="探索默认值">探索默认值</h3>
<p>通过键入以下内容，可以看到当前选择哪个区域作为默认区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure>
<p>由于我们没有给 firewalld 提供任何偏离默认区域的命令，并且我们的接口都没有配置为绑定到另一个区域，因此该区域（public 区域）也将是唯一的“活动”（active）区域（该区域正在控制我们接口的流量）。我们可以通过输入以下内容进行验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">public</span><br><span class="line">  interfaces: eth0 eth1</span><br></pre></td></tr></table></figure>
<p>在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（ <code>eth0</code> 和 <code>eth1</code> ）。目前，它们都根据为 public 区域定义的规则进行管理。</p>
<p>我们如何知道与 public 区域相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --list-all</span></span><br><span class="line">public (default, active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0 eth1</span><br><span class="line">  sources:</span><br><span class="line">  services: ssh dhcpv6-client</span><br><span class="line">  ports:</span><br><span class="line">  protocols:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  source-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>
<p>从输出中可以看出，该区域既是默认区域（default zone）又是活动区域（active zone），并且 <code>eth0</code> 和 <code>eth1</code> 接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。但是，我们还可以看到，该区域允许与 DHCP 客户端（用于 IP 地址分配）和 SSH（用于远程管理）相关的正常操作。</p>
<h3 id="探索可选区域">探索可选区域</h3>
<p>现在，我们对默认区域和活动区域的配置有了一个好主意。我们还可以找到有关其他区域的信息。</p>
<p>要获取可用区域的列表，请输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure>
<p>通过在 <code>--list-all</code> 命令中指定 <code>--zone</code> 参数，可以看到与指定区域关联的特定配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=home --list-all</span></span><br><span class="line">home</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: dhcpv6-client ipp-client mdns samba-client ssh</span><br><span class="line">  ports:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>--list-all-zones</code> 选项输出所有区域定义。您可能希望将输出通过管道传到 pager 中以便于查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --list-all-zones | less</span></span><br></pre></td></tr></table></figure>
<h2 id="为接口选定区域">为接口选定区域</h2>
<p>除非另外配置了网络接口，否则在启动防火墙时，每个接口都将置于默认区域中。</p>
<h3 id="更改接口区域">更改接口区域</h3>
<p>通过将 <code>--zone</code> 参数与 <code>--change-interface</code> 参数结合使用，可以在会话期间在区域之间转换接口。与所有修改防火墙的命令一样，您将需要使用 sudo。</p>
<p>例如，我们可以通过输入以下命令将 eth0 接口转换为 "home" 区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=home --change-interface=eth0</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>注意：每当将接口转换到新区域时，请注意您可能正在修改将要运行的服务。例如，在这里，我们将移至具有 SSH 可用的 "home" 区域。这意味着我们的连接不应断开。其他一些区域默认情况下未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。</p>
<p>我们可以通过再次请求活动区域来验证此操作是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">home</span><br><span class="line">  interfaces: eth0</span><br><span class="line">public</span><br><span class="line">  interfaces: eth1</span><br></pre></td></tr></table></figure>
<h3 id="调整默认区域">调整默认区域</h3>
<p>您最好用一个区域来处理所有接口，这样选择最佳的默认区域然后将其用于配置可能会更容易。</p>
<p>您可以使用 <code>--set-default-zone</code> 参数更改默认区域。这将立即将所有使用默认值的接口更改为新区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --set-default-zone=home</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<h2 id="为您的应用程序设置规则">为您的应用程序设置规则</h2>
<p>为希望提供的服务定义防火墙例外的基本方法很容易。我们将在此处介绍基本概念。</p>
<h3 id="将服务添加到您的区域">将服务添加到您的区域</h3>
<p>最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用 <code>--get-services</code> 选项获取可用服务的列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-services</span></span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure>
<p>注意：您可以通过查看 <code>/usr/lib/firewalld/services</code> 目录中与它们相关的 <code>.xml</code> 文件来获得有关每个服务的更多详细信息。例如，SSH 服务（/usr/lib/firewalld/services/ssh.xml）的定义如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>--add-service</code> 参数为区域启用服务。该操作将针对默认区域或 <code>--zone</code> 参数指定的任何区域。默认情况下，这只会调整当前的防火墙会话。您可以通过包括 <code>--permanent</code> 标志来调整永久防火墙配置。</p>
<p>例如，如果我们运行的是提供常规 HTTP 流量的 Web 服务器，则可以通过键入以下内容在此会话的 "public" 区域中为接口允许此流量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-service=http</span></span><br></pre></td></tr></table></figure>
<p>如果要修改默认区域，可以省略 <code>--zone</code>。我们可以使用 <code>--list-all</code> 或 <code>--list-services</code> 操作来验证操作是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --list-services</span></span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure>
<p>测试完所有功能后，您可能需要修改永久防火墙规则，以便重新启动后您的服务仍然可用。我们可以通过输入以下内容使 "public" 区域更改永久生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-service=http</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>您可以通过在 <code>--list-services</code> 操作中添加 <code>--permanent</code> 标志来验证此操作是否成功。您需要对任何 <code>--permanent</code> 操作使用sudo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --list-services</span></span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure>
<p>您的 "public" 区域现在将允许端口 80 上的 HTTP Web 通信。如果您的 Web 服务器配置为使用 SSL/TLS，则还需要添加 https 服务。我们可以通过输入以下内容将其添加到当前会话和永久规则集中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-service=https</span></span><br></pre></td></tr></table></figure>
<h3 id="如果没有适当的服务可用怎么办">如果没有适当的服务可用怎么办</h3>
<p>防火墙安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见要求。但是，在某些情况下，这些服务可能无法满足您的要求。</p>
<p>在这种情况下，您有两个选择。</p>
<h4 id="为您的区域打开端口">为您的区域打开端口</h4>
<p>为您的特定应用程序添加支持的最简单方法是打开它在相应区域中使用的端口。这就像指定端口或端口范围以及需要打开的端口的关联协议一样容易。</p>
<p>例如，如果我们的应用程序在端口 5000 上运行并使用 TCP，则可以使用 <code>--add-port</code> 参数将其添加到此会话的 "public" 区域中。协议可以是 tcp 或 udp：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-port=5000/tcp</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>--list-ports</code> 操作验证此操作是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --list-ports</span></span><br><span class="line">5000/tcp</span><br></pre></td></tr></table></figure>
<p>也可以通过用 <code>-</code> 分隔范围内的开始和结束端口来指定顺序的端口范围。例如，如果我们的应用程序使用 UDP 端口 4990 至 4999，则可以通过键入以下内容在 "public" 端口上打开这些端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-port=4990-4999/udp</span></span><br></pre></td></tr></table></figure>
<p>经过测试后，我们可能希望将它们添加到永久防火墙中。您可以通过键入以下内容进行操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-port=5000/tcp</span></span><br><span class="line">success</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-port=4990-4999/udp</span></span><br><span class="line">success</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --list-ports</span></span><br><span class="line">5000/tcp 4990-4999/udp</span><br></pre></td></tr></table></figure>
<h4 id="定义服务">定义服务</h4>
<p>为您的区域打开端口很容易，但是很难跟踪每个区域的用途。如果您曾经停用服务器上的服务，则可能很难记住仍需要打开哪些端口。为了避免这种情况，可以定义服务。</p>
<p>服务只是带有相关名称和描述的端口的简单集合。使用服务比端口更易于管理，但是需要一些前期工作。最简单的开始方法是将现有脚本（在 /usr/lib/firewalld/services 中找到）复制到 /etc/firewalld/services 目录中，防火墙在该目录中查找非标准定义。</p>
<p>例如，我们可以复制 SSH 服务定义以用于我们的 "example" 服务定义，如下所示。文件名减去 <code>.xml</code> 后缀将指示防火墙服务列表中的服务名称：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/example.xml</span></span><br></pre></td></tr></table></figure>
<p>现在，您可以调整在复制的文件中找到的定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vi /etc/firewalld/services/example.xml</span></span><br></pre></td></tr></table></figure>
<p>首先，文件将包含您复制的 SSH 定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该定义的大部分实际上是元数据。您将要在 <code>&lt;short&gt;</code> 标记内更改服务的简称。这是您的服务的易读名称。您还应该添加描述，以便在需要审核服务时获得更多信息。您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。可以多次指定。</p>
<p>对于我们的 "example" 服务，假设我们需要为 TCP 打开端口 7777，为 UDP 打开端口 8888。通过按 <code>i</code> 进入 INSERT 模式，我们可以使用以下内容修改现有定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>Example Service<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is just an example service.  It probably shouldn&#x27;t be used on a real system.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;udp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>按 ESC，然后输入 <code>:x</code> 保存并关闭文件。</p>
<p>重新加载防火墙以访问新服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --reload</span></span><br></pre></td></tr></table></figure>
<p>您可以看到它现在在可用服务列表中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-services</span></span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure>
<p>现在，您可以像往常一样在您的区域中使用此服务。</p>
<h2 id="创建自己的区域">创建自己的区域</h2>
<p>尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。</p>
<p>例如，您可能要为 Web 服务器创建一个名为 "publicweb" 的区域。或者，您可能希望为您在专用网络上提供的 DNS 服务配置另一个区域，您可能需要一个名为 "privateDNS" 的区域。</p>
<p>添加区域时，必须将其添加到永久防火墙配置中。然后，您可以重新加载以将配置带入正在运行的会话。例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --new-zone=publicweb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --new-zone=privateDNS</span></span><br></pre></td></tr></table></figure>
<p>您可以通过键入以下内容来验证这些内容是否存在于您的永久配置中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --get-zones</span></span><br><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure>
<p>如前所述，这些功能在当前的防火墙实例中尚不可用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure>
<p>重新加载防火墙以使这些新区域进入活动配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure>
<p>现在，您可以开始为您的区域分配适当的服务和端口。通常，最好先调整活动实例，然后在测试后将这些更改转移到永久配置中。例如，对于 "publicweb" 区域，您可能想要添加 SSH，HTTP 和 HTTPS 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=http</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --list-all</span></span><br><span class="line">publicweb</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: ssh http https</span><br><span class="line">  ports:</span><br><span class="line">  protocols:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  source-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>
<p>同样地，我们可以将 DNS 服务添加到我们的 "privateDNS" 区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --add-service=dns</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --list-all</span></span><br><span class="line">privateDNS</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: dns</span><br><span class="line">  ports:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>
<p>然后，我们可以将网络接口更改为这些新区域以对其进行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --change-interface=eth0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --change-interface=eth1</span></span><br></pre></td></tr></table></figure>
<p>此时，您将有机会测试您的配置。如果这些值对您有用，您将要向永久配置添加相同的规则。您可以通过使用 <code>--permanent</code> 标志重新应用规则来做到这一点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=http</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --permanent --add-service=dns</span></span><br></pre></td></tr></table></figure>
<p>在永久应用了这些规则之后，您可以重新启动网络并重新加载防火墙服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart network</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl reload firewalld</span></span><br></pre></td></tr></table></figure>
<p>验证是否分配了正确的区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">privateDNS</span><br><span class="line">  interfaces: eth1</span><br><span class="line">publicweb</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure>
<p>并验证相应的服务可用于两个区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --list-services</span></span><br><span class="line">http https ssh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --list-services</span></span><br><span class="line">dns</span><br></pre></td></tr></table></figure>
<p>您已经成功设置了自己的区域！ 如果要将这些区域之一设为其他接口的默认区域，请记住使用 <code>--set-default-zone</code> 参数配置该行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --set-default-zone=publicweb</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>您现在应该对如何在 CentOS 系统上日常使用的防火墙服务进行充分的了解。</p>
<p>Firewalld 服务允许您配置考虑网络环境的可维护规则和规则集。它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。</p>
]]></content>
      <categories>
        <category>os</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信机制</title>
    <url>/posts/9fb7f5b4/</url>
    <content><![CDATA[<p>进程通信（Inter-Process Communication, IPC）是指进程之间的信息交换。其所交换的信息量，少则是一个状态或数值，多则是成千上万个字节。多个进程为了协调完成一项工作，相互之间必须能够进行通信。进程的互斥和同步可归结为低级通信。进程的高级通信是指用户可直接利用系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节，即对用户来说是透明的。这样就大大简化了通信程序编程上的复杂性。</p>
<span id="more"></span>
<h1 id="进程间通信机制">进程间通信机制</h1>
<p>Linux 操作系统支持以下几种进程间通信机制：</p>
<ul>
<li>Unix IPC 机制
<ul>
<li>信号（signal）</li>
<li>管道（pipe）和命名管道（named pipe）</li>
</ul></li>
<li>System V 的 IPC 机制
<ul>
<li>信号量（semaphore）</li>
<li>消息队列（message queue）</li>
<li>共享内存（shared memory）</li>
</ul></li>
<li>网络通信的套接字机制
<ul>
<li>套接字（socket）</li>
</ul></li>
<li>全双工管道机制</li>
</ul>
<p>以上各种通信机制都提供了相应的接口，IPC 结构图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e7555aebbcdae382572ddedda53516e8.png" alt="IPC" /></p>
<h2 id="信号">信号</h2>
<p>信号是用来向一个或多个进程发送异步事件的软件机制，它类似于硬件中断，所以也叫软中断。信号不仅可以从键盘中断中产生，进程对虚拟内存的非法存取等系统错误环境下也会有信号产生，此外信号还被 shell 程序用来向其子进程发送任务控制命令。</p>
<p>系统中有一组被详细定义的信号类型，使用 <code>man 7 signal</code> 可以看到详细介绍。除了 SIGSTOP（进程终止执行）和 SIGKILL（进程退出）两个信号外，进程可以忽略其余信号。信号没有相对优先级，如果在同一时刻对于一个进程产生了两个信号，则它们将可能以任意顺序到达进程并进行处理。同时 Linux 并不提供处理多个相同类型信号的方式。</p>
<p>信号个数受到处理器字长的限制。32 位字长的处理器最多可以有 32 个信号，而 64 位处理器可以有最多 64 个信号。Linux 通过存储在进程 task_struct 中的信息来实现信号。当前未处理的信号保存在 signal 域中，并带有保存在 blocked 中的被阻塞信号的屏蔽码。除了 SIGSTOP 和 SIGKILL 外，所有的信号都能被阻塞。</p>
<p>系统中只有核心和超级用户进程可以向其他所有进程发送信号，普通进程只能向具有相同 uid 和 gid 的进程或者在同一进程组中的进程发送信号。信号是通过设置 task_struct 结构中 signal 域里的某一位来产生的。如果进程没有阻塞信号并且处于可中断的等待状态，则可以将其状态改成 Running，同时如确认进程还处在运行队列中，就可以通过信号唤醒它。这样系统下次发生调度时，调度管理器将选择它运行。信号必须等待到进程再次运行时才交给它，每次进程从系统调用中退出前，它都会检查 signal 和 blocked 域，看是否有可以立刻发送的非阻塞信号。对当前不可阻塞信号的处理代码放置在 sigaction 结构中。</p>
<h2 id="管道">管道</h2>
<p>管道是一个先进先出、大小固定的缓冲区，容量为 1 页（4KB），用于两个进程之间的单向数据传递。当管道有空间时，写者进程把数据送入管道，否则将被阻塞；如果管道中没有数据或读者进程需要的数据多于其中的数据，读者进程会被阻塞，否则执行读者进程的请求。整个过程由操作系统监控完成，互斥地访问管道。当传送的数据量大于管道的容量时，可以通过同步机制分次传送数据。</p>
<h3 id="无名管道">无名管道</h3>
<p>例如：Linux shell 程序中的重定向操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | more</span></span><br></pre></td></tr></table></figure>
<p>在这个管道应用中，<code>ls</code> 列出当前目录的输出被作为标准输入送到 more 程序中按格式显示处理。无名管道是将两个相关联的进程联系在一起。shell 程序负责在进程间建立临时的管道。</p>
<p>在 Linux 中，管道是通过指向同一个临时 VFS（Virtual File System，虚拟文件系统）inode 的两个 file 数据结构来实现的，此 VFS inode 指向内存中的一个物理块。当写者进程向管道中写入数据时，字节被复制到共享数据页面中，当读者进程从管道中读时，字节从共享数据页面中复制出来。</p>
<p>Linux 必须同步对管道的访问。它必须保证读者和写者进程以确定的步骤执行，为此需要使用锁、等待队列和信号等同步机制。以写数据为例，如果没有足够的空间容纳对所有写入管道的数据，或者管道被读者进程加锁时，当前进程将在管道 inode 的等待队列中睡眠，同时调度管理器开始执行以选择其他进程来执行。当有足够的空间或者管道被解锁时，它将被读者唤醒，然后执行写操作。当两个进程对管道的使用结束时，管道 inode 和共享数据页面将同时被释放。</p>
<h3 id="命名管道">命名管道</h3>
<p>Linux 还支持命名管道（named pipe），即 FIFO 管道，为两个不相关的进程提供通信手动。命名管道不是临时对象，它们是文件系统中的实体并且可以通过 <code>mknod</code> 命令来创建。进程只要拥有适当的权限就可以自由使用 FIFO 管道。在写者进程使用之前，Linux 必须让读者进程先打开此 FIFO 管道；任何读者进程从中读取之前必须有写者进程向其写入数据。</p>
<h2 id="消息队列">消息队列</h2>
<p>Linux 系统也支持 System V 的进程间通信机制，包括消息序列、信号量和共享内存。所有的 IPC 对象在 Linux 中有一个公共的 ipc_perm 结构，它含有进程拥有者、创建者和组标志符，对此对象（拥有者，组及其他）的存取模式以及 IPC 对象键。</p>
<p>消息是按一定格式封装起来的消息。每个进程都有一个与之关联的消息队列，接收进程按时间顺序或消息类型从消息队列取走消息。如果进程向一个满队列发送消息或从一个空队列取走消息都会被阻塞。</p>
<p>Linux 系统维护着一个 msgque 消息队列链表，其中每个元素指向一个描述消息队列 msqid_ds 结构，该结构完整地描述一个消息队列。每个 msqid_ds 结构包含一个 ipc_perm 结构和指向已经进入此队列消息的指针。另外，Linux 保留有关队列修改时间信息，如上次系统向队列中写入的时间等。msqid_ds 包含两个等待队列：一个为队列写入进程使用而另一个由队列读取进程使用。</p>
<p>每次进程试图向写入队列写入消息时，系统将把其有效用户和组标志符与此队列的 ipc_perm 结构中的模式进行比较。如果允许写入操作，则把此消息从该进程的地址空间复制到 msg 数据结构中，并放置到此消息队列尾部。如果消息队列的长度已满，则该写入进程将被阻塞，并调度新进程运行。若有消息被取走时，该进程将被唤醒。读进程执行时将选择队列中第一个消息或者某特定类型的消息。如果没有消息可以满足此要求，读进程将被阻塞，并运行调度程序。当有新消息写入队列时，进程将被唤醒。</p>
<h2 id="信号量">信号量</h2>
<p>信号量是用一个整数表示系统当前资源的使用情况，当信号量大于或等于 0 时，其值表示可用资源的数量，当它小于 0 时，其值表示等待该资源的进程数。信号量是 wait 和 signal 原语的推广，可以通过它实现进程的同步与互斥。例如用信号量实现临界区（critical region）的互斥，即在某一时刻在此区域内的代码只能被一个进程执行。</p>
<h3 id="数据结构">数据结构</h3>
<p>信号量在 Linux 中使用以下几个数据结构来表示：</p>
<ul>
<li>sem：表示系统中的每个信号量</li>
<li>semid_ds：表示信号量的集合</li>
<li>sem_queue：表示由每个信号量集合所构成的队列</li>
</ul>
<p>semid_ds 结构的 sem_base 指向一个 sem 数组，进程可以使用系统调用来操作这些信号量数组。</p>
<h3 id="实现过程">实现过程</h3>
<p>在执行信号量操作时，Linux 首先将检查是否所有操作已经成功。如果操作值与信号量当前数组相加大于 0，或者操作值与信号量当前值都是 0，操作将会成功。如果所有信号量操作失败，Linux 仅仅会把那些操作标志没有要求系统调用为非阻塞类型的进程挂起。进程挂起后，Linux 必须保存信号量操作的执行状态并将当前进程放入等待队列。系统还堆栈上建立 sem_queue 结构并填充各个域。 这个 sem_queue 结构将被放到信号量对象等待队列的尾部。系统把当前进程置入 sem_queue 结构中的等待队列中，然后执行调度程序。</p>
<p>如果所有这些信号量操作都成功则无须挂起当前进程，Linux 将对信号量数组中的其他成员进行相同操作，然后检查那些处于等待或挂起状态的进程。首先，Linux 将依次检查挂起队列（sem_pending）中的每个成员，看信号量操作能否继续。如果可以则将其 sem_queue 结构从挂起链表中删除并对信号量数组发出信号灯操作。Linux 还将唤醒处于睡眠状态的进程并使之成为下一个运行的进程。如果在对挂起队列的遍历过程中有的信号量操作不能完成则 Linux 将一直重复此过程，直到所有信号量操作完成且没有进程需要继续睡眠。</p>
<h3 id="与信号量有关的系统调用">与信号量有关的系统调用</h3>
<ul>
<li><code>semget()</code>：创建新的信号量集合或存取一个已有的信号量集合。</li>
<li><code>semop()</code>： 当操作数和信号量的值相加大于或等于 0 时，即进程请求的资源能够满足，操作成功，返回 0；若相加后其中某个值小于 0，资源不能满足，将进程阻塞，操作不成功。</li>
<li><code>semctl()</code>：在信号量集合上完成指定的命令操作。</li>
</ul>
<h3 id="死锁">死锁</h3>
<p>死锁是信号量使用过程中可能产生的一个最严重的问题。当一个进程进入临界区时它修改了信号量的值，然后在离开临界区时由于运行失败或者被 kill 而没有改回信号量时，死锁将会发生。</p>
<p>Linux 为了避免死锁的发生，为每个进程维护至少一个对应于信号量数组的 sem_undo 结构，它保存了完成信号量操作之前的状态。当对信号量进行操作时，信号量变化的数值被放入进程的 sem_undo 结构的该信号的入口中。当进程被删除时，Linux 将遍历该进程的 sem_undo 集合对信号量数组使用调整值。如果信号量集合被删除而 sem_undo 数据结构还在进程的 task_struct 结构中，则此信号灯数组标志符将被置为无效。此时信号量清除代码只需丢弃 sem_undo 即可。</p>
<h2 id="共享存储区">共享存储区</h2>
<p>共享存储区是指被多个进程共享的虚存中的一个数据块，进程利用它来实现通信。此虚拟内存的页面出现在每个共享进程页表中，但位置可以不同。每个进程有相应的读或读写权限，对共享存储区的互斥访问必须依赖于其他机制，如信号量。</p>
<p>每个新创建的共享存储区由一个 shmid_ds 数据结构来表示，它描述共享存储区的大小，进程如何使用以及共享存储区映射到各自地址空间的方式。由共享存储区创建者控制对此内存的存取权限。</p>
<p>每个使用此共享内存的进程必须它能通过系统调用将其连接到虚拟内存上，但在连接时并没有创建共享存储区，只有进程访问它时才创建。当进程首次访问共享虚拟内存中的页面时将产生缺页中断。当取回此页面后，Linux 找到了描述此页面的数据结构。它包含指向使用此种类型虚拟内存的处理函数地址指针。当发生共享内存页面缺页错误时，错误处理代码将在此 shmid_ds 对应的页表入口链表中寻找此页面是否在内存。如果不在，则为其分配物理页面并创建页表入口。同时还将它放入当前进程的页表中，此入口被保存在 shmid_ds 结构中。下个访问此内存的进程就会连接到此页面上。这样，第一个访问虚拟内存页面的进程创建这块内存，随后的进程把此页面加入到各自的虚拟地址空间中。</p>
<p>不再使用共享存储区的进程将断开与之的连接，其对应的页面结构将从 shmid_ds 结构中删除并回收。当前进程对应此共享内存地址的页表入口也将被更新并置为无效。当最后一个进程断开与共享内存的连接时，当前位于物理内存中的共享内存页面将被释放，同时删除 shmid_ds 结构。</p>
]]></content>
      <categories>
        <category>os</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>进程间通信</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/posts/3a046ccf/</url>
    <content><![CDATA[<p>操作系统的重要任务之一是管理计算机的软、硬件资源。现代操作系统的主要特点在于程序的并发执行，由此引出系统的资源被共享和用户随机使用系统。因而操作系统最核心的概念就是进程：即正在运行的程序。操作系统借助于进程来管理计算机的软、硬件资源，支持多任务的并发。操作系统的其他内容都是围绕进程展开的。所以进程管理是 Linux 操作系统内核的主要内容之一，它对整个操作系统的执行效率至关重要。</p>
<span id="more"></span>
<div class="note info"><p><strong>Linux 进程管理</strong> 原文出处：《操作系统实验指导-基于Linux内核》第2版 原文作者：徐虹 何嘉 张钟澍</p>
</div>
<h1 id="linux-进程管理">Linux 进程管理</h1>
<p>进程是一个动态的实体，是一个可并发执行的程序在一个数据集合上的运行过程，它是一个正在执行的程序，是操作系统分片资源的基本单位。进程不仅包含指令和数据，也包含程序计数器和所有 CPU 寄存器的值，同时它的堆栈中存储着如子程序参数、返回地址以及变量之类的临时数据。</p>
<p>Linux 的进程具有独立的权限与职责。如果系统中某个进程崩溃，它不会影响到其余的进程。每个进程运行在其各自的虚拟地址空间中，进程之间发生联系只能通过核心控制下的可靠通信机制来完成。</p>
<p>进程在生命周期内将使用系统中的资源。它利用系统中的 CPU 来执行命令，在物理内存中放置指令和数据，使用文件系统提供的功能打开并使用文件，同时直接或间接地使用物理设备。Linux 必须跟踪系统中每个进程以及资源，以便在进程间实现资源的公平分配。</p>
<p>Linux 支持多种类型的可执行文件格式，如 ELF、Java 等。由于这些进程必须使用系统共享库，所以对它们的管理要具有透明性。</p>
<ul>
<li>描述进程的数据结构</li>
<li>进程调度</li>
<li>创建进程</li>
<li>进程通信机制</li>
</ul>
<h2 id="描述进程的数据结构">描述进程的数据结构</h2>
<p>Linux 用 task_struct 数据结构来表示每个进程，在 Linux 中任务与进程表示的意义是一样的。系统维护一个名为 task 的数组，task 包含指向系统中所有进程的 task_struct 结构的指针。这意味着系统中的最大进程数目受 task 数组大小的限制，默认值一般为 512。创建新进程时，Linux 将从系统内存中分配一个 task_struct 结构并将其加入 task 数组。当前运行进程的结构用 current 指针来指示。</p>
<p>Linux 还支持实时进程。这些进程必须对外部事件作出快速反应，系统将区分对待这些进程和其他进程。虽然 task_struct 数据结构庞大而复杂，但可以归纳为如下几类：</p>
<h3 id="进程的状态信息state">进程的状态信息（state）</h3>
<p>进程在执行过程中会根据环境来改变进程的状态，Linux 进程有以下状态。</p>
<ul>
<li><p>Running</p>
<p>进程处于运行（它是系统的当前进程）或者准备运行状态（它在等待系统将 CPU 分配给它）。</p></li>
<li><p>Waiting</p>
<p>进程在等待一个事件或者资源。Linux 将等待进程分成两类：可中断与不可中断。可中断等待进程可以被信号中断；不可中断等待进程是由于硬件原因而等待，例如进程打开某个设备文件，在得到设备的回应前处于等待状态，因此在任何情况下都不可中断。</p></li>
<li><p>Stopped</p>
<p>进程被停止，通常是通过接收一个信号。正在被调试的进程可以处于停止状态。</p></li>
<li><p>Zombie</p>
<p>这是因为某些原因而被终止的进程，但是在 task 数组中仍然保留其 task_struct 结构。它像一个已经死亡的进程。</p></li>
</ul>
<h3 id="调度信息scheduling-information">调度信息（scheduling information）</h3>
<p>Linux 调度进程所需要的信息，包括进程的类型（普通或实时）和优先级，计数器中记录允许进程执行的时间量。</p>
<h3 id="进程标识信息identifiers">进程标识信息（identifiers）</h3>
<p>系统中每个进程都有进程标志。进程标志并不是 task 数组的索引，它仅仅是个数字。每个进程还有一个用户与组标志，它们用来控制进程对系统中的文件和设备的存取权限。</p>
<h3 id="进程的通信信息inter-process-communication">进程的通信信息（inter-process communication）</h3>
<p>Linux 支持经典的 UNIX IPC 机制，如信号、管道和命名管道以及 System V 中 IPC 机制，包括共享内存、信号量和消息队列。</p>
<h3 id="链接信息links">链接信息（links）</h3>
<p>Linux 系统中所有进程都是相互联系的。除了初始化进程外，所有进程都有一个父进程。新进程不是被创建，而是被复制，都是从以前的进程克隆而来。每个进程对应的 task_struct 结构中包含有指向其父进程和兄弟进程（具有相同父进程的进程）以及子进程的指针。</p>
<p>系统中所有进程都用一个双向链表连接起来，而它们的根是 init 进程的 task_struct 数据结构。这个链表被 Linux 核心用来寻找系统中所有进程，它为 ps 或者 kill 命令提供了支持。</p>
<h3 id="时间和定时器信息times-and-timers">时间和定时器信息（times and timers）</h3>
<p>核心需要记录进程的创建时间以及在其生命期消耗的 CPU 时间。适中每跳动一次，核心就要更新保存在 jiffies 变量中，记录进程在系统和用户模式下消耗的时间量。Linux 支持与进程相关的 interval 定时器，进程可以通过系统调用来设定定时器以便在定时器到时后向它发送信号。这些定时器可以是一次性的或者周期性的。</p>
<h3 id="有关文件系统的信息file-system">有关文件系统的信息（file system）</h3>
<p>进程可以自由地打开或关闭文件，进程的 task_struct 结构中包含一个指向每个打开文件描述符的指针以及指向两个 VFS inode 的指针。每个 VFS inode 唯一地标记文件中的一个目录或者文件，同时还对底层文件系统提供统一的接口。这两个指针，一个指向进程的根目录，另一个指向其当前或者 pwd 目录。pwd 从 UNIX 命令 pwd 中派生出来，用来显示当前工作目录。这两个 VFS inode 包含一个 count 域，当多个进程引用它们时，它的值将增加。这就是为什么不能删除进程当前目录或者其子目录的原因。</p>
<h3 id="虚拟内存信息virtual-memory">虚拟内存信息（virtual memory）</h3>
<p>多数进程都有一些虚拟内存（核心线程和后台进程没有），Linux 核心必须跟踪虚拟内存与系统物理内存的映射关系。</p>
<h3 id="进程上下文信息processor-specific-context">进程上下文信息（processor specific context）</h3>
<p>进程可以认为是系统当前状态的总和。进程运行时，它将使用处理器的寄存器以及堆栈等。进程被挂起时，进程的上下文中所有与 CPU 相关的状态必须保存在它的 task_struct 结构内。当调度器重新调度该进程时，所有上下文被重新设定。</p>
<h3 id="其它信息">其它信息</h3>
<p>Linux 支持 SMP 多 CPU 结构，在 task_struct 中有相应的描述信息。此外还包括资源使用、进程终止信号、描述可执行的文件格式的信息等。</p>
<h2 id="进程调度">进程调度</h2>
<p>Linux 能让多个进程并发执行，由此必然会产生资源争夺的情况，而 CPU 是系统中最重要的资源。进程调度就是进程调度程序按照一定的策略，动态地把 CPU 分配给处于就绪队列中的某一个进程，使之执行。进程调度的目的是使处理机资源得到最高效的利用。进程调度的策略要考虑“高效”、“公平”、“周转时间”、“吞吐量”、“响应时间”等原则，并且在一定的调度时机，通过合适的调度算法来完成进程的调度。</p>
<h3 id="进程调度的时机">进程调度的时机</h3>
<p>在 Linux 中采用的是 <strong>非剥夺调度</strong> 的机制，进程一旦运行就不能被停止，当前进程必须等待某个系统事件时，它才释放 CPU。例如进程可能需要写数据到某个文件。一般等待发生在系统调用的过程中，此时进程处于系统模式；处于等待状态的进程将被挂起而其他的进程被调度管理器选出来执行。系统为进程设置相应的时间片，当这个时间用完之后，再选择另一个进程来运行。Linux 调度时机有以下几种。</p>
<p>（1）时间片完</p>
<p>（2）进程状态转换</p>
<p>（3）执行设备驱动程序</p>
<p>（4）进程从中断、异常或系统调用返回到用户态</p>
<h3 id="进程调度的功能">进程调度的功能</h3>
<p>（1）允许进程建立自己的新备份</p>
<p>（2）决定哪一个进程将占用 CPU，使得可运行进程之间进行有效的转移</p>
<p>（3）接收中断并把它们发送到合适的内核子系统</p>
<p>（4）发送信号给用户进程</p>
<p>（5）管理定时器硬件</p>
<p>（6）当进程结束后，释放进程所占用的资源</p>
<p>（7）支持动态装入模块，这些模块代表着内核启动以后所增加的内核功能，这种可装入的模块将由虚拟文件系统和网络接口使用。</p>
<h3 id="进程调度的数据结构">进程调度的数据结构</h3>
<p>Linux 使用基于优先级的简单调度算法来选择下一个运行进程。当选定新进程后，系统必须将当前进程的状态、处理器中的寄存器以及上下文状态保存到 task_struct 结构中。同时它将重新设置新进程的状态并将系统控制权交给此进程。为了将 CPU 时间合理地分配给系统中每个可执行进程，调度管理器必须将这些时间信息也保存在 task_struct 中。</p>
<p>（1）调度策略（policy）</p>
<p>Linux 系统中存在普遍与实时两种进程。实时进程的优先级要高于其他进程。根据调度策略，Linux 将进程分为以下三种类型。</p>
<ul>
<li><code>SCHED_FIFO</code>：先进先出实时进程。只有当前进程执行完毕再调度下一优先级最高的进程。</li>
<li><code>SCHED_RR</code>：循环实时进程。在此策略下，每个进程执行完一个时间片后，会被挂起，然后选择另一具有相同或更高优先级的进程执行。</li>
<li><code>SCHED_OTHER</code>：普通进程。</li>
</ul>
<p>（2）优先级（priority）</p>
<p>调度管理器分配给进程的优先级，同时也是进程允许运行的时间（jiffies）。系统调度 renice 可以改变进程的优先级。</p>
<p>（3）实时进程的优先级（rt_priority）</p>
<p>Linux 支持实时进程，且它们的优先级要高于非实时进程。调度器使用这个域给每个实时进程一个相对优先级。同样可以通过系统调用来改变实时进程的优先级。</p>
<p>（4）当前执行进程剩余的时间（counter）</p>
<p>进程首次运行时为进程优先级的数值，它随时间变化递减。普通进程的 counter 值是其优先级权值，而实时进程的则是 counter 加上 1000。</p>
<p>（5）当前进程（current process）</p>
<p>当调度其他进程占用 CPU 时，根据调度策略对当前进程进行一些处理，修改其状态，并插入相应的队列。</p>
<h3 id="进程调度的依据">进程调度的依据</h3>
<p>调度程序运行时，要在所有处于可运行状态的进程中选择最值得运行的进程投入运行。上面所介绍的 policy、priority、counter 和 rt_priority 4 项是调度程序选择的依据。</p>
<p>Linux 操作系统用函数 <code>goodness()</code> 来衡量一个处于可运行状态的进程值得运行的程度。该函数综合了上面4项依据，给每个处于可运行状态的进程赋予一个权值（weight），调度程序以这个权值作为选择进程的唯一依据。函数流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7a1b73c66d76b7082c7a94d38d352405.png" alt="goodnees-flowchart" /></p>
<h3 id="进程队列的组织方式">进程队列的组织方式</h3>
<p>（1）可运行队列（runnable queue）</p>
<p>操作系统中所有处于可运行状态的进程链成一个队列，该队列就称作可运行队列。调度程序直接的操作对象就是可运行队列。</p>
<p>可运行队列容纳了系统中所有可运行进程，它是一个双向循环队列，其结构如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/985ddc670db155defe7e30b3bcd952d8.png" alt="process-runnable-queue" /></p>
<p>该队列通过 task_struct 结构中的两个指针 next_run 和 prev_run 来维持。队列的标志有两个：一个是空进程 idle_task 即 task[0]，另一个是队列的长度（即系统中处于可运行状态的进程数目，用全局整形变量 nr_running 表示）。</p>
<p>（2）pidhash 表及链表 pidhash</p>
<p>为了快速根据进程的 pid 找到该进程的 task_struct 结构，系统使用链式结构的 Hash 表对进程的 task_struct 结构进行管理，Hash 表的默认长度为 128。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> PIDHASH_SZ (NR_TASKS&gt;&gt;2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pidhash(x) (((x)&gt;&gt;8)^(x))&amp;(PIDHASH_SZ-1)</span></span><br></pre></td></tr></table></figure>
<p>新创建进程时，系统根据其 pid 值将其结构插入到 pidhash 表中，具有相同 hash 值的进程构成一个双向链表。</p>
<p>（3）空闲 task_struct 双向循环链表 tarray_freelist</p>
<p>Linux 操作系统将所有的空闲 task_struct 通过双向循环链表进行链接，方便对新创建的进程快速分配 task_struct 结构，以及对撤销的进程回收 task_struct 结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">tarray_freelist</span>;</span></span><br></pre></td></tr></table></figure>
<p>（4）等待队列</p>
<p>进程经常要等待某个系统资源。例如某个进程可能需要描述文件系统中某个目录的 VFS inode，但是此 inode 可能不在 buffer cache 中。此时这个进程必须等到该 inode 从包含次文件系统的物理介质中取出来才可以继续运行。Linux 核心使用一个非常简单的队列：等待队列。它包含一个指向进程 task_struct 结构的指针以及等待队列中下一个元素的指针。加入到等待队列中的进程既可以是可中断也可以是不可中断的。</p>
<h3 id="进程调度的工作流程">进程调度的工作流程</h3>
<p>进程调度的工作流程比较简单：遍历可运行队列，从中选择一个权值最大的进程；如果可运行队列中所有进程的时间片都用完了，则要给系统中所有进程的时间片重新赋值。Linux 操作系统中的调度程序比较简单，它可以分为如下 5 个部分。</p>
<ul>
<li>第一部分：看是否有中断在运行。当中断运行时，是不允许调度程序执行的。</li>
<li>第二部分：处理内核例程。</li>
<li>第三部分：对当前进程做相关处理，为选择下一个进程做好准备。</li>
<li>第四部分：选择下一个可运行进程，即进程调度。</li>
<li>第五部分：进程切换，使 current 指向选定的进程，并建立新进程的运行环境。</li>
</ul>
<h2 id="创建进程">创建进程</h2>
<p>Linux 启动后经过一系列的初始化操作，系统由 <code>init()</code> 函数创建系统的第一个进程 init，其标志符为 1。init 进程将完成系统的一些初始化设置任务（如打开系统控制台、安装根文件系统及启动系统的守护进程等），以及执行系统初始化程序，如 /etc/init，/bin/init 或者 /sbin/init。init 进程使用 /etc/inittab 作为脚本文件来创建系统中的新进程。这些新进程又创建各自的新进程。例如 getty 进程将在用户试图登录时创建一个 login 进程。系统中所有进程都是从 init 核心进程中派生出来。</p>
<p>新进程通过复制老进程或当前进程来创建。系统调用 fork 或 clone 可以创建新任务，复制发生在核心状态下的核心中。系统从物理内存中分配出来一个新的 task_struct 数据结构，同时还有一个或多个包含被复制进程堆栈（用户与核心）的物理页面。然后创建唯一的标记此新任务的进程标志符。新创建的 task_struct 将被放入 task 数组中，另外将被复制进程的 task_struct 中的内容页表拷入新的 task_struct 中。</p>
<p><strong>复制完成后，Linux 允许两个进程共享资源而不是复制各自的备份。这些资源包括文件、信号处理过程和虚拟内存。</strong> 进程对共享资源用各自的 count 来记数。在两个进程对资源的使用完毕之前，Linux 绝不会释放此资源。</p>
<h2 id="进程间通信机制">进程间通信机制</h2>
<p><a href="https://wylu.me/posts/9fb7f5b4">进程间通信机制</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Morris Traversal</title>
    <url>/posts/5e36b8b8/</url>
    <content><![CDATA[<p>通常，实现二叉树的前序（preorder）、中序（inorder）、后序（postorder）遍历的迭代版本都需要 O(n) 的空间复杂度，那么有没有可能使用 O(1) 空间进行迭代遍历呢？答案是肯定的。</p>
<p>本文将介绍 Morris Traversal 遍历二叉树的方法，该算法能够做到 O(1) 空间复杂度的迭代遍历，并在遍历完成后二叉树依然保持原始状态（遍历过程中可能被修改）。</p>
<span id="more"></span>
<h1 id="morris-traversal">Morris Traversal</h1>
<p>要使用 O(1) 空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的 p 指针），由于不能用栈作为辅助空间。为了解决这个问题，Morris 方法用到了线索二叉树（threaded binary tree）的概念。在 Morris 方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。</p>
<h1 id="树结点定义">树结点定义</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历">中序遍历</h1>
<ul>
<li>1.设当前结点为cur</li>
<li>2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</li>
<li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。
<ol type="a">
<li>如果pre.right为空，则将pre.right指向当前结点，然后当前结点更新 为当前结点的左孩子。</li>
<li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 输出当前结点，然后当前结点更新为当前结点的右孩子。</li>
</ol></li>
<li>4.重复步骤2、3，直到当前结点为空。</li>
</ul>
<p>下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/fdfa082fd0a7a7a07440aa457f74421e.jpg" alt="morris-inorder-traversal" /></p>
<p>参考实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisInorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 18:43:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisInorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Inorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，然后当前结点更新</span></span><br><span class="line"><span class="comment">     *      为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      输出当前结点，然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找出左子树的最右结点，也即找出当前结点的前驱</span></span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromPreAndIn(pre, in);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisInorderTraversal</span>().inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：O(n)</li>
</ul>
<p>寻找左子树最右结点（也即当前结点的前驱）的时间复杂度为 O(n)，n 个节点的二叉树中一共有 n-1 条边，整个过程中每条边最多只走 2 次，一次是为了定位到某个节点，另一次是为了寻找某个结点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点，所以复杂度为O(n)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8626f16d4c3cf499d5611e80f4f81da2.jpg" alt="search-predecessor" /></p>
<h1 id="前序遍历">前序遍历</h1>
<ul>
<li>1.设当前结点为cur</li>
<li>2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点</li>
<li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。
<ol type="a">
<li>如果pre.right为空，则将pre.right指向当前结点，输出当前结点， 然后当前结点更新为当前结点的左孩子。</li>
<li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 然后当前结点更新为当前结点的右孩子。</li>
</ol></li>
<li>4.重复步骤2、3，直到当前结点为空。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/faf43f911834341ec7d1cad8d5121fec.jpg" alt="morris-preorder-traversal" /></p>
<p>参考实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisPreorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 19:53:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisPreorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Preorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，输出当前结点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找出左子树的最右结点，也即找出当前结点的前驱</span></span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromPreAndIn(pre, in);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisPreorderTraversal</span>().preorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历">后序遍历</h1>
<ul>
<li>1.创建一个临时结点dump，令其左孩子是root，设当前结点为cur</li>
<li>2.如果当前结点的左孩子为空，则将其右孩子作为当前结点。</li>
<li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。
<ol type="a">
<li>如果pre.right为空，则将pre.right指向当前结点， 然后当前结点更新为当前结点的左孩子。</li>
<li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 倒序输出从当前节点的左孩子到pre这条路径上的所有节点， 然后当前结点更新为当前结点的右孩子。</li>
</ol></li>
<li>4.重复步骤2、3，直到当前结点为空。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e1f5307fd830868204e48aa7a18e0001.jpg" alt="morris-postorder-traversal" /></p>
<p>参考实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisPostorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 20:16:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisPostorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Postorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.创建一个临时结点dump，令其左孩子是root，设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      倒序输出从当前节点的左孩子到pre这条路径上的所有节点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.left = root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    printReverse(cur.left);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printReverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> reverse(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反转后的链表头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">reverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.right;</span><br><span class="line">            cur.right = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] post = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromInAndPost(in, post);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisPostorderTraversal</span>().postorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html">https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html</a></p>
<p><a href="https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading">https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
        <tag>morris-traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树练习</title>
    <url>/posts/cb350e7d/</url>
    <content><![CDATA[<p>一些经典的二叉树练习题，帮助理解掌握二叉树的各种遍历方法和递归地解决问题的思路。</p>
<span id="more"></span>
<h1 id="二叉树节点定义">二叉树节点定义</h1>
<ul>
<li>java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h1 id="利用中序和后序遍历序列重建二叉树">利用中序和后序遍历序列重建二叉树</h1>
<p>给定一棵树的中序和后序遍历结果，构造二叉树。</p>
<p>注意：您可以假定树中不存在重复项。</p>
<p>例如，给定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure>
<p>返回以下二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="literal">null</span> || postorder == <span class="literal">null</span> || inorder.length != postorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(inorder.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> si, <span class="type">int</span>[] post, <span class="type">int</span> sp, <span class="type">int</span> ep, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp &gt; ep) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(post[ep]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> idx - si;</span><br><span class="line">        root.left = build(si, post, sp, sp + leftLen - <span class="number">1</span>, map);</span><br><span class="line">        root.right = build(idx + <span class="number">1</span>, post, sp + leftLen, ep - <span class="number">1</span>, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder <span class="keyword">or</span> <span class="built_in">len</span>(inorder) != <span class="built_in">len</span>(postorder):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        indices = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        <span class="keyword">return</span> self.build(<span class="number">0</span>, postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, si: <span class="built_in">int</span>, post: <span class="type">List</span>[<span class="built_in">int</span>], sp: <span class="built_in">int</span>, ep: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">              indices: <span class="built_in">dict</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> sp &gt; ep:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(post[ep])</span><br><span class="line">        idx = indices[root.val]</span><br><span class="line">        llen = idx - si</span><br><span class="line"></span><br><span class="line">        root.left = self.build(si, post, sp, sp + llen - <span class="number">1</span>, indices)</span><br><span class="line">        root.right = self.build(idx + <span class="number">1</span>, post, sp + llen, ep - <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="利用前序和中序遍历序列重建二叉树">利用前序和中序遍历序列重建二叉树</h1>
<p>给定一棵树的前序和中序遍历结果，构造二叉树。</p>
<p>注意：您可以假定树中不存在重复项。</p>
<p>例如，给定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回以下二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || inorder == <span class="literal">null</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(inorder.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> si, <span class="type">int</span>[] pre, <span class="type">int</span> sp, <span class="type">int</span> ep,</span></span><br><span class="line"><span class="params">                           HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp &gt; ep) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[sp]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> idx - si;</span><br><span class="line">        root.left = build(si, pre, sp + <span class="number">1</span>, sp + leftLen, map);</span><br><span class="line">        root.right = build(idx + <span class="number">1</span>, pre, sp + leftLen + <span class="number">1</span>, ep, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="built_in">len</span>(preorder) != <span class="built_in">len</span>(inorder):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        indices = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        <span class="keyword">return</span> self.build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, pre: <span class="type">List</span>[<span class="built_in">int</span>], sp: <span class="built_in">int</span>, ep: <span class="built_in">int</span>, si: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">              indices: <span class="built_in">dict</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> sp &gt; ep:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(pre[sp])</span><br><span class="line">        idx = indices[root.val]</span><br><span class="line">        llen = idx - si</span><br><span class="line"></span><br><span class="line">        root.left = self.build(pre, sp + <span class="number">1</span>, sp + llen, si, indices)</span><br><span class="line">        root.right = self.build(pre, sp + llen + <span class="number">1</span>, ep, idx + <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h1>
<p>您会得到一棵完美的二叉树，其中所有叶子都在同一水平上，每个父级都有两个孩子。二叉树定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充每个 next 指针以指向其下一个右节点。如果没有下一个右节点，则 next 指针应设置为 NULL。</p>
<p>最初，所有 next 指针都设置为 NULL。</p>
<p>Follow up:</p>
<ul>
<li>您只能使用常量的额外空间。</li>
<li>递归方法很好，您可以假定隐式堆栈空间不算作此问题的额外空间。</li>
</ul>
<p>Example 1:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d4af01ea9ac3ca3193f50caa8b6a7b8b.png" alt="116-sample" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: 给定上面完美的二叉树（图A），您的函数应该填充每个下一个指针，</span><br><span class="line">以指向其下一个右节点，如图B所示。序列化的输出按层次顺序排列，与下一个指针相连，</span><br><span class="line">并带有 &#x27;＃&#x27; 表示每个层次的结束。</span><br></pre></td></tr></table></figure>
<p>限制条件：</p>
<ul>
<li>给定树中的节点数少于4096。</li>
<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * class Node &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public Node left;</span></span><br><span class="line"><span class="comment"> *     public Node right;</span></span><br><span class="line"><span class="comment"> *     public Node next;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment"> *         val = _val;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node(int _val, Node _left, Node _right, Node  * _next) &#123;</span></span><br><span class="line"><span class="comment"> *         val = _val;</span></span><br><span class="line"><span class="comment"> *         left = _left;</span></span><br><span class="line"><span class="comment"> *         right = _right;</span></span><br><span class="line"><span class="comment"> *         next = _next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">levelStart</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (levelStart != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> levelStart;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.left.next = cur.right;</span><br><span class="line">                    <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cur.right.next = cur.next.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            levelStart = levelStart.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="comment"># class Node:</span></span><br><span class="line"><span class="comment">#     def __init__(self,</span></span><br><span class="line"><span class="comment">#                  val: int = 0,</span></span><br><span class="line"><span class="comment">#                  left: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  right: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            head = cur.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.<span class="built_in">next</span> = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                    cur.right.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.left</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="填充每个节点的下一个右侧节点指针ii">填充每个节点的下一个右侧节点指针II</h1>
<p>给定一棵二叉树：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充每个 next 指针以指向其下一个右节点。如果没有下一个右节点，则 next 指针应设置为 NULL。</p>
<p>最初，所有 next 指针都设置为 NULL。</p>
<p>Follow up:</p>
<ul>
<li>您只能使用常量的额外空间。</li>
<li>递归方法很好，您可以假定隐式堆栈空间不算作此问题的额外空间。</li>
</ul>
<p>Example 1:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/099321a3abf9e1118186bb2b101338c9.png" alt="117-sample" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: 给定上面的二叉树（图A），您的函数应该填充每个下一个指针，</span><br><span class="line">以指向其下一个右节点，如图B所示。序列化的输出按层次顺序排列，与下一个指针相连，</span><br><span class="line">并用 &#x27;＃&#x27; 表示 每个层次的结尾。</span><br></pre></td></tr></table></figure>
<p>限制条件：</p>
<ul>
<li>给定树中的节点数少于6000。</li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nextHeadDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nextLevelCur</span> <span class="operator">=</span> nextHeadDummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextLevelCur.next = cur.left;</span><br><span class="line">                    nextLevelCur = nextLevelCur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextLevelCur.next = cur.right;</span><br><span class="line">                    nextLevelCur = nextLevelCur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nextHeadDummy.next;</span><br><span class="line">            nextHeadDummy.next = <span class="literal">null</span>;</span><br><span class="line">            nextLevelCur = nextHeadDummy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="comment"># class Node:</span></span><br><span class="line"><span class="comment">#     def __init__(self,</span></span><br><span class="line"><span class="comment">#                  val: int = 0,</span></span><br><span class="line"><span class="comment">#                  left: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  right: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            head, pre = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    <span class="keyword">if</span> pre:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur.left</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        head = cur.left</span><br><span class="line">                    pre = cur.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    <span class="keyword">if</span> pre:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur.right</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        head = cur.right</span><br><span class="line">                    pre = cur.right</span><br><span class="line"></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最低共同祖先">二叉树的最低共同祖先</h1>
<p>给定二叉树，在树中找到两个给定节点的最低公共祖先（LCA）。</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia上LCA的定义</a>：“最低的共同祖先被定义为两个节点p和q之间的关系，这是T中同时具有p和q作为后代的最低节点（我们允许一个节点成为其自身的后代）。 ”</p>
<p>给定以下二叉树：<code>root = [3,5,1,6,2,0,8,null,null,7,4]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f2660bc712bf0a802e26ae97e1677ed6.png" alt="binarytree" /></p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be</span><br><span class="line">a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p和q不同，并且两个值都将存在于二叉树中。</li>
</ul>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的序列化与反序列化">二叉树的序列化与反序列化</h1>
<p>序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接进行传输，以便稍后在相同或另一个计算机环境中进行重构。</p>
<p>设计一种用于对二叉树进行序列化和反序列化的算法。序列化/反序列化算法的工作方式没有任何限制。您只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<p>说明：上面的格式与 LeetCode 序列化二叉树的方式相同。您不一定需要遵循这种格式，因此请发挥创造力并自己提出不同的方法。</p>
<p>注意：不要使用类成员/全局/静态变量来存储状态。您的序列化和反序列化算法应该是无状态的。</p>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELIMITER</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PADDING</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(PADDING).append(DELIMITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(DELIMITER);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(data.split(DELIMITER)));</span><br><span class="line">        <span class="keyword">return</span> deserialize(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (PADDING.equals(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(val));</span><br><span class="line">        root.left = deserialize(queue);</span><br><span class="line">        root.right = deserialize(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): the root of tree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: a serial str of binary tree</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        self._serial(root, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_serial</span>(<span class="params">self, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        self._serial(root.left, res)</span><br><span class="line">        self._serial(root.right, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            data (str): a serial str of binary tree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            TreeNode: the root of tree</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        data.reverse()</span><br><span class="line">        <span class="keyword">return</span> self._deserial(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deserial</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        val = data.pop()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">        root.left = self._deserial(data)</span><br><span class="line">        root.right = self._deserial(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/942/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/942/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/943/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/943/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/932/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/932/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>binary-tree</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>递归地解决树问题</title>
    <url>/posts/657c0b00/</url>
    <content><![CDATA[<p>在前面的部分中，我们介绍了如何递归解决<a href="https://wylu.me/posts/e85d694a">树遍历</a>问题。<strong>递归</strong>是解决树问题的最强大，最常用的技术之一。</p>
<p>众所周知，树可以递归定义为一个节点（根节点），该节点包含一个值和对子节点的引用列表。递归是树的自然特征之一。因此，许多树问题可以递归解决。对于每个递归函数调用，我们仅关注当前节点的问题，然后递归调用函数以解决其子级。</p>
<p>通常，我们可以使用 <strong>自上而下</strong> 的方法或 <strong>自下而上</strong> 的方法递归地解决树问题。</p>
<span id="more"></span>
<h1 id="自上而下的解决方案">自上而下的解决方案</h1>
<p>“自顶向下”表示在每个递归调用中，我们将首先访问该节点以提供一些值，并在递归调用该函数时将这些值传递给其子级。因此，“自上而下”的解决方案可以看作是一种前序遍历（preorder traversal）。具体来说，递归函数 <code>top_down(root, params)</code> 的工作方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. return specific value for null node</span><br><span class="line">2. update the answer if needed                      // answer &lt;-- params</span><br><span class="line">3. left_ans = top_down(root.left, left_params)      // left_params &lt;-- root.val, params</span><br><span class="line">4. right_ans = top_down(root.right, right_params)   // right_params &lt;-- root.val, params</span><br><span class="line">5. return the answer if needed                      // answer &lt;-- left_ans, right_ans</span><br></pre></td></tr></table></figure>
<p>例如，考虑以下问题：给定一棵二叉树，找到其最大深度。</p>
<p>我们知道根节点的深度为1。对于每个节点，如果我们知道其深度，我们将知道其子节点的深度。因此，如果在递归调用函数时将节点的深度作为参数传递，则所有节点都将知道其深度。对于叶节点，我们可以使用深度来更新最终答案。这是递归函数 <code>maximum_depth(root, depth)</code> 的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. return if root is null</span><br><span class="line">2. if root is a leaf node:</span><br><span class="line">3.      answer = max(answer, depth)         // update the answer if needed</span><br><span class="line">4. maximum_depth(root.left, depth + 1)      // call the function recursively for left child</span><br><span class="line">5. maximum_depth(root.right, depth + 1)     // call the function recursively for right child</span><br></pre></td></tr></table></figure>
<p>以下示例可帮助您了解其工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/abb8f5a44b799f9a77f817c9ddeffcf7.gif" alt="top-down-solution" /></p>
<p>Java 参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> answer;  <span class="comment">// don&#x27;t forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自下而上的解决方案">自下而上的解决方案</h1>
<p>“自底而上”是另一种递归解决方案。在每个递归调用中，我们将首先对所有子节点递归调用该函数，然后根据返回的值和当前节点本身的值得出答案。此过程可以视为一种后序遍历（postorder traversal）。通常，“自下而上”的递归函数 <code>bottom_up(root)</code> 将是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. return specific value for null node</span><br><span class="line">2. left_ans = bottom_up(root.left)          // call function recursively for left child</span><br><span class="line">3. right_ans = bottom_up(root.right)        // call function recursively for right child</span><br><span class="line">4. return answers                           // answer &lt;-- left_ans, right_ans, root.val</span><br></pre></td></tr></table></figure>
<p>让我们继续讨论有关最大深度的问题，但使用另一种思考方式：对于树的单个节点，以自身为根的子树的最大深度 <code>x</code> 将是多少？</p>
<p>如果我们知道以其左孩子为根的子树的最大深度 <code>l</code> 和以其右孩子为根的子树的最大深度 <code>r</code>，我们可以回答前面的问题吗？当然可以，我们可以选择它们之间的最大值，然后加1以获取根于当前节点的子树的最大深度。即 <code>x = max(l, r) + 1</code>。</p>
<p>这意味着对于每个节点，我们都可以在为其子节点解决问题后得到答案。因此，我们可以使用“自下而上”的解决方案来解决此问题。这是递归函数 <code>maximum_depth(root)</code> 的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. return 0 if root is null                 // return 0 for null node</span><br><span class="line">2. left_depth = maximum_depth(root.left)</span><br><span class="line">3. right_depth = maximum_depth(root.right)</span><br><span class="line">4. return max(left_depth, right_depth) + 1  // return depth of the subtree rooted at root</span><br></pre></td></tr></table></figure>
<p>以下示例可帮助您了解其工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d6ab88624ed4fe88ff2021306861e38a.gif" alt="bottom-up-solution" /></p>
<p>Java 参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// return 0 for null node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left_depth</span> <span class="operator">=</span> maximum_depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right_depth</span> <span class="operator">=</span> maximum_depth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;  <span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>理解递归并找到该问题的递归解决方案并不容易。它需要练习。</p>
<p>遇到树型问题时，请问自己两个问题：是否可以确定一些参数来帮助节点知道其答案？您可以使用这些参数和节点本身的值来确定将什么参数传递给它的子节点吗？如果答案都是肯定的，请尝试使用“自顶向下”递归解决方案来解决此问题。</p>
<p>或者，您可以通过这种方式思考问题：对于树中的某个节点，如果您知道其子节点的答案，可以计算该节点的答案吗？如果答案是肯定的，那么使用自下而上的方法递归解决问题可能是一个好主意。</p>
<p>在下面，我们为您提供了几个经典问题，以帮助您更好地理解树的结构和递归。</p>
<h1 id="二叉树节点定义">二叉树节点定义</h1>
<ul>
<li>java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h1 id="二叉树递归练习">二叉树递归练习</h1>
<h2 id="二叉树的最大深度">二叉树的最大深度</h2>
<p>给定二叉树，找到其最大深度。</p>
<p>最大深度是沿着从根节点到最远叶节点的最长路径的节点数。</p>
<p>注意：叶是没有子节点的节点。</p>
<p>例：给定二叉树[3,9,20,null,null,15,7]，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其深度 = 3</p>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树">对称二叉树</h2>
<p>给定一棵二叉树，检查它是否是其自身的镜像（即，围绕其中心对称）。</p>
<p>例如，此二叉树[1,2,2,3,4,4,3]是对称的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但[1,2,2,null,3,null,3]不是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>递归和迭代地解决它。</p>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归地判断左右子树是否对称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r1 左子树根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r2 右子树根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recursive</span><span class="params">(TreeNode r1, TreeNode r2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (r1.val == r2.val) &amp;&amp; recursive(r1.left, r2.right) &amp;&amp; recursive(r1.right, r2.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代地判断树是否对称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">iterate</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span> || r1.val != r2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(r1.left);</span><br><span class="line">            queue.offer(r2.right);</span><br><span class="line">            queue.offer(r1.right);</span><br><span class="line">            queue.offer(r2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="comment">//        if (root == null) return true;</span></span><br><span class="line"><span class="comment">//        return recursive(root.left, root.right);</span></span><br><span class="line">        <span class="keyword">return</span> iterate(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.isSym(root, root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSym</span>(<span class="params">self, r1: TreeNode, r2: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">and</span> <span class="keyword">not</span> r2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">or</span> <span class="keyword">not</span> r2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r1.val == r2.val <span class="keyword">and</span> self.isSym(r1.left, r2.right)</span><br><span class="line">                <span class="keyword">and</span> self.isSym(r1.right, r2.left))</span><br></pre></td></tr></table></figure>
<h2 id="路径总和">路径总和</h2>
<p>给定一个二叉树和一个和，确定该树是否具有从根到叶的路径，以使该路径上的所有值加起来等于给定的和。</p>
<p>注意：叶是没有子节点的节点。</p>
<p>例：给定下面的二叉树，并且 <code>sum = 22</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>
<p>返回true，因为存在从根到叶的路径 <code>5-&gt;4-&gt;11-&gt;2</code>，其总和为22。</p>
<p><strong>java 参考代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        cur += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> sum == cur;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) flag = hasPathSum(root.left, sum, cur);</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; root.right != <span class="literal">null</span>) flag = hasPathSum(root.right, sum, cur);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>python 参考代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (self.hasPathSum(root.left, <span class="built_in">sum</span> - root.val)</span><br><span class="line">                <span class="keyword">or</span> self.hasPathSum(root.right, <span class="built_in">sum</span> - root.val))</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/535/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/535/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>binary-tree</tag>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/e85d694a/</url>
    <content><![CDATA[<p>了解树和二叉树的相关概念；</p>
<p>理解不同遍历方法的工作原理，掌握相应遍历方法的递归和迭代实现；</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
<span id="more"></span>
<h1 id="树和二叉树的概念">树和二叉树的概念</h1>
<p>树是模拟分层树结构的常用数据结构。</p>
<p>树的每个节点将具有一个根值和包含其它被称为子节点的引用列表。从图的角度来看，树也可以定义为具有 N 个节点和 N-1 个边的有向无环图。</p>
<p>二叉树是最典型的树结构之一。顾名思义，二叉树是一种树数据结构，其中每个节点最多具有两个孩子节点，分别称为左孩子和右孩子。</p>
<h1 id="二叉树节点定义">二叉树节点定义</h1>
<ul>
<li>java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h1 id="树的遍历">树的遍历</h1>
<p>本文的目的：</p>
<p>了解不同的树遍历方法之间的区别；</p>
<p>能够递归地解决前序，中序和后序遍历；</p>
<p>能够迭代解决前序，中序和后序遍历；</p>
<p>能够使用 BFS 进行分层遍历。</p>
<h2 id="前序遍历preorder-traversal">前序遍历(Preorder Traversal)</h2>
<p>前序遍历是首先访问根，然后遍历左子树，最后遍历右子树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/16a9e6b5c0d5b637a092b5a0879bef18.gif" alt="preorder-traversal" /></p>
<h3 id="例题">例题</h3>
<p>给定一个二叉树，返回其节点值的前序遍历序列。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<h4 id="java">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 访问当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3>
<h4 id="java-1">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.将根结点压入栈</span></span><br><span class="line"><span class="comment">     * 2.弹出栈顶结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="comment">     * 3.然后先将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 4.再将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 先将右子树压入栈，以确保先遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="comment">// 将左子树压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python-1">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行前序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.将根结点压入栈</span></span><br><span class="line"><span class="string">        2.弹出栈顶结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="string">        3.然后先将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        4.再将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 前序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历inorder-traversal">中序遍历(Inorder Traversal)</h2>
<p>中序遍历是首先遍历左子树，然后访问根，最后遍历右子树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/861bb0ee8680a74d6e40c5d876271f54.gif" alt="inorder-traversal" /></p>
<p>通常，对于二叉搜索树，我们可以使用中序遍历以排序的顺序检索所有数据。</p>
<h3 id="例题-1">例题</h3>
<p>给定一个二叉树，返回其节点值的中序遍历序列。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>
<h3 id="递归-1">递归</h3>
<h4 id="java-2">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python-2">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 访问当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br></pre></td></tr></table></figure>
<h3 id="迭代-1">迭代</h3>
<h4 id="java-3">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.当前结点置为根结点</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点不为空，则将最左路径的所有结点压入栈中</span></span><br><span class="line"><span class="comment">     * 3.弹出栈顶结点作为当前结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="comment">     * 4.然后将当前结点置为当前结点的右子结点</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至当前结点为空且栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借助栈实现迭代中序遍历二叉树</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 确保先遍历未曾访问过的最左节点</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python-3">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行中序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.当前结点置为根结点</span></span><br><span class="line"><span class="string">        2.如果当前结点不为空，则将最左路径的所有结点压入栈中</span></span><br><span class="line"><span class="string">        3.弹出栈顶结点作为当前结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="string">        4.然后将当前结点置为当前结点的右子结点</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至当前结点为空且栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 中序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line"></span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历postorder-traversal">后序遍历(Postorder Traversal)</h2>
<p>后序遍历是首先遍历左子树，然后遍历右子树，最后访问根。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a8f9ea34c137c0a579b69395328ba954.gif" alt="postorder-traversal" /></p>
<p>值得注意的是，当删除树中的节点时，删除过程应处于后序遍历状态。也就是说，删除节点时，先删除左节点，再删除右节点，然后再删除节点本身。</p>
<p>而且，后序在数学表达式中被广泛使用，编写程序来解析后序表达式会更容易。这是一个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4170d2a0e6bf349c5153f322f7bd050d.png" alt="mathematical-expression" /></p>
<p>你可以使用中序遍历轻松找出原始表达式，但是，程序要处理该表达式（中序表达式）并不容易，因为你必须检查操作的优先级。</p>
<p>如果按后序处理此树，则可以使用栈轻松处理表达式，每次遇到操作符时，只需从栈中弹出 2 个元素，计算结果并将结果推回栈中即可。</p>
<h3 id="例题-2">例题</h3>
<p>给定一个二叉树，返回其节点值的后序遍历序列。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>
<h3 id="递归-2">递归</h3>
<h4 id="java-4">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python-4">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br><span class="line">        <span class="comment"># 遍历当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br></pre></td></tr></table></figure>
<h3 id="迭代-2">迭代</h3>
<h4 id="java-5">Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.将根结点压入栈</span></span><br><span class="line"><span class="comment">     * 2.弹出栈顶结点，将结点值插入结果序列的头部</span></span><br><span class="line"><span class="comment">     * 3.然后先将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 4.再将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.addFirst(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python-5">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行后序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.将根结点压入栈</span></span><br><span class="line"><span class="string">        2.弹出栈顶结点，将结点值插入结果序列的头部</span></span><br><span class="line"><span class="string">        3.然后先将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        4.再将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 后序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line"></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历level-order-traversal">层次遍历(Level Order Traversal)</h2>
<p>层次遍历是逐级遍历树，每一层从左往右依次遍历结点。</p>
<p>广度优先搜索（Breadth-First Search）是一种遍历或搜索数据结构（如树或图）的算法。该算法从根节点开始，并首先访问该节点本身。然后遍历其邻居，遍历其第二级邻居，遍历其第三级邻居，依此类推。</p>
<p>当我们在树中进行广度优先搜索（BFS）时，我们访问的节点的顺序是层次遍历的顺序。</p>
<p>这是一个层次遍历的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/edf8dd3d276a32d86f8fff4428eebe6f.gif" alt="level-order-traversal" /></p>
<p>通常，我们使用队列来帮助我们进行BFS。</p>
<h3 id="例题-3">例题</h3>
<p>给定一个二叉树，返回其节点值的层次遍历序列。（即，从左到右，逐级）。</p>
<p><strong>Example:</strong></p>
<p>给定一棵二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="java-6">Java</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用两个指针，curTail指向当前层的最右结点，nextTail指向下一层的最右结点；</span></span><br><span class="line"><span class="comment">     *   创建辅助队列，将根结点压入队列中</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左子结点不为空，则左子结点入队列，并更新nextTail</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的右子结点不为空，则右子结点入队列，并更新nextTail</span></span><br><span class="line"><span class="comment">     * 4.如果当前结点已是当前层的最右结点，则将curTail更新为nextTail</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至队列空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 层次遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curTail</span> <span class="operator">=</span> root, nextTail = <span class="literal">null</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">                nextTail = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">                nextTail = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur == curTail) &#123;</span><br><span class="line">                res.add(level);</span><br><span class="line">                level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                curTail = nextTail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python-6">python</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        que = deque()</span><br><span class="line">        que.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            level, size = [], <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                root = que.popleft()</span><br><span class="line">                level.append(root.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    que.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    que.append(root.right)</span><br><span class="line"></span><br><span class="line">            ans.append(level)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/">https://leetcode.com/explore/learn/card/data-structure-tree/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/928/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/928/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/929/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/929/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/930/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/930/</a></p>
<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/931/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/931/</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>前序遍历</tag>
        <tag>中序遍历</tag>
        <tag>后序遍历</tag>
        <tag>层次遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>C函数指针的理解与使用</title>
    <url>/posts/184fc68/</url>
    <content><![CDATA[<p>通过一些具体例子，来深入理解并掌握函数指针的运用。</p>
<span id="more"></span>
<h1 id="c语言函数指针的理解与使用">C语言函数指针的理解与使用</h1>
<h2 id="函数指针的定义">函数指针的定义</h2>
<p>函数指针就是函数的指针。它是一个指针，指向一个函数。看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A) <span class="type">char</span>* (*fun1)(<span class="type">char</span>* p1, <span class="type">char</span>* p2);</span><br><span class="line">B) <span class="function"><span class="type">char</span>** <span class="title">fun2</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>;</span><br><span class="line">C) <span class="function"><span class="type">char</span>* <span class="title">fun3</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面三个表达式分别什么意思？</p>
<ul>
<li><ol start="3" type="A">
<li>这很容易，fun3是函数名，p1，p2是参数，其类型为 <code>char*</code> 型，函数的返回值为 <code>char*</code> 类型。</li>
</ol></li>
<li><ol start="2" type="A">
<li>也很简单，与C）表达式相比，唯一不同的就是函数的返回值类型为 <code>char**</code>，是个二级指针。</li>
</ol></li>
<li><ol type="A">
<li>fun1是函数名吗？回忆一下数组指针的定义：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*)[<span class="number">10</span>] p;</span><br></pre></td></tr></table></figure>
<p>这里 fun1 不是什么函数名，而是一个指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。同样，我们把这个表达式改写一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* (*)(<span class="type">char</span>* p1, <span class="type">char</span>* p2) fun1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数指针使用的例子">函数指针使用的例子</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>&#123;</span><br><span class="line">　　<span class="type">int</span> i = <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">　　<span class="keyword">if</span> (<span class="number">0</span> == i) <span class="keyword">return</span> p1;</span><br><span class="line">　　<span class="keyword">else</span> <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="type">char</span>* (*pf)(<span class="type">char</span>* p1, <span class="type">char</span>* p2); <span class="comment">//声明一个指向改函数的指针,未初始化</span></span><br><span class="line">　　pf = &amp;fun;</span><br><span class="line">　　(*pf) (<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>赋值方法 给函数指针赋值时，可以用 <code>&amp;fun</code> 或直接用函数名 fun。这是因为函数名被编译之后其实就是一个地址，所以这里两种用法没有本质的差别。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pf = fun;</span><br><span class="line">pf = &amp;fun;</span><br></pre></td></tr></table></figure></li>
<li><p>调用方法 可以直接使用指向函数的指针调用函数，无须提前解引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个等价调用</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">(*pf) (<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="built_in">fun</span>(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="intp-是什么"><code>*(int*)&amp;p</code> 是什么</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call Function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*p)();</span><br><span class="line">    *(<span class="type">int</span>*)&amp;p = (<span class="type">int</span>)function;</span><br><span class="line">    (*p)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*(int*)&amp;p = (int)function;</code> 表示什么意思？先看这行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*p)();</span><br></pre></td></tr></table></figure>
<ul>
<li>这行代码定义了一个指针变量 p，p 指向一个函数，这个函数的参数和返回值都是 <code>void</code>。</li>
<li><code>&amp;p</code> 是求指针变量 p 本身的地址，这是一个32位的二进制常数（32位系统）。</li>
<li><code>(int*)&amp;p</code> 表示将地址强制转换成指向 int 类型数据的指针。</li>
<li><code>(int)function</code> 表示将函数的入口地址强制转换成 int 类型的数据。</li>
<li><code>*(int*)&amp;p = (int)function;</code> 表示将函数的入口地址赋值给指针变量 p。</li>
<li>那么 <code>(*p) ();</code> 就是表示对函数的调用。</li>
</ul>
<p>64位系统：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call Function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*p)();</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)&amp;p = (<span class="type">long</span> <span class="type">long</span>)function;</span><br><span class="line">    (*p)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-0-是什么"><code>(*(void(*) ())0) ()</code> 是什么</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*(<span class="built_in">void</span>(*) ())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure>
<p>这是《C Traps and Pitfalls》书中的一个例子：</p>
<ul>
<li>第一步：<code>void(*) ()</code>，可以明白这是一个函数指针类型。这个函数没有参数，没有返回值。</li>
<li>第二步：<code>(void(*) ())0</code>，这是将0强制转换为函数指针类型，0是一个地址，也就是说一个函数存在首地址为0的一段区域内。</li>
<li>第三步：<code>(*(void(*) ())0)</code>，这是取0地址开始的一段内存里面的内容，其内容就是保存在首地址为0的一段区域内的函数。</li>
<li>第四步：<code>(*(void(*) ())0) ()</code>，这是函数调用。</li>
</ul>
<p>上面的例子再改写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*(<span class="type">char</span>**(*) (<span class="type">char</span>**, <span class="type">char</span>**))<span class="number">0</span>) (<span class="type">char</span>**, <span class="type">char</span>**);</span><br></pre></td></tr></table></figure>
<h2 id="使用函数指针的好处">使用函数指针的好处</h2>
<p>可以将实现同一功能的多个模块统一起来标识，这样一来更容易后期的维护，系统结构更加清晰。</p>
<p>归纳为：便于分层设计、利于系统抽象、降低耦合度以及使接口与实现分开。</p>
<h2 id="references">References</h2>
<p><a href="http://www.cnblogs.com/haore147/p/3647262.html">http://www.cnblogs.com/haore147/p/3647262.html</a></p>
<p><a href="https://www.cnblogs.com/huangzhenxiong/p/7772627.html">https://www.cnblogs.com/huangzhenxiong/p/7772627.html</a></p>
]]></content>
      <categories>
        <category>programming-language</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title>应用密码学总结</title>
    <url>/posts/8ad7d8df/</url>
    <content><![CDATA[<p>应用密码学学习总结，涉及密码学基本概念、古典密码、PGP安全电子邮件解决方案、对称加密、非对称加密、ElGamal密码体制、Diffie-Hellman密钥交换、数字签名等。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<h2 id="信息安全的三个基本的目标">信息安全的三个基本的目标</h2>
<ul>
<li>保密性 Confidentiality 消息能够被安全的传送，即窃听者不能阅读发送的消息。</li>
<li>完整性 Integrity 消息的接收者应该能够验证在传递的过程中消息没有被修改；入侵者不能用假消息代替合法的消息。</li>
<li>可用性 Availability 即保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况。</li>
</ul>
<h2 id="数据的安全基于密钥的保密而不是算法的保密">数据的安全基于密钥的保密，而不是算法的保密</h2>
<h2 id="公钥密码使得无密钥传输的保密通信成为可能">公钥密码使得无密钥传输的保密通信成为可能</h2>
<h2 id="密码学的基本概念">密码学的基本概念</h2>
<p>密码学(Cryptology)：研究信息系统安全技术的科学。它包含两个分支：</p>
<ul>
<li>密码编码学(Cryptography)，对信息进行编码实现隐蔽信息的一门学问</li>
<li>密码分析学(Cryptanalysis)，研究分析破译密码或伪造的学问。 两者相互对立，而又互相促进地向前发展。</li>
</ul>
<h2 id="密码算法分类-i">密码算法分类-I</h2>
<p>按照保密性依赖的基础分为:</p>
<ul>
<li>受限制的（Restricted)算法: 算法的保密性基于保持算法的秘密。</li>
<li>基于密钥（Key-based)的算法: 算法的保密性基于对密钥的保密。</li>
</ul>
<h2 id="密码算法分类-ii">密码算法分类-II</h2>
<p>按照密钥的特点分为：</p>
<ul>
<li>对称密码算法（Symmetric Cipher)：就是加密密钥和解密密钥相同，或实质上等同，即从一个易于推出另一个。又称秘密密钥算法或单密钥算法。 对称密钥密码又可分为流密码和分组密码
<ul>
<li>分组密码每次对一块数据(Block)加密例子：DES, IDEA, RC6, Rijndael</li>
<li>流密码每次对一位或一字节加密例子：One-time padding, Vigenére, Vernam</li>
</ul></li>
<li>非对称密钥算法（Asymmetric Cipher)：加密密钥和解密密钥不相同，从一个很难推出另一个。又称公钥密钥算法（Public-key Cipher) 。</li>
</ul>
<h1 id="数论基础">数论基础</h1>
<h2 id="互素">互素</h2>
<p>如果a,b的最大公约数为1，则称a,b互素。(注. (a,b)表示a,b的最大公约数) (3,5)=1 a,b互素，a,b不一定是素数，例如(9,4)=1</p>
<h2 id="模运算">模运算</h2>
<h3 id="模加法">模加法</h3>
<p>(a + b) mod m = ((a mod m) + (b mod m)) mod m 例: (11 + 15) mod 8 = ((11 mod 8) + (15 mod 8)) mod 8 = (3 + 7) mod 8 = 10 mod 8 = 2</p>
<h3 id="模减法">模减法</h3>
<p>(a - b) mod m = ((a mod m) - (b mod m)) mod m 例: (15 - 1) mod 7 = ((15 mod 7) - (1 mod 7)) mod 7 = (1 - 1) mod 7 = 0 mod 7 = 0</p>
<h3 id="模乘法">模乘法</h3>
<p>(a × b) mod m = ((a mod m) × (b mod m)) mod m 例: (7 × 9) mod 8 = ((7 mod 8) × (9 mod 8)) mod 8 = (7 × 1) mod 8 = 7 mod 8 = 7</p>
<h2 id="逆元">逆元</h2>
<h3 id="加法逆元">加法逆元</h3>
<p>x的加法逆元y是满足x + y ≡ 0 mod m的数 例: 2 + 6 ≡ 0 mod 8, 6和2互为模8的加法逆元</p>
<h3 id="乘法逆元">乘法逆元</h3>
<p>x的乘法逆元y是满足x × y ≡ 1 mod m 数。 例：2 × 4 ≡ 1 mod 7，2和4互为模7的乘法逆元</p>
<h3 id="如果m是一个素数则对每一个0xm-都存在乘法逆元">如果m是一个素数，则对每一个0&lt;x&lt;m, 都存在乘法逆元</h3>
<p>例： 1 × 1 ≡1 mod 7 2 × 4 ≡1 mod 7 3 × 5 ≡1 mod 7 4 × 2 ≡1 mod 7 5 × 3 ≡1 mod 7 6 × 6 ≡1 mod 7 ​ …</p>
<h3 id="一个定理">一个定理</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设a, b, c是任意三个不全为零的整数,且</span><br><span class="line">                     a= bq + r                      (1)</span><br><span class="line">其中q是整数, 则(a, b)=(b, r).</span><br><span class="line">对(1)进一步地约束，令b&gt;0,将a除以b所得的商记为q, 余数为r , 则(1)成为</span><br><span class="line">                     a= bq + r, 0&lt;=r&lt;b              (2)</span><br><span class="line">r是a对模b的非负最小剩余。</span><br><span class="line">进一步 (a, b)=(|a|, |b|)=(b, a)</span><br><span class="line">由此我们得到求(a, b)的Euclid辗转相除法</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3f15c8e84962d30760085229d67a8a60.png" alt="Euclid" /></p>
<h3 id="解一次同余式">解一次同余式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个定理:</span><br><span class="line">若 (a, m) = 1, 则一次同余式</span><br><span class="line">                 ax ≡ b (mod m)</span><br><span class="line">有唯一解</span><br><span class="line">例：19x ≡ 1(mod 48)</span><br><span class="line">因为(19, 48) = 1, 所以一次同余式有唯一解，即19对于模48的有唯一逆元。</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c75b8f5ca55cf1486266f36d7e76e924.png" alt="Solve a congruence" /></p>
<h1 id="古典密码">古典密码</h1>
<h2 id="单表密码体制">单表密码体制</h2>
<p>如果明文中不同的位置的同一明文字母在密文中对应的密文字母相同,则称其为单表密码体制。</p>
<ul>
<li>乘法密码算法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3dd17f64de84a1c8ce3402f340d4ee36.png" alt="Multiplication cryptographic algorithm" /></p>
<ul>
<li>仿射密码算法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/084606049081d419d0a7a927a5973eed.png" alt="Affine cryptographic algorithm" /></p>
<ul>
<li>语言的统计特性：频率特征；连接特征；重复特征</li>
</ul>
<h2 id="多表密码体制">多表密码体制</h2>
<p>如果明文中不同的位置的同一明文字母在密文中对应的密文字母不同,则称其为多表密码体制。</p>
<h1 id="安全电子邮件方案">安全电子邮件方案</h1>
<h2 id="pgp产生的背景">PGP产生的背景</h2>
<p>你的电子邮件不安全，电子邮件在传输中使用的SMTP协议。</p>
<ul>
<li>无法保证邮件在传输过程中不被人偷看。</li>
<li>无法确认来源。</li>
<li>无法确定邮件是否在传输过程中被篡改</li>
<li>当邮件被发到错误地址，可能造成信息泄露</li>
</ul>
<h2 id="pgp提供了一个安全电子邮件解决方案">PGP提供了一个安全电子邮件解决方案</h2>
<p>PGP (Pretty Good Privacy) 具有以下的功能</p>
<ul>
<li>消息加密</li>
<li>数字签名</li>
<li>完整性确认</li>
<li>数据压缩</li>
</ul>
<h3 id="pgp加密流程">PGP加密流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b09aa8d21c3db8c63e087bfa93020877.png" alt="PGP encrypt" /></p>
<h3 id="pgp解密流程">PGP解密流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/154124f32894f962838c70977cabdb26.png" alt="PGP decrypt" /></p>
<h3 id="pgp整合了对称加密和公钥加密的方案">PGP整合了对称加密和公钥加密的方案</h3>
<ul>
<li>保持了对称加密算法速度快的特点</li>
<li>具有公钥算法密钥分配方便的特点</li>
</ul>
<h2 id="pgp数字签名和hash函数">PGP数字签名和Hash函数</h2>
<p>直接对明文进行数字签名一些问题</p>
<ul>
<li>速度非常慢</li>
<li>生成大量的数据</li>
</ul>
<p>PGP的解决方案</p>
<ul>
<li>对明文使用一种Hash函数, 产生定长的数据, 称为消息摘要</li>
<li>PGP使用签名算法对摘要签名</li>
<li>PGP将签名和明文一同传输</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e6d41a3a99acd12139a2e0614676f81a.png" alt="PGP digital signature" /></p>
<h2 id="公共密钥分发和证明模型">公共密钥分发和证明模型</h2>
<h3 id="金字塔模型">金字塔模型</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b1237f6ee63cf73edcde1c110fbf3476.png" alt="pyramid model" /></p>
<h3 id="直接信任模型">直接信任模型</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/15201e23f3b4a7444812eca45aeebec8.png" alt="direct trust model" /></p>
<h3 id="信任网络">信任网络</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/eeadb6d1e2d99037708952168a9f2d54.png" alt="trust network" /></p>
<h1 id="对称密码">对称密码</h1>
<h2 id="aes的若干要求和评估准则">AES的若干要求和评估准则</h2>
<ul>
<li>AES的基本要求：比DES快而且比DES安全，分组长度为128比特，密钥长度为128／192（超56比特）。</li>
<li>安全性评估：算法输出的随机性好，抗密码分析能力强，并且有可靠的数学基础。</li>
<li>成本估计准则：许可成本低，在各种平台上的计算高效率和较小的内存空间需求。</li>
<li>算法和实现特性准则：灵活性、硬件和软件适用性、算法的简明性。</li>
</ul>
<p>具体体现为：</p>
<ul>
<li>算法处理的密钥和分组长度必须具备灵活的支持范围；</li>
<li>算法在许多不同类型的环境下能够安全和有效地实现；</li>
<li>可以作为序列密码、哈希算法实现；</li>
<li>算法必须能够用软件和硬件两种方法实现，并且有利于有效的固件实现；</li>
<li>算法设计相对简单。</li>
</ul>
<h2 id="分组密码的填充与模式">分组密码的填充与模式</h2>
<p>（1）什么是填充，为什么需要填充</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f9013eaf183c39051322642f6ec35092.png" alt="padding" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a23e6ca46cd8f962fd8c8d3ea7c0b583.png" alt="no padding" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/498dab03a71688c382b722bcd0a0aede.png" alt="PKCS#5 padding" /></p>
<p>（2）什么是模式，为什么需要模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/03baa2362ee7ab6bb28622469c0fd4ad.png" alt="mode" /></p>
<p><strong>分组密码工作模式的应用背景</strong>：多次使用相同的密钥对多个分组加密，会引发许多安全问题。为了应对不同场合，因而需要开发出不同的工作模式来增强密码算法的安全性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dce657af901a9be8a4c9ead487a94351.png" alt="group work mode" /></p>
<ul>
<li><p>ECB模式</p>
<p>特别适合数据较少的情况，对于很长的信息或者具有特定结构的信息（对ECB模式分组重放攻击），其大量重复的信息或固定的字符开头将给密码分析者提供大量的已知明密文对。若明文不是完整的分组，ECB需要进行填充。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6d27b31840c3008c7c001b839233f4f2.png" alt="ECB" /></p>
<p>ECB模式的特点</p>
<ul>
<li>简单</li>
<li>有利于并行</li>
<li>计算误差不会被传递</li>
<li>不能隐藏明文的模式</li>
<li>可能对明文进行主动攻击</li>
</ul></li>
<li><p>CBC模式</p>
<p>由于加密算法的每次输入和本明文组没有固定的关系，因此就算有重复的明文组，加密后也看不出来了。为了配合算法的需要，有一个初始向量（IV）。与ECB一样有填充机制以保证完整的分组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ad096cfd9871a0ecdc00178942d7058a.png" alt="CBC" /></p>
<p>CBC的特点</p>
<ul>
<li>不容易主动攻击</li>
<li>不利于并行</li>
<li>计算误差传递</li>
<li>需要初始向量IV</li>
</ul>
<p>安全性好于ECB, 适合传输长度长的报文,是SSL, IPSec的标准</p></li>
<li><p>CFB模式</p>
<p>和OFB，CTR模式一样，均可将分组密码当做流密码（实际是将分组大小任意缩减）使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/86465767a9c0e7b63a53b490a9d6cdff.png" alt="CFB" /></p>
<p>CFB模式的特点</p>
<ul>
<li>隐藏了明文模式</li>
<li>分组密码转化为流模式</li>
<li>可以及时加密传输小于分组的数据</li>
<li>不利于并行计算</li>
<li>误差传递：一个明文单元损坏影响多个单元唯一的ＩＶ</li>
</ul></li>
<li><p>OFB模式</p>
<p>OFB的结构与CFB很相似，它用加密函数的输出填充移位寄存器，而CFB是用密文单元来填充移位寄存器。其他的不同是，OFB模式是对整个明文和密文分组进行运算，而不是仅对s位的子集运算，因而不至于浪费运算能力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/95e95626263bd7b21a1fd7ef6a5a699e.png" alt="OFB" /></p>
<p>OFB模式的特点</p>
<ul>
<li>隐藏了明文模式</li>
<li>分组密码转化为流模式</li>
<li>可以及时加密传输小于分组的数据</li>
<li>不利于并行计算</li>
<li>对明文的主动攻击是可能的</li>
<li>误差传递：一个单元损坏只损坏对应单元</li>
<li>唯一的ＩＶ</li>
</ul>
<p>安全性于不如CFB</p></li>
</ul>
<h2 id="流密码">流密码</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/671d5585286d828bae248bbc87f1dac4.png" alt="vernam" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b5c90a3f672b9ff2547750220f26f073.png" alt="linear feedback shift register" /></p>
<h2 id="随机位的测试">随机位的测试</h2>
<ul>
<li>单个位测试(monobit test) 目的：校验1和0的个数是否大致相等。</li>
<li>扑克牌测试(poker test) 目的： 测试0至15的分布的随机随机性</li>
<li>连续串测试 目的：测试连续串长度分布的随机性</li>
</ul>
<h1 id="单向散列函数">单向散列函数</h1>
<h2 id="性质">性质</h2>
<ul>
<li>h(x)的输入x为任意长度</li>
<li>h(x)的输出长度固定</li>
<li>h(x)的计算方便快捷</li>
<li>h(x)的计算具有单向性</li>
<li>对于给定 x, 找到 y != x, 且 h(y) = h(x) 在计算不可行</li>
</ul>
<h2 id="应用">应用</h2>
<p>（1）使用Hash函数进行完整性验证的模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1fb4b778d7cd76503d1ca6c6548b03d.png" alt="check integrity by hash" /></p>
<p>（2）PGP的公钥真实性验证</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/96d0427d8cd4ed4256a083ac85ecfde7.png" alt="PGP public key verify" /></p>
<h2 id="碰撞">碰撞</h2>
<p>如果 y != x, 且 h(x) = h(y), 则称为碰撞 对给定的 x, 要找到一个 y 满足 y != x, h(x) = h(y) 在计算上不可行, 则称为弱无碰撞 要找到任意一对数 x,y, y != x, 满足 h(x) = h(y), 在计算上不可行, 则称为强无碰撞(包含弱无撞)</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/87b98ae5aff37e728c5e5d17c452cb40.png" alt="hash collision" /></p>
<h2 id="对数字签名的生日攻击">对数字签名的生日攻击</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d7008582105ce8d2542314a8e7bc4fc1.png" alt="birthday attack" /></p>
<h1 id="不对称密码">不对称密码</h1>
<h2 id="公钥密码的特性">公钥密码的特性</h2>
<ul>
<li>特性一：加密和解密使用不同的钥匙</li>
<li>特性二：从一个钥匙推出另一个钥匙在计算上不可行</li>
<li>特性三：每个钥匙都可以做加密和解密</li>
</ul>
<h2 id="rsa算法">RSA算法</h2>
<p>RSA算法可用于加密、又可用于数字签字，易懂且易于实现，是目前仍然安全并且逐步被广泛应用的一种体制。</p>
<h2 id="euler函数">Euler函数</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/43af4c780145132ce7e8c6716b20920e.png" alt="Euler function" /></p>
<h2 id="euler定理">Euler定理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/29d401af406d98301da457fc64798f54.png" alt="Euler theorem" /></p>
<h2 id="rsa密钥对生成步骤">RSA密钥对生成步骤</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f765b45da28bc037280f9b0d0d1d0b88.png" alt="RSA key pair generation" /></p>
<h2 id="rsa加密和解密步骤">RSA加密和解密步骤</h2>
<p>加密消息前，首先将它分成比n小的数据分组，再对每个分组加密</p>
<ul>
<li>加密： <span class="math inline">\(C=M^e(mod\ n)\)</span></li>
<li>解密： <span class="math inline">\(M=C^d(mod\ n)\)</span></li>
</ul>
<h2 id="rsa密钥对生成实例">RSA密钥对生成实例</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/424075aa423829a0391a98bcc853b3dd.png" alt="RSA key pair generation example" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a524e12cd4e5320bdbea37769d0795a1.png" alt="RSA encrypt and decrypt example" /></p>
<h2 id="rsa的缺点">RSA的缺点</h2>
<p>受到素数产生技术的限制，产生密钥很麻烦。 分组长度太大，为保证安全性，n 至少也要 600比特以上，使运算代价很高，尤其是速度较慢；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化</p>
<h2 id="当pq比较接近的数分解攻击">当p,q比较接近的数分解攻击</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e1b350b3af660b9676912058b43da4e8.png" alt="decomposition attack 1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cb81f1e0fdca6c4789cbfa2c582f86ea.png" alt="decomposition attack 2" /></p>
<h2 id="选择明文攻击">选择明文攻击</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/44f805ba13c49f0c8804035da24accc1.png" alt="select plaintext attack" /></p>
<p>从算法上无法解决这一问题，主要措施是采用好的公钥协议：</p>
<ul>
<li>工作过程中实体不轻易对其他实体任意产生的信息加解密，不对自己一无所知的信息签名</li>
<li>对其他实体送来的随机文档签名时首先对文档作HASH处理</li>
</ul>
<h1 id="elgamal密码体制">ElGamal密码体制</h1>
<p>由ElGamal[1984,1985]提出，是一种基于离散对数问题的双钥密码体制，既可用于加密，又可用于签字。</p>
<h2 id="elgamal密钥对生成步骤">ElGamal密钥对生成步骤</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dfa9e6d2c54c514935d282d21d6bb40f.png" alt="ElGamal key pair gen" /></p>
<h2 id="elgamal加密和解密步骤">ElGamal加密和解密步骤</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bfc9dfa2e3d1a45ea98ed8deb13204b9.png" alt="ElGamal encrypt and decrypt" /></p>
<h2 id="elgamal密钥对生成例子">ElGamal密钥对生成例子</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b346d1cfd0a6c7e3c07a2b098197d9f4.png" alt="ElGamal key pair gen example" /></p>
<h2 id="elgamal加密和解密例子">ElGamal加密和解密例子</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1b84050c50736c456c11f9d727f072a.png" alt="ElGamal encrypt and decrypt example" /></p>
<h1 id="diffie-hellman密钥交换">Diffie-Hellman密钥交换</h1>
<p>密钥交换方案:允许两个用户可以安全地建立一个秘密信息，用于后续的通讯过程 算法的安全性依赖于:有限域上计算离散对数的难度</p>
<h2 id="dh密钥匙方案实现步骤">DH密钥匙方案实现步骤</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7f49ca12367df14dd0ea2b488fc97910.png" alt="DH key exchange" /></p>
<h2 id="dh密钥匙交换方案实现例子">DH密钥匙交换方案实现例子</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c5a06b231c6c9c9c179d34d3b245ea1.png" alt="DH key exchange example" /></p>
<h2 id="dh密钥匙方案的第三者攻击方法">DH密钥匙方案的第三者攻击方法</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/87303aed7496f9dafae44487a9aa1d89.png" alt="DH third party attack" /></p>
<p>第三者攻击的方法的为什么可以成功呢? 问题在于：A和B在不安全的信道上通信, 那么双方如何能够知道通信的另一方的到底是谁呢? 是否能设计一种可以确认通信双方身份的DH密钥交换方案呢?</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8c0c85ce951daa2fb2b8fa057c29debb.png" alt="DH key exchange with identity auth" /></p>
<h1 id="数字签名">数字签名</h1>
<h2 id="rsa签名方案">RSA签名方案</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a8043e86475699d1aa460dba9191fca7.png" alt="RSA signature" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c232e619e9ac36d6f139d942db9901e.png" alt="RSA signature example" /></p>
<h2 id="elg签名方案">ELG签名方案</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/faf924b5fdfa67b4fe0e78afc1151076.png" alt="ELG signature" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8b85c54a331eac1c619bd48f4bed5c5a.png" alt="ELG signature example" /></p>
<h1 id="实验02">实验02</h1>
<p>（1）使用PGP软件，产生一对新的公钥/私钥，并在PGP服务器上注册</p>
<p>思考：为什么不是由服务器统一产生公钥/私钥对呢，而是由客户端产生钥匙对呢？注册完成后，公钥/私钥存放在什么地方呢？私钥需要什么样的保护措施吗？</p>
<ul>
<li>公钥/私钥对不由任一政府或标准化组织所控制，使得PGP得到广泛信任，能够满足商业化的需求。</li>
<li>在服务器上注册后，公钥存放在服务器上，私钥则由使用者自己保存。</li>
<li>使用口令密码对私钥加密存储，口令密码方便记忆，也可以保护私钥。</li>
</ul>
<p>（2）邀请其他使用者互相签署对方的公钥</p>
<p>思考：此步骤的意义是什么？在签署他人的公钥前，应该注意什么？</p>
<ul>
<li>相互签署公钥用于建立信任体系，信任对方公钥是指定实体的合法公钥。</li>
<li>需要确认所签署公钥是指定实体的合法公钥，可行的方法有：物理上得到对方的公钥，这种方式最可靠，但有一定局限性；通过电话验证公钥；从双方都信任的第三方处获得对方公钥。</li>
</ul>
<p>（3）使用ASCII编码格式将自己的公钥发给其他使用者</p>
<p>思考：这样在整个PGP信任体系中的意义是什么？</p>
<ul>
<li>向信任的朋友发送公钥和接收信任朋友传送来的公钥，一般这些公钥都带有签名，在这种方式下，用户可以自行决定对周围的联系人是否信任，建立以个人为中心的信任模型。</li>
</ul>
<p>（4）发送加密及签名的电子邮件</p>
<p>思考: 加密时使用了谁的、哪一把钥匙；签名时又使用了谁的、哪一把钥匙？邮件是否一定要同时加密和签名呢？邮件的长度是可变的，但数字签名的数据长度似乎是定长，这是为什么？</p>
<ul>
<li>加密时使用了接收者的公钥</li>
<li>签名时使用了发送者的私钥</li>
<li>邮件不一定要同时加密和签名</li>
<li>实际上，sign &amp; verify 是利用 hash function 及非对称加密的技术来达到确认文件来源及文件内容是没被更改过的，而hash value的长度是由不同的hash function决定的，常见的hash function有MD2, MD5, SHA-1, SHA-128, SHA-256, SHA-512</li>
</ul>
<p>（5）收到他人的加密及签名的电子邮件后，解密并验证其签名的正确性</p>
<p>思考：解密时使用了谁的、哪一把钥匙；验证签名时又使用了谁的、哪一把钥匙？</p>
<ul>
<li>解密时使用了接收者的私钥</li>
<li>验证签名时使用了发送者的公钥</li>
</ul>
]]></content>
      <categories>
        <category>cs</category>
        <category>cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx configuration for CodeIgniter</title>
    <url>/posts/ec244fdf/</url>
    <content><![CDATA[<p>Nginx server configuration for CodeIgniter</p>
<span id="more"></span>
<h1 id="my-environment">My Environment</h1>
<ul>
<li><strong>System:</strong> CentOS 7</li>
<li><strong>Web Server:</strong> Nginx v1.17.2</li>
<li><strong>Application Server:</strong> php-fpm (based on PHP 7.2)</li>
<li><strong>Web Framework:</strong> CodeIgniter v3.1.10</li>
</ul>
<h1 id="deploy-codeigniter-project">Deploy CodeIgniter project</h1>
<p>First, Goto <a href="https://www.codeigniter.com/download">Official website</a> and download CodeIgniter.</p>
<p>Then, create a folder named <code>ci</code> in the root directory of the nginx server and extract the CodeIgniter framework code into this directory. As follow:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@xyz html]# pwd</span><br><span class="line">/usr/share/nginx/html</span><br><span class="line">[root@xyz html]# tree -L 1 ci</span><br><span class="line">ci</span><br><span class="line">├── application</span><br><span class="line">├── composer.json</span><br><span class="line">├── contributing.md</span><br><span class="line">├── index.php</span><br><span class="line">├── license.txt</span><br><span class="line">├── readme.rst</span><br><span class="line">├── system</span><br><span class="line">└── user_guide</span><br><span class="line"></span><br><span class="line">3 directories, 5 files</span><br><span class="line">[root@xyz html]#</span><br></pre></td></tr></table></figure>
<p>The path <code>/usr/share/nginx/html</code> is the default static files path of nginx in my machine. You can use any other path actually. Just for simple, my goal to test the nginx server configuration.</p>
<h1 id="edit-nginx-server-configuration">Edit Nginx server configuration</h1>
<p>Edit nginx default configuration file named <code>default.conf</code>, which is in <code>/etc/nginx/conf.d</code>.</p>
<p>I highly recommend you back up before changing the server configuration.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /ci &#123;</span><br><span class="line">        try_files $uri $uri/ /ci/index.php?/$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    location ~ /\.ht &#123;</span><br><span class="line">        deny  all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="test">Test</h1>
<p><strong>My codeigniter folder is <code>ci</code> which is located in <code>/usr/share/nginx/html/ci</code>.</strong></p>
<ul>
<li><p>default controller</p>
<p><code>http://yourdomain/ci/index.php/</code></p>
<p><code>http://yourdomain/ci/index.php/welcome</code></p>
<p>The effect of these two urls is the same. They all execute the <code>index</code> function of <code>Welcome</code> controller in <code>Welcome.php</code> file.</p></li>
<li><p>custom controller</p>
<p>Create a file named <code>Test.php</code> in <code>application/controllers</code> directory and edit it as follow:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Test Controller index!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello CodeIgniter!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Restart service and test:</p>
<p><code>http://yourdomain/ci/index.php/Test/</code></p>
<p><code>http://yourdomain/ci/index.php/Test/hello</code></p>
<p>All these work well.</p></li>
</ul>
]]></content>
      <categories>
        <category>programming-language</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>CodeIgniter</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB分片集群搭建</title>
    <url>/posts/e54730f4/</url>
    <content><![CDATA[<p>在如今的互联网环境下，海量数据已随处可见并且还在不断增长，对于如何存储处理海量数据，比较常见的方法有两种：</p>
<ul>
<li><strong>垂直扩展</strong>：通过增加单台服务器的配置，例如使用更强悍的 CPU、更大的内存、更大容量的磁盘，此种方法虽然成本很高，但是实现比较简单，维护起来也比较方便。</li>
<li><strong>水平扩展</strong>：通过使用更多配置一般的服务器来共同承担工作负载，此种方法很灵活，可以根据工作负载的大小动态增减服务器的数量，但是实现比较复杂，得有专门的人员来运维。</li>
</ul>
<p>MongoDB 支持通过分片技术从而进行水平扩展，用以支撑海量数据集和高吞吐量的操作。如果数据集不够大，还是建议您使用 <a href="https://docs.mongodb.com/manual/replication/">MongoDB 副本集</a>，因为分片需要处理更多的技术细节，所以在分片环境下其性能可能始终没有副本集性能强。本文通过介绍如何搭建 MongoDB 分片集群以及及一些相关核心概念，可以帮您快速理解 MongoDB 是如何通过分片技术来处理海量数据的。</p>
<span id="more"></span>
<h1 id="分片集群组件">分片集群组件</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/29228540b81791a13235d9e8e5cf3d2c.svg" alt="sharded cluster" /></p>
<p>MongoDB 分片集群（参考官方文档 <a href="https://docs.mongodb.com/manual/sharding/">Sharded Cluster</a>）由以下三个组件构成，缺一不可：</p>
<ul>
<li>mongos：数据库集群请求的入口，所有的请求都通过 mongos 进行协调，不需要在应用程序添加一个路由选择器，mongos 自己就是一个请求分发中心，它负责把对应的数据请求请求转发到对应的 shard 服务器上。在生产环境通常有多 mongos 作为请求的入口，防止其中一个挂掉所有的 mongodb 请求都没有办法操作。</li>
<li>config server：顾名思义为配置服务器，存储所有数据库元信息（路由、分片）的配置。mongos 本身没有物理存储分片服务器和数据路由信息，只是缓存在内存里，配置服务器则实际存储这些数据。mongos 第一次启动或者关掉重启就会从 config server 加载配置信息，以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态，这样 mongos 就能继续准确路由。从 MongoDB 3.4 开始，必须将配置服务器部署为副本集（CSRS，全称是 Config Servers Replica Set），因为它存储了分片路由的元数据，防止数据丢失！</li>
<li>shard，分片（sharding）是指将数据库拆分，将其分散在不同的机器上的过程，每个分片是整体数据的子集，且都可以部署为副本集。将数据分散到不同的机器上，不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。基本思想就是将集合切成小块，这些块分散到若干片里，每个片只负责总数据的一部分，最后通过一个均衡器来对各个分片进行均衡（数据迁移）。</li>
</ul>
<p>其它名词概念：</p>
<ul>
<li>replica set：中文翻译副本集，其实就是 shard 的备份，防止 shard 挂掉之后数据丢失。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</li>
<li>仲裁者（Arbiter）：是复制集中的一个 MongoDB 实例，它并不保存数据。仲裁节点使用最小的资源并且不要求硬件设备，不能将 Arbiter 部署在同一个数据集节点中，可以部署在其他应用服务器或者监视服务器中，也可部署在单独的虚拟机中。为了确保复制集中有奇数的投票成员（包括 primary），需要添加仲裁节点做为投票，否则 primary 不能运行时不会自动切换 primary。</li>
</ul>
<p>简单了解之后，我们可以这样总结一下，应用请求 mongos 来操作 mongodb 的增删改查，配置服务器存储数据库元信息，并且和 mongos 做同步，数据最终存入在 shard（分片）上，为了防止数据丢失同步在副本集中存储了一份，仲裁在数据存储到分片的时候决定存储到哪个节点。</p>
<h1 id="sharded-key-分片键">Sharded Key 分片键</h1>
<p>MongoDB 通过定义 shared key（分片键）从而对整个集合进行分片，分片键的好坏直接影响到整个集群的性能。另外需要注意的是，一个集合只有且只能有一个分片键，一旦分片键确定好之后就不能更改。分片键分为以下两种类型：</p>
<ul>
<li><strong>基于 Hashed 的分片</strong>：MongoDB 会计算分片键字段值的哈希值，用以确定该文档存于哪个 chunk，从而达到将集合分摊到不同的 chunk。此种类型能够使得数据整体分布比较均匀，对于等值查询效率很高，但是对于范围查询效率就比较低，因为可能要扫描所有的分片才能获取到数据。</li>
<li><strong>基于 Ranged 的分片</strong>：MongoDB 会将相似的值放到一个 chunk 中，所以说如果在查询的时候带上分片键的范围条件，查询效率会非常高，因为不需要扫描所有的分片就可以定位到数据。注意，如果片键的值为单调递增或单调递减，那么不适合采用该分片策略，因为数据总会写到一个分片，从而没有很好地分散 IO。</li>
</ul>
<p>分片键的类型需要根据实际的业务场景决定，例如有张非常大的用户表，用户表里有用户 ID 字段，每次查询的时候都会带上用户 ID，如果想对该用户表进行分片，可以选择将用户 ID 字段作为 shard key，并且分片键类型可以使用基于 Hashed 的分片。</p>
<h1 id="chunk-块">Chunk 块</h1>
<p><strong>chunk</strong>（块）是均衡器迁移数据的最小单元，默认大小为 64MB，取值范围为 1-1024MB。一个块只存在于一个分片，每个块由片键特定范围内的文档组成，块的范围为左闭又开即 <code>[start,end)</code>。一个文档属于且只属于一个块，当一个块增加到特定大小的时候，会通过拆分点（split point）被拆分成 2 个较小的块。在有些情况下，chunk 会持续增长，超过 ChunkSize，官方称为 <a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/Maximum-Number-of-Documents-Per-Chunk-to-Migrate">jumbo chunk</a>，该块无法被 MongoDB 拆分，也不能被均衡器迁移，故久而久之会导致 chunk 在分片服务器上分布不均匀，从而成为性能瓶颈，表现之一为 insert 数据变慢。</p>
<h2 id="chunk-的拆分">Chunk 的拆分</h2>
<p>mongos 会记录每个块中有多少数据，一旦达到了阈值就会检查是否需要对其进行拆分，如果确实需要拆分则可以在配置服务器上更新这个块的相关元信息。</p>
<p>chunk 的拆分过程如下：</p>
<ol type="1">
<li>mongos 接收到客户端发起的写请求后会检查当前块的拆分阈值点。</li>
<li>如果需要拆分，mongos 则会像分片服务器发起一个拆分请求。</li>
<li>分片服务器会做拆分工作，然后将信息返回 mongos。</li>
</ol>
<p>注意，相同的片键只能保存在相同的块中，如果一个相同的片键过多，则会导致一个块过大，成为 jumbo chunk，所以具有不同值的片键很重要。</p>
<h2 id="chunk-的迁移过程"><a href="https://docs.mongodb.com/manual/core/sharding-balancer-administration/">Chunk 的迁移过程</a></h2>
<ol type="1">
<li>均衡器进程发送 <code>moveChunk</code> 命令到源分片。</li>
<li>源分片使用内部 <code>moveChunk</code> 命令，在迁移过程，对该块的操作还是会路由到源分片。</li>
<li>目标分片构建索引。</li>
<li>目标分片开始进行数据复制。</li>
<li>复制完成后会同步在迁移过程中该块的更改。</li>
<li>同步完成后源分片会连接到配置服务器，使用块的新位置更新集群元数据。</li>
<li>源分片完成元数据更新后，一旦块上没有打开的游标，源分片将删除其文档副本。</li>
</ol>
<p>迁移过程可确保一致性，并在平衡期间最大化块的可用性。</p>
<h2 id="chunk-迁移的阈值">Chunk 迁移的阈值</h2>
<p>为了最大程度地减少平衡对集群的影响，平衡器仅在分片集合的块分配达到某些阈值之后才开始平衡。阈值适用于集合中具有最多块的 shard 与该集合中具有最少块的 shard 之间的块数差异。平衡器具有以下阈值：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Number of Chunks</th>
<th style="text-align: left;">Migration Threshold</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Fewer than 20</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">20-79</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">80 and greater</td>
<td style="text-align: left;">8</td>
</tr>
</tbody>
</table>
<p>当该集合的任何两个分片上的块数之差小于2或块迁移失败时，平衡器将停止在目标集合上运行。</p>
<h2 id="修改-chunk-size-的注意事项">修改 Chunk Size 的注意事项</h2>
<p>修改 chunk 大小需要注意以下几点：</p>
<ol type="1">
<li>chunk 的自动拆分操作仅发生在插入或更新的时候。</li>
<li>如果减少 chunk size，将会耗费一些时间将原有的 chunk 拆分到新 chunk，并且此操作不可逆。</li>
<li>如果新增 chunk size，已存在的 chunk 只会等到新的插入或更新操作将其扩充至新的大小。</li>
<li>chunk size 的可调整范围为 1-1024MB。</li>
</ol>
<h1 id="balancer-均衡器">Balancer 均衡器</h1>
<p>MongoDB 的 balancer（均衡器）是监视每个分片的 chunk 数的一个后台进程。当分片上的 chunk 数达到特定迁移阈值时，均衡器会尝试在分片之间自动迁移块，使得每个分片的块的数量达到平衡。分片群集的平衡过程对用户和应用程序层完全透明，但在执行过程时可能会对性能产生一些影响。</p>
<p>从 MongoDB 3.4 开始，balancer 在配置服务器副本集（CSRS）的主服务器上运行，在 3.4 版本中，当平衡器进程处于活动状态时，主配置服务器的的 locks 集合通过修改 <code>_id: "balancer"</code> 文档会获取一个 balancer lock，该 balancer lock 不会被释放，是为了保证只有一个 mongos 实例能够在分片集群中执行管理任务。从 3.6 版本开始，均衡器不再需要 balancer lock。</p>
<p>均衡器可以动态的开启和关闭，也可以针对指定的集合开启和关闭，还可以手动控制均衡器迁移 chunk 的时间，避免在业务高峰期的时候迁移 chunk 从而影响集群性能。以下命令将均衡器的迁移 chunk 时间控制在凌晨 02 点至凌晨 06 点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use config</span><br><span class="line">db.settings.update(</span><br><span class="line">   &#123; _id: &quot;balancer&quot; &#125;,</span><br><span class="line">   &#123; $set: &#123; activeWindow : &#123; start : &quot;02:00&quot;, stop : &quot;06:00&quot; &#125; &#125; &#125;,</span><br><span class="line">   &#123; upsert: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="环境准备">环境准备</h1>
<ul>
<li><p>系统系统：CentOS7 64位</p></li>
<li><p>三台服务器：192.168.0.11/12/13</p></li>
<li><p>安装包：mongodb-linux-x86_64-4.2.5.tgz</p></li>
<li><p>服务器规划</p>
<table>
<thead>
<tr class="header">
<th><strong>服务器11</strong></th>
<th><strong>服务器12</strong></th>
<th><strong>服务器13</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mongos</td>
<td>mongos</td>
<td>mongos</td>
</tr>
<tr class="even">
<td>config server</td>
<td>config server</td>
<td>config server</td>
</tr>
<tr class="odd">
<td>shard server1 主节点</td>
<td>shard server1 副节点</td>
<td>shard server1 仲裁</td>
</tr>
<tr class="even">
<td>shard server2 仲裁</td>
<td>shard server2 主节点</td>
<td>shard server2 副节点</td>
</tr>
<tr class="odd">
<td>shard server3 副节点</td>
<td>shard server3 仲裁</td>
<td>shard server3 主节点</td>
</tr>
</tbody>
</table></li>
<li><p>端口分配</p>
<ul>
<li>mongos：20000</li>
<li>config：21000</li>
<li>shard1：27001</li>
<li>shard2：27002</li>
<li>shard3：27003</li>
</ul></li>
</ul>
<h1 id="分片集群搭建">分片集群搭建</h1>
<h2 id="安装-mongodb">安装 mongodb</h2>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat-tarball/">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat-tarball/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf mongodb-linux-x86_64-4.2.5.tgz -C /usr/local/</span><br><span class="line">mv mongodb-linux-x86_64-4.2.5 mongodb</span><br></pre></td></tr></table></figure>
<h3 id="创建数据和日志目录">创建数据和日志目录</h3>
<p>分别在每台机器建立 conf、mongos、config、shard1、shard2、shard3 六个目录，因为 mongos 不存储数据，只需要建立日志文件目录即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/mongodb/conf /usr/local/mongodb/mongos/log /usr/local/mongodb/config/data /usr/local/mongodb/config/log /usr/local/mongodb/shard1/data /usr/local/mongodb/shard1/log /usr/local/mongodb/shard2/data /usr/local/mongodb/shard2/log /usr/local/mongodb/shard3/data /usr/local/mongodb/shard3/log</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量">配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$MONGODB_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使修改立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="config-server-配置服务器">config server 配置服务器</h2>
<p>mongodb3.4 以后要求配置服务器也创建副本集，不然集群搭建不成功。</p>
<p>添加配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/config.conf</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/config/log/configsrv.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/config/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/config/log/configsrv.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">21000</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 声明这是集群的配置服务器</span></span><br><span class="line"><span class="attr">configsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=configs</span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>启动三台服务器的 config server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/config.conf</span><br></pre></td></tr></table></figure>
<p>登录任意一台配置服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 21000</span><br></pre></td></tr></table></figure>
<p>定义 config server 副本集配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;configs&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:21000&quot; &#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:21000&quot; &#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:21000&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 config server 副本集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>
<p>其中，<code>_id : "configs"</code> 应与配置文件中配置的 <code>replicaction.replSetName</code> 一致，"members" 中的 "host" 为三个节点的 ip 和 port</p>
<h2 id="配置分片副本集三台机器">配置分片副本集（三台机器）</h2>
<h3 id="设置第一个分片副本集">设置第一个分片副本集</h3>
<p>添加配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard1.conf</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard1/log/shard1.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard1/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard1/log/shard1.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27001</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard1</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>启动三台服务器的 shard1 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard1.conf</span><br></pre></td></tr></table></figure>
<p>登录任意一台非 arbiter 的 shard1 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27001</span><br></pre></td></tr></table></figure>
<p>使用 admin 数据库，定义 shard1 server 副本集配置：</p>
<p>第三个节点的 <code>arbiterOnly: true</code> 代表其为仲裁节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard1&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27001&quot;&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27001&quot;&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27001&quot;, arbiterOnly: true&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 shard1 server 副本集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>
<h3 id="设置第二个分片副本集">设置第二个分片副本集</h3>
<p>添加配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard2.conf</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard2/log/shard2.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard2/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard2/log/shard2.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27002</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard2</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>启动三台服务器的 shard2 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard2.conf</span><br></pre></td></tr></table></figure>
<p>登录任意一台非 arbiter 的 shard2 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27002</span><br></pre></td></tr></table></figure>
<p>使用 admin 数据库，定义 shard2 server 副本集配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard2&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27002&quot;, arbiterOnly: true&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27002&quot;&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27002&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 shard2 server 副本集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>
<h3 id="设置第三个分片副本集">设置第三个分片副本集</h3>
<p>添加配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard3.conf</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard3/log/shard3.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard3/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard3/log/shard3.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27003</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard3</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>启动三台服务器的 shard3 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard3.conf</span><br></pre></td></tr></table></figure>
<p>登录任意一台非 arbiter 的 shard3 server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27003</span><br></pre></td></tr></table></figure>
<p>使用 admin 数据库，定义 shard3 server 副本集配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard3&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27003&quot;&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27003&quot;, arbiterOnly: true&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27003&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 shard3 server 副本集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>
<h2 id="配置路由服务器-mongos">配置路由服务器 mongos</h2>
<p>先启动配置服务器和分片服务器，后启动路由实例：（三台机器）</p>
<p>添加配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/mongos/log/mongos.pid</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/mongos/log/mongos.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">20000</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 监听的配置服务器, 只能有1个或者3个, configs为配置服务器的副本集名字</span></span><br><span class="line"><span class="attr">configdb</span>=configs/<span class="number">192.168</span>.<span class="number">0.11</span>:<span class="number">21000</span>,<span class="number">192.168</span>.<span class="number">0.12</span>:<span class="number">21000</span>,<span class="number">192.168</span>.<span class="number">0.13</span>:<span class="number">21000</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>启动三台服务器的 mongos server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongos -f /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure>
<h2 id="启用分片">启用分片</h2>
<p>目前搭建了 mongodb 配置服务器、路由服务器，各个分片服务器，不过应用程序连接到 mongos 路由服务器并不能使用分片机制，还需要在程序里设置分片配置，让分片生效。</p>
<p>登陆任意一台 mongos：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure>
<p>使用 admin 数据库，串联路由服务器与分片副本集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">sh.addShard(&quot;shard1/192.168.0.11:27001,192.168.0.12:27001,192.168.0.13:27001&quot;)</span><br><span class="line">sh.addShard(&quot;shard2/192.168.0.11:27002,192.168.0.12:27002,192.168.0.13:27002&quot;)</span><br><span class="line">sh.addShard(&quot;shard3/192.168.0.11:27003,192.168.0.12:27003,192.168.0.13:27003&quot;)</span><br></pre></td></tr></table></figure>
<p>查看集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure>
<h2 id="测试分片">测试分片</h2>
<h3 id="基于-hashed-的分片">基于 Hashed 的分片</h3>
<p>目前配置服务、路由服务、分片服务、副本集服务都已经串联起来了，现在我们希望插入数据时，数据能够自动分片。</p>
<p>首先连接到 mongos：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure>
<p>切换到 admin 数据库，让指定的数据库、指定的集合分片生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 <span class="built_in">test</span> 库的分片功能</span></span><br><span class="line">db.runCommand(&#123;enablesharding: &quot;test&quot;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择集合的分片键，注意这里创建的是 <span class="built_in">hash</span> 索引</span></span><br><span class="line">db.runCommand(&#123;shardcollection: &quot;test.hashed&quot;, key: &#123;_id: &quot;hashed&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里设置 test 数据库的 <code>hashed</code> 表需要分片，根据 <code>_id</code> 自动分片到 shard1，shard2，shard3 上面去，之所以这样设置是因为不是所有 mongodb 的数据库和表都需要分片！</p>
<p>查看此时的分片的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">sh.status()</span></span><br><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">        &quot;currentVersion&quot; : 6,</span><br><span class="line">        &quot;clusterId&quot; : ObjectId(&quot;5e82a238caf5457afd11f184&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/192.168.0.11:27001,192.168.0.12:27001&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/192.168.0.12:27002,192.168.0.13:27002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard3&quot;,  &quot;host&quot; : &quot;shard3/192.168.0.11:27003,192.168.0.13:27003&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        &quot;4.2.5&quot; : 1</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  no</span><br><span class="line">        Failed balancer rounds in last 5 attempts:  0</span><br><span class="line">        Migration Results for the last 24 hours:</span><br><span class="line">                6 : Success</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard1&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : &#123;  &quot;uuid&quot; : UUID(&quot;3ed17366-fef3-4225-bdc4-f89f8bf751cf&quot;),  &quot;lastMod&quot; : 1 &#125; &#125;</span><br><span class="line">                test.hashed</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : &quot;hashed&quot; &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  2</span><br><span class="line">                                shard2  2</span><br><span class="line">                                shard3  2</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;-6148914691236517204&quot;) &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;-6148914691236517204&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;-3074457345618258602&quot;) &#125; on : shard1 Timestamp(1, 1)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;-3074457345618258602&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(0) &#125; on : shard2 Timestamp(1, 2)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(0) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;3074457345618258602&quot;) &#125; on : shard2 Timestamp(1, 3)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;3074457345618258602&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;6148914691236517204&quot;) &#125; on : shard3 Timestamp(1, 4)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;6148914691236517204&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard3 Timestamp(1, 5)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure>
<p>切换到 test 数据库，测试分片配置结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入测试数据</span></span><br><span class="line">for (var i = 1; i &lt;= 100000; i++) db.hashed.save(&#123;&quot;task&quot;: i, &quot;createTime&quot;: new Date()&#125;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分片情况</span></span><br><span class="line">db.hashed.stats();</span><br></pre></td></tr></table></figure>
<p>查看分片情况，省掉了部分无关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">use <span class="built_in">test</span></span></span><br><span class="line">switched to db test</span><br><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash"><span class="keyword">for</span> (var i = 1; i &lt;= 100000; i++) db.hashed.save(&#123;<span class="string">&quot;task&quot;</span>: i, <span class="string">&quot;createTime&quot;</span>: new Date()&#125;);</span></span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">db.hashed.stats()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;sharded&quot; : true,</span><br><span class="line">        &quot;capped&quot; : false,</span><br><span class="line">        ...</span><br><span class="line">        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">        &quot;count&quot; : 100000,</span><br><span class="line">        &quot;size&quot; : 5600000,</span><br><span class="line">        &quot;storageSize&quot; : 2539520,</span><br><span class="line">        &quot;totalIndexSize&quot; : 4485120,</span><br><span class="line">        &quot;indexSizes&quot; : &#123;</span><br><span class="line">                &quot;_id_&quot; : 1036288,</span><br><span class="line">                &quot;_id_hashed&quot; : 3448832</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;avgObjSize&quot; : 56,</span><br><span class="line">        &quot;maxSize&quot; : NumberLong(0),</span><br><span class="line">        &quot;nindexes&quot; : 2,</span><br><span class="line">        &quot;nchunks&quot; : 6,</span><br><span class="line">        &quot;shards&quot; : &#123;</span><br><span class="line">                &quot;shard3&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1872584,</span><br><span class="line">                        &quot;count&quot; : 33439,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 675840,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;shard2&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1874656,</span><br><span class="line">                        &quot;count&quot; : 33476,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 663552,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;shard1&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1852760,</span><br><span class="line">                        &quot;count&quot; : 33085,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 1200128,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ok&quot; : 1,</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到数据分到3个分片，各自分片数量为：</p>
<ul>
<li>shard1 <code>"count": 33085</code></li>
<li>shard2 <code>"count": 33476</code></li>
<li>shard3 <code>"count": 33439</code></li>
</ul>
<p>33085 + 33476 + 33085 = 100000</p>
<h3 id="基于-ranged-的分片">基于 Ranged 的分片</h3>
<p>基于范围分片特别适合范围查找，因为可以直接定位到分片，所以效率很高。</p>
<p>为了方便看到基于 Ranged 分片的效果，我们先修改分片集群的 Chunk Size。</p>
<blockquote>
<p>分片群集的默认块大小为 64 MB。 此默认块大小适用于大多数部署。但是，如果您发现自动迁移的 I/O超出了硬件的处理能力，则可能需要减小块大小。对于自动拆分和迁移，小的块大小会导致更快和更频繁的迁移。块大小的允许范围在 1 到 1024 MB（含）之间。</p>
</blockquote>
<p>连接到 mongos：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure>
<p>切换到 config 数据库，使用 save() 来设置全局块大小的配置值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use config</span><br><span class="line">db.settings.save(&#123;_id: &quot;chunksize&quot;, value: 2&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 chunk size 配置值</span></span><br><span class="line">db.settings.find(&#123;_id: &quot;chunksize&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>切换到 admin 数据库，让指定的数据库、指定的集合分片生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 <span class="built_in">test</span> 库的分片功能</span></span><br><span class="line">db.runCommand(&#123;enablesharding: &quot;test&quot;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择集合的分片键，此时 MongoDB 会自动为 age 字段创建索引</span></span><br><span class="line">db.runCommand(&#123;shardcollection: &quot;test.ranged&quot;, key: &#123;&quot;age&quot;: 1&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里设置 test 数据库的 <code>ranged</code> 表需要分片，根据 <code>age</code> 自动分片到 shard1，shard2，shard3，查看此时的分片的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">sh.status()</span></span><br><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">        &quot;currentVersion&quot; : 6,</span><br><span class="line">        &quot;clusterId&quot; : ObjectId(&quot;5e82fe6c6f3857f3fd9253ed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/10.251.1.231:27001,10.251.1.232:27001&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/10.251.1.232:27002,10.251.1.233:27002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard3&quot;,  &quot;host&quot; : &quot;shard3/10.251.1.231:27003,10.251.1.233:27003&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        &quot;4.2.5&quot; : 1</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  no</span><br><span class="line">        Failed balancer rounds in last 5 attempts:  0</span><br><span class="line">        Migration Results for the last 24 hours:</span><br><span class="line">                No recent migrations</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard1&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : &#123;  &quot;uuid&quot; : UUID(&quot;73c9a05f-b578-41ea-92c0-42d11821004c&quot;),  &quot;lastMod&quot; : 1 &#125; &#125;</span><br><span class="line">                test.ranged</span><br><span class="line">                        shard key: &#123; &quot;age&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;age&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;age&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure>
<p>切换到 test 数据库，测试分片配置结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入测试数据</span></span><br><span class="line">for (var i = 1; i &lt;= 100000; i++) db.ranged.save(&#123;&quot;age&quot;: NumberInt(i % 100), &quot;createTime&quot;: new Date()&#125;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分片情况</span></span><br><span class="line">db.ranged.stats()</span><br></pre></td></tr></table></figure>
<h1 id="后期运维">后期运维</h1>
<h2 id="启动关闭">启动关闭</h2>
<p>mongodb 的启动顺序是，先启动配置服务器，再启动分片，最后启动 mongos</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/config.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard1.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard2.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard3.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure>
<p>关闭时，直接 killall 杀掉所有进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall mongod</span><br><span class="line">killall mongos</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ol type="1">
<li>Mongodb 分片需要比较大的内存，搭建时分配比较大的内存空间，线上环境是 48G</li>
<li>每个 mongodb 实例，需要限制 wiredTigerCacheSizeGB 大小，即在每个配置文件中增加这个配置。根据经验，如果每台机器上的实例个数 n，<code>n * wiredTigerCacheSizeGB &lt; 2/3</code> 总内存</li>
<li>Mongodb 分片后，每次 update 数据时，必须指定片键，没有片键无法 update</li>
</ol>
<h1 id="附录">附录</h1>
<h2 id="清除数据和日志目录">清除数据和日志目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf config/data/*</span><br><span class="line">rm -rf config/log/*</span><br><span class="line">rm -rf mongos/log/*</span><br><span class="line">rm -rf shard1/data/*</span><br><span class="line">rm -rf shard1/log/*</span><br><span class="line">rm -rf shard2/data/*</span><br><span class="line">rm -rf shard2/log/*</span><br><span class="line">rm -rf shard3/data/*</span><br><span class="line">rm -rf shard3/log/*</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://docs.mongodb.com/manual/sharding/">https://docs.mongodb.com/manual/sharding/</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/index.html">https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/index.html</a></p>
<p><a href="http://www.ityouknow.com/mongodb/2017/08/05/mongodb-cluster-setup.html">http://www.ityouknow.com/mongodb/2017/08/05/mongodb-cluster-setup.html</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>sharding-cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB副本集搭建</title>
    <url>/posts/fd4a1d37/</url>
    <content><![CDATA[<p>对于互联网应用来说，我们要尽量保证服务的不可间断性，一旦出现故障需要尽快的恢复。MongoDB 的副本集模式主要解决了在其主从模式下故障无法自动转移的情况，自动实现高可用。三个成员副本集提供足够的冗余性，以承受大多数网络分区和其他系统故障，这些集合对于许多分布式读取操作也具有足够的容量。本文介绍如何从三个现有 mongod 实例创建三成员副本集，包括不启用访问控制的和启用访问控制的。</p>
<span id="more"></span>
<h1 id="mongodb副本集搭建">MongoDB副本集搭建</h1>
<p>MongoDB Replica Set</p>
<h1 id="三成员副本集部署模式">三成员副本集部署模式</h1>
<h2 id="p-s-s">P-S-S</h2>
<p>Primary with Two Secondary Members 是具有三个存储数据的成员的副本集部署模式，它包含：</p>
<ul>
<li>一个主节点 primary</li>
<li>两个副节点 secondary （每个副节点都可以被选举为主节点）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/71ff1feced2a2fa4d924c9ed148c4437.svg" alt="P-S-S" /></p>
<p>除 primary 成员外，P-S-S 部署始终提供数据集的两个完整副本。这些副本集提供了额外的容错能力和高可用性。 如果主服务器不可用，则副本集将 secondary 成员选为 primary 并继续正常操作。原本的 primary 在可用时会重新加入副本集。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a65dbacf011bf17efb8c12d1f8658b2f.svg" alt="elect" /></p>
<h1 id="环境准备">环境准备</h1>
<ul>
<li>系统系统：CentOS7 64位</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Replica Set Member</th>
<th>Hostname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>rs0-0</td>
<td>127.0.0.1:27017</td>
</tr>
<tr class="even">
<td>rs0-1</td>
<td>127.0.0.1:27018</td>
</tr>
<tr class="odd">
<td>rs0-2</td>
<td>127.0.0.1:27019</td>
</tr>
</tbody>
</table>
<h1 id="部署说明">部署说明</h1>
<p>下面将一个示例说明在单机部署一个 P-S-S 集群的流程。</p>
<h2 id="前提">前提</h2>
<p>对于测试和开发环境，您可以在本地系统或虚拟实例中运行 mongod 实例。</p>
<p>在部署副本集之前，必须在将成为副本集一部分的每个系统上安装 MongoDB。</p>
<p>每个成员都必须能够连接到其他每个成员。</p>
<h2 id="副本集名称">副本集名称</h2>
<p>此过程中的示例创建一个名为 rs0 的新副本集。</p>
<p>如果您的应用程序连接到多个副本集，则每个副本集应具有不同的名称。某些驱动程序通过副本集名称对副本集连接进行分组。</p>
<h2 id="基于命令行参数的部署">基于命令行参数的部署</h2>
<ol type="1">
<li><p>通过执行类似于下列示例的命令，为每个成员创建必要的数据目录，它们将存储 mongod 实例的数据库文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/rs0-0/data /srv/mongodb/rs0-1/data /srv/mongodb/rs0-2/data</span><br></pre></td></tr></table></figure></li>
<li><p>通过下列命令，在终端窗口中启动 mongod 实例：</p>
<p>启动第一个成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure>
<p>启动第二个成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27018 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-1/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure>
<p>启动第三个成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27019 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-2/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure>
<p>通过上面的启动，将使每个实例作为名为 rs0 的副本集的成员，每个副本集都在不同的端口上运行，并使用 <code>--dbpath</code> 设置指定数据目录的路径。如果您已经在使用建议的端口，请选择其他端口。</p>
<p>这些实例同时绑定到主机的 localhost 和 ip 地址。</p>
<p><code>--oplogSize</code> 设置减少了每个 mongod 实例使用的磁盘空间。这是测试和开发部署的理想选择，因为它可以防止计算机过载。有关此配置选项和其他配置选项的更多信息，请参阅 <a href="https://docs.mongodb.com/manual/reference/configuration-options/">配置文件选项</a>。</p></li>
<li><p>通过 mongo shell 连接到您的 mongod 实例之一。您需要通过指定其端口号来指示哪个实例。为了简单明了，直接连接第一个，如以下命令所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure></li>
<li><p>在 mongo shell 中，使用 <code>rs.initiate()</code> 初始化副本集。您可以在 mongo shell 环境中创建副本集配置对象，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsconf = &#123;</span><br><span class="line">  _id: &quot;rs0&quot;,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 0,</span><br><span class="line">     host: &quot;127.0.0.1:27017&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 1,</span><br><span class="line">     host: &quot;127.0.0.1:27018&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 2,</span><br><span class="line">     host: &quot;127.0.0.1:27019&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据实际情况替换为系统的主机名和端口，然后将 rsconf 文件传递给 <code>rs.initiate()</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate( rsconf )</span><br></pre></td></tr></table></figure></li>
<li><p>通过以下命令来显示当前 <a href="https://docs.mongodb.com/manual/reference/replica-configuration/">副本配置</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.conf()</span><br></pre></td></tr></table></figure>
<p>副本集配置对象类似于以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;rs0&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;protocolVersion&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">1</span>)<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;members&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27018&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27019&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;chainingAllowed&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;heartbeatIntervalMillis&quot;</span> <span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;heartbeatTimeoutSecs&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;electionTimeoutMillis&quot;</span> <span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;catchUpTimeoutMillis&quot;</span> <span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;getLastErrorModes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;getLastErrorDefaults&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;w&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;wtimeout&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;replicaSetId&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;598f630adc9053c6ee6d5f38&quot;</span>)</span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>随时使用 <code>rs.status()</code> 检查副本集的状态。</p>
<p>从运行该方法的成员的角度返回副本集状态。此方法为 <a href="https://docs.mongodb.com/manual/reference/command/replSetGetStatus/#dbcmd.replSetGetStatus">replSetGetStatus</a> 命令提供了包装。</p>
<p>此输出使用从副本集其他成员发送的心跳数据包派生的数据反映副本集的当前状态。</p></li>
</ol>
<h2 id="基于配置文件的部署">基于配置文件的部署</h2>
<p><a href="https://docs.mongodb.com/manual/reference/configuration-options/">https://docs.mongodb.com/manual/reference/configuration-options/</a></p>
<ol type="1">
<li><p>创建日志文件目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/rs0-0/log /srv/mongodb/rs0-1/log /srv/mongodb/rs0-2/log</span><br></pre></td></tr></table></figure></li>
<li><p>创建配置文件目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/conf</span><br></pre></td></tr></table></figure></li>
<li><p>创建每个成员的配置文件</p>
<p>第一个成员的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-0.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-0/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-0/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-0/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure>
<p>第二个成员的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-1.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-1/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-1/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-1/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27018</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure>
<p>第三个成员的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-2.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-2/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-2/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-2/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27019</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动副本集成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f /srv/mongodb/conf/rs0-0.conf</span><br><span class="line">mongod -f /srv/mongodb/conf/rs0-1.conf</span><br><span class="line">mongod -f /srv/mongodb/conf/rs0-2.conf</span><br></pre></td></tr></table></figure></li>
<li><p>查看 mongod 进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep mongod</span><br></pre></td></tr></table></figure>
<p>剩余初始副本集的步骤与上面命令行方式部署的操作相同。</p></li>
</ol>
<h1 id="启用身份验证">启用身份验证</h1>
<p>默认情况下，MongoDB 不会进行身份验证，也没有账号，只要能连接上服务就可以对数据库进行各种操作，出于安全角度考虑，我们应当为其添加认证访问。</p>
<p>通过 <code>--auth</code> 选项可以开启身份认证，此外，副本集设置身份验证与单机不同，需要增加一个 <code>keyFile</code> 以便副本集成员相互认证。</p>
<h2 id="创建一个用户">创建一个用户</h2>
<p>首先创建一个用于身份验证的用户，首先使用 mongo shell 连接到集群的 primary 节点，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure>
<p>切换到 admin 数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure>
<p>在 admin 下创建用户 root：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">  user: &quot;root&quot;,</span><br><span class="line">  pwd: &quot;toor&quot;,</span><br><span class="line">  roles: [</span><br><span class="line">    &#123;role: &quot;userAdminAnyDatabase&quot;, db:&quot;admin&quot;&#125;,</span><br><span class="line">    &#123;role: &quot;readWriteAnyDatabase&quot;, db: &quot;admin&quot;&#125;,</span><br><span class="line">    &#123;role:&quot;clusterAdmin&quot;, db:&quot;admin&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建-keyfile">创建 KeyFile</h2>
<p>这个文件需要满足下面几点要求：</p>
<ul>
<li>文本长度需要在 6 和 1024 之间</li>
<li>认证时候不考虑文件中空白字符</li>
<li>连接到副本集的成员和 mongos 进程的 keyfile 文件内容必须一样</li>
<li>必须是 base64 编码，但是不能有等号</li>
<li>文件权限必须是 X00，也就是说，不能分配任何权限给 group 成员和 other 成员</li>
</ul>
<p>我们可以在 Linux 上直接使用 openssl 创建一个这样的文件，然后上传至其他副本集成员服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 512 &gt; mongodb.key</span><br><span class="line">chmod 400 mongodb.key</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件">修改配置文件</h2>
<p>如果你是通过配置文件形式部署的副本集，那么需要修改对应成员的配置：</p>
<p>（假设 Key File 文件在 <code>/srv/mongodb</code> 目录下）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">keyFile:</span> <span class="string">/srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="attr">authorization:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure>
<p>如果你是直接通过命令行参数形式启动的副本集，那么需要使用 <code>--auth</code> 选项并指定 <code>--keyFile</code>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0 --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure>
<h2 id="测试密码认证">测试密码认证</h2>
<p>关闭三个 mongod 服务实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall mongod</span><br></pre></td></tr></table></figure>
<p>添加 <code>--auth</code> 和 <code>--keyFile</code> 选项重新启动 mongod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第一个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第二个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27018 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-1  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第三个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27019 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-2  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure>
<p>重启 mongodb ，第一次登陆时，直接查询会报权限错误，使用 <code>db.auth()</code> 认证后就可以成功读取数据库了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">rs0:PRIMARY&gt; db.auth(&#x27;root&#x27;, &#x27;toor&#x27;)</span><br><span class="line">1</span><br><span class="line">rs0:PRIMARY&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">test    0.000GB</span><br><span class="line">rs0:PRIMARY&gt;</span><br></pre></td></tr></table></figure>
<h1 id="问题">问题</h1>
<h2 id="初始化失败">初始化失败</h2>
<p>在初始化一个 MongoDB 副本集的过程中，出现了初始化失败，报 "No host described in new configuration 1 for replica set mongotest maps to this node"。具体报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rsconf = &#123;</span></span><br><span class="line">...   _id: &quot;rs0&quot;,</span><br><span class="line">...   members: [</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 0,</span><br><span class="line">...      host: &quot;0.0.0.0:27017&quot;</span><br><span class="line">...     &#125;,</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 1,</span><br><span class="line">...      host: &quot;0.0.0.0:27018&quot;</span><br><span class="line">...     &#125;,</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 2,</span><br><span class="line">...      host: &quot;0.0.0.0:27019&quot;</span><br><span class="line">...     &#125;</span><br><span class="line">...    ]</span><br><span class="line">... &#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rs.initiate( rsconf )</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;operationTime&quot; : Timestamp(0, 0),</span><br><span class="line">        &quot;ok&quot; : 0,</span><br><span class="line">        &quot;errmsg&quot; : &quot;No host described in new configuration 1 for replica set rs0 maps to this node&quot;,</span><br><span class="line">        &quot;code&quot; : 93,</span><br><span class="line">        &quot;codeName&quot; : &quot;InvalidReplicaSetConfig&quot;,</span><br><span class="line">        &quot;$clusterTime&quot; : &#123;</span><br><span class="line">                &quot;clusterTime&quot; : Timestamp(0, 0),</span><br><span class="line">                &quot;signature&quot; : &#123;</span><br><span class="line">                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),</span><br><span class="line">                        &quot;keyId&quot; : NumberLong(0)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，将 rsconf 中的 IP 替换为真正的 IP，如：127.0.0.1。</p>
<h2 id="开启认证后-secondary-读取失败">开启认证后 SECONDARY 读取失败</h2>
<p>"errmsg" : "not master and slaveOk=false" 的解决办法参考：</p>
<p><a href="https://stackoverflow.com/questions/8990158/mongodb-replicates-and-error-err-not-master-and-slaveok-false-code">https://stackoverflow.com/questions/8990158/mongodb-replicates-and-error-err-not-master-and-slaveok-false-code</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs0:SECONDARY&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">rs0:SECONDARY&gt; db.auth(&#x27;root&#x27;, &#x27;toor&#x27;)</span><br><span class="line">1</span><br><span class="line">rs0:SECONDARY&gt; show dbs</span><br><span class="line">2020-03-30T12:03:51.218+0800 E  QUERY    [js] uncaught exception: Error: listDatabases failed:&#123;</span><br><span class="line">        &quot;operationTime&quot; : Timestamp(1585541025, 1),</span><br><span class="line">        &quot;ok&quot; : 0,</span><br><span class="line">        &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">        &quot;code&quot; : 13435,</span><br><span class="line">        &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,</span><br><span class="line">        &quot;$clusterTime&quot; : &#123;</span><br><span class="line">                &quot;clusterTime&quot; : Timestamp(1585541025, 1),</span><br><span class="line">                &quot;signature&quot; : &#123;</span><br><span class="line">                        &quot;hash&quot; : BinData(0,&quot;DHLkVZz2fe4aeAjIxEmkHu9FhBE=&quot;),</span><br><span class="line">                        &quot;keyId&quot; : NumberLong(&quot;6809843876723949571&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; :</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">Mongo.prototype.getDBs/&lt;@src/mongo/shell/mongo.js:135:19</span><br><span class="line">Mongo.prototype.getDBs@src/mongo/shell/mongo.js:87:12</span><br><span class="line">shellHelper.show@src/mongo/shell/utils.js:906:13</span><br><span class="line">shellHelper@src/mongo/shell/utils.js:790:15</span><br><span class="line">@(shellhelp2):1:1</span><br><span class="line">rs0:SECONDARY&gt; rs.slaveOk()</span><br><span class="line">rs0:SECONDARY&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">rs0:SECONDARY&gt;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://docs.mongodb.com/manual/reference/configuration-options/">https://docs.mongodb.com/manual/reference/configuration-options/</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-replication/index.html">https://www.ibm.com/developerworks/cn/opensource/os-mongodb-replication/index.html</a></p>
<p><a href="https://docs.mongodb.com/manual/core/retryable-writes/#retryable-writes">https://docs.mongodb.com/manual/core/retryable-writes/#retryable-writes</a></p>
<p><a href="https://docs.mongodb.com/manual/reference/configuration-file-settings-command-line-options-mapping/#conf-file-command-line-mapping">Configuration File Settings and Command-Line Options Mapping</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>replica-set</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题博客接入谷歌广告</title>
    <url>/posts/9d582ac3/</url>
    <content><![CDATA[<p>本文将向你展示 Hexo + NexT 主题博客如何接入 Google 广告联盟 Google Adsense</p>
<span id="more"></span>
<h1 id="前提">前提</h1>
<ul>
<li>使用 Hexo 和 NexT 主题搭建博客</li>
<li>可以登录 Google Adsense 网站（科学上网）</li>
</ul>
<h1 id="注册账号">注册账号</h1>
<p><a href="https://www.google.com/adsense/">Google Adsense</a></p>
<h1 id="向网站列表添加新网站">向网站列表添加新网站</h1>
<p>要在新网站上展示广告或设置网站级屏蔽规则，首先需要先将相应网站添加到您的网站列表中。</p>
<h2 id="添加新网站">添加新网站</h2>
<ol type="1">
<li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li>
<li>点击 <strong>网站</strong>。</li>
<li>点击 <strong>添加网站</strong>。</li>
<li>输入您网站的网址。</li>
<li><p><strong>将您的网站关联到 AdSense</strong>。</p>
<p>将代码复制并粘贴到网页的 HTML 中，放置在 <code>&lt;head&gt;</code> 和 <code>&lt;/head&gt;</code> 标签之间。</p>
<p>使用 Hexo + NexT 搭建的博客站点，只要将 Google 提供的 AdSense 代码添加到 <code>/themes/next/layout/_partials/head/head.swig</code> 文件末尾即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script data-ad-client=<span class="string">&quot;ca-pub-5699403938610067&quot;</span> <span class="keyword">async</span> src=<span class="string">&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>以下是添加了代码的 HTML 网页示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">&quot;ca-pub-5699403938610067&quot;</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">This is the head of your page.</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">This is the body of your page.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>点击 <strong>完成</strong>。 Google AdSense 会审核您的网站是否可以开始展示广告。</p></li>
</ol>
<h2 id="审核网站是否已可以开始展示广告">审核网站是否已可以开始展示广告</h2>
<p>添加新网站后，Google AdSense 会检查以确保您的网站已可以开始展示广告。它将验证您是否是网站所有者以及您的网站是否符合 AdSense 合作规范。通常，此过程几天之内就能完成，但在某些情况下最长可能需要 2 周时间。Google AdSense 会在审核完毕并确认您的网站可以开始展示广告后通知您。</p>
<h1 id="放置广告">放置广告</h1>
<p>根据站点的结构设计和选择广告的投放位置，目前 Google AdSense 主要提供了 <strong>按网站</strong> 和 <strong>按广告单元</strong>* 两种形式的广告添加方式。</p>
<h2 id="按网站自动广告">按网站（自动广告）</h2>
<p><a href="https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304&amp;visit_id=637240760139765363-4192744759&amp;rd=1">自动广告</a>是 Google AdSense 近来提供的一种广告形式，它自动会分析您的网页，然后根据您的布局、内容和现有 Google 广告找到新位置来展示广告。您只需放置一段广告代码即可开始使用。在您放置代码后，自动广告会根据您对网站和广告设置所做的任何更改自动进行调整。自动广告可自动调整以适应每种屏幕尺寸。</p>
<h3 id="前期准备">前期准备</h3>
<p>确保您的网站已列入广告页面。如未列入，您需要在设置自动广告之前，将相应网站添加到您的网站列表中。</p>
<h3 id="设置自动广告">设置自动广告</h3>
<ol type="1">
<li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li>
<li>点击 <strong>广告</strong> 接着点击 <strong>概览</strong>。</li>
<li>在汇总了您所有网站的表格中，点击相应网站旁边的“修改”图标 修改。该网站就会在<a href="https://support.google.com/adsense/answer/9262310">广告设置预览模式</a>下打开。
<ul>
<li>提示：在自动广告投放之前，您可以使用预览功能尝试不同的广告设置。</li>
</ul></li>
<li>在“网站设置”下，启用 <strong>自动广告</strong>。</li>
<li>（可选）如果您想让 Google 为您一起优化广告单元和自动广告，并在效果最佳的广告展示位置上投放广告，请启用 <strong>优化您现有的广告单元</strong> 选项。
<ul>
<li>注意：此设置目前尚未启用。启用此设置意味着您愿意让 Google 在日后为您优化现有广告单元。</li>
</ul></li>
<li>（可选）点击 <strong>广告格式</strong> 可关闭页内广告和重叠式广告，或开启页面中的匹配内容。详细了解广告格式和匹配内容设置。</li>
<li>（可选）点击 <strong>广告投放量</strong>，然后使用滑块控制您在网页上展示的广告数量。了解如何为自动广告选择广告投放量。</li>
<li>（可选）在“排除的网页”部分中，点击 <strong>管理</strong> 可<a href="https://support.google.com/adsense/answer/9262311">阻止特定网页展示自动广告</a>。</li>
<li>点击 <strong>应用到网站</strong>。</li>
</ol>
<p><strong>注意</strong>：确保您已将 AdSense 代码放置到您网站的每个网页上。广告最多可能需要一个小时才会展示在网页上。</p>
<h2 id="按广告单元">按广告单元</h2>
<p><a href="https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242">广告单元</a>是指在同一段 AdSense 广告代码的作用下显示出来的一个或多个 Google 广告。您可以在 AdSense 帐号的广告页面上创建、自定义和管理广告单元。利用广告单元，您可以掌控广告的展示位置；利用原生广告单元，您可以更灵活地进行自定义设置。</p>
<h3 id="广告单元的类型">广告单元的类型</h3>
<p>AdSense 提供多种不同类型的广告单元。如果展示广告单元不符合您网站的要求，不妨试试其他更具特色的广告单元：</p>
<ul>
<li><a href="https://support.google.com/adsense/topic/9183360">展示广告单元</a>
<ul>
<li>这种格式的广告适用范围广，在任何空间都能投放。</li>
<li>默认情况下，展示广告属于自适应广告，也就是说它们会自动根据您的页面布局和用户的设备屏幕调整自身尺寸。</li>
<li>这种格式的广告可进行自定义，以显示固定尺寸的广告。</li>
<li>此外，这种格式的广告还与 AMP 网页兼容。</li>
</ul></li>
<li><a href="https://support.google.com/adsense/topic/9183582">信息流广告单元</a>
<ul>
<li>在信息流（例如，文章或产品列表）内投放的原生广告，看起来十分自然，可提供良好的用户体验。</li>
</ul></li>
<li><a href="https://support.google.com/adsense/topic/9183594">文章内嵌广告单元</a>
<ul>
<li>完美融入网页段落之间的原生广告，可增强用户的阅读体验。</li>
</ul></li>
<li><a href="https://support.google.com/adsense/topic/9185053">匹配内容单元</a>
<ul>
<li>一种内容推荐功能，可向网站访问者宣传您的内容，有望提升收入、网页浏览量并延长用户在网站上停留的时间。</li>
</ul></li>
</ul>
<h3 id="展示广告推荐">展示广告（推荐）</h3>
<p>使用范围广，在任何空间都能投放。</p>
<p>要新建可在您的帐号中管理的展示广告单元，请按以下步骤操作：</p>
<ol type="1">
<li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li>
<li>点击 <strong>广告</strong> 接着点击 <strong>概览</strong>。</li>
<li>点击 <strong>“按广告单元”</strong>。</li>
<li>点击 <strong>展示广告</strong>。</li>
<li>为此广告单元命名。建议您使用具有唯一性的描述性名称，便于您今后轻松找到此广告单元。</li>
<li>在“广告尺寸”部分，选择您想要展示的广告的尺寸：
<ul>
<li>建议您将 <strong>自适应</strong> 选项保持选中状态。自适应广告会自动根据您的页面布局和用户的设备屏幕调整自身尺寸。详细了解<a href="https://support.google.com/adsense/answer/9183362">展示广告单元的自适应行为</a>。</li>
<li>如果您更倾向于自行指定在您的网页上展示何种尺寸的广告，请选择 <strong>固定尺寸</strong>，然后输入所需的宽度和高度。请注意，固定尺寸的广告单元可投放的广告数量可能较少，因而所创造的收入也可能不如采用自适应尺寸的广告单元。有关详情，请参阅<a href="https://support.google.com/adsense/answer/9185043">固定尺寸的展示广告单元指南</a>。</li>
<li>提示：不妨参阅<a href="https://support.google.com/google-ads/answer/7031480">最常见的固定广告尺寸</a>示例。</li>
</ul></li>
<li>点击 <strong>保存并获取代码</strong>。</li>
<li>复制广告单元代码并将其粘贴在要展示广告的网页上，放在 <code>&lt;body&gt;&lt;body/&gt;</code> 标记之间。</li>
<li>点击完成。</li>
</ol>
<p>通常，广告只需几分钟便会展示在网页上，但有时也可能会需要长达一个小时。如果一小时后广告仍未展示，请前往 <strong>网站</strong> 页面<a href="https://support.google.com/adsense/answer/9128461">查看您的网站是否处于“准备就绪”状态</a>。</p>
<h3 id="信息流广告">信息流广告</h3>
<p>与您网站的外观浑然一体，可以自然地展示在推送的文章资讯以及连续显示的产品或服务介绍之间。</p>
<p>您可以通过两种方式创建信息流广告单元。最简便快捷的方法是让 Google 扫描您的网页，然后自动为您制作广告。另外，您也可以手动制作信息流广告。</p>
<p>注意：如果您的信息流是纯文本，请使用手动方法制作信息流广告。</p>
<ol type="1">
<li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li>
<li>点击 <strong>广告</strong>。</li>
<li>点击 <strong>广告单元</strong>。</li>
<li>选择 <strong>信息流广告</strong>。</li>
<li>选择要如何制作信息流广告：
<ul>
<li>让 Google 提供样式建议（推荐）</li>
<li>手动创建广告样式</li>
</ul></li>
<li>复制信息流广告代码并粘贴到您网站上信息流的 HTML 中。</li>
</ol>
<p>制作信息流广告详情参考 <a href="https://support.google.com/adsense/answer/9185051?hl=zh-Hans">https://support.google.com/adsense/answer/9185051?hl=zh-Hans</a></p>
<h3 id="文章内嵌广告">文章内嵌广告</h3>
<p>同样与您的网站浑然一体，与文章和内容页面完美融合。</p>
<p>要创建文章内嵌广告单元，请按以下步骤操作：</p>
<ol type="1">
<li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li>
<li>点击 <strong>广告</strong>。</li>
<li>点击 <strong>广告单元</strong>。</li>
<li>点击 <strong>文章内嵌广告</strong>。</li>
<li>为文章内嵌广告单元指定名称。
<ul>
<li>建议您为文章内嵌广告单元的名称添加诸如“Native”（“原生”）之类的前缀，以帮助您跟踪其效果。</li>
</ul></li>
<li>设置您的广告样式，使其与您的内容相匹配。如需了解详情，请参阅<a href="https://support.google.com/adsense/answer/9189960">文章内嵌广告设置</a>。</li>
<li>通过在预览区域更改容器宽度，测试您的广告在不同尺寸屏幕上的外观。使用拖动手柄更改宽度。</li>
<li>点击 <strong>保存并获取代码</strong>。</li>
<li>复制文章内嵌广告代码并将其粘贴到您网站网页的 HTML 中。 建议在文章前两段下方放置代码。</li>
</ol>
<p><strong>重要提示：</strong>如果您想在网页上放置多个文章内嵌广告，请务必在广告之间放置足够的内容，尽可能避免对读者形成干扰。</p>
<p>文章内嵌自适应广告尺寸：</p>
<p>请注意，默认情况下文章内嵌广告属于自适应广告，也就是说它们可根据观看设备自动调整尺寸。在处于纵向模式的移动设备上，文章内嵌广告会展开以占据用户屏幕的整个宽度。在桌面设备和采用其他配置模式的移动设备上，文章内嵌广告的宽度始终等于其所在的父级容器（<code>&lt;div&gt;</code>、<code>&lt;iframe&gt;</code> 等）的宽度。（请注意，文章内嵌广告的最小宽度为 250 像素）。AdSense 会自动调整文章内嵌广告的高度。</p>
<h2 id="next-广告代码插入位置">NexT 广告代码插入位置</h2>
<p>由于是博客网站，所以第二种信息流广告没有投入使用，这里主要使用了第一种和第三种。这里，提供几种针对 Hexo NexT 主题广告代码插入位置的操作:</p>
<h3 id="创建-google-adsense.swig">创建 google-adsense.swig</h3>
<p>首先在 <code>themes/next/layout/_custom</code> 目录下，新建 google-adsense.swig 文件，并将对应广告单元的代码插入其中。</p>
<p>然后在需要展示广告的位置插入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入评论区">插入评论区</h3>
<p>将下列代码插入 <code>themes/next/layout/_partials/comments.swig</code> 文件末尾即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入侧边栏">插入侧边栏</h3>
<p>将下列代码插入 <code>themes/next/layout/_macro/sidebar.swig</code> 文件中 <code>&lt;div class=”sidebar-inner”&gt;&lt;/div&gt;</code> 的最下侧即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-inner&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  &#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插入文章中">插入文章中</h3>
<p>编辑 <code>themes/next/layout/_macro/post.swig</code> 文件，将下面的 include 语句添加到 post body 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#################&#125;</span><br><span class="line">&#123;### POST BODY ###&#125;</span><br><span class="line">&#123;#################&#125;</span><br><span class="line">&lt;div class=&quot;post-body&#123;%- if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;%- endif %&#125;&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">  &#123;%- if is_index %&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">      &#123;&#123; post.content &#125;&#125;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br><span class="line">    &#123;&#123; post.content &#125;&#125;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意事项">注意事项</h1>
<p>在成功接入 AdSense 广告之后，并不算结束，Google 会根据几种方式和数据判断广告点击是否作弊，从而注销你的账号。</p>
<ul>
<li>作弊广告点击者的 IP 地址与你 Adsense 账户登录 IP 地址相同</li>
<li>作弊广告点击的 CTR 数据太高</li>
<li>作弊广告点击者的 IP 地址来自同一个地理区域</li>
<li>根据 Cookies 判断作弊 Adsense 广告点击</li>
<li>作弊广告点击者页面停留时间太短</li>
<li>直接访问者的广告点击率过高</li>
<li>流量小但广告点击率高</li>
<li>在网页上用文字提示请求鼓动点击广告</li>
</ul>
<h1 id="references">References</h1>
<p><a href="https://support.google.com/adsense/answer/9130038">https://support.google.com/adsense/answer/9130038</a></p>
<p><a href="https://support.google.com/adsense/answer/9261307?hl=zh-Hans&amp;ref_topic=9261304">https://support.google.com/adsense/answer/9261307?hl=zh-Hans&amp;ref_topic=9261304</a></p>
<p><a href="https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304">https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304</a></p>
<p><a href="https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242">https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>python 自定义比较函数</title>
    <url>/posts/8100d913/</url>
    <content><![CDATA[<p>Python 列表具有内置的 list.sort() 方法，该方法可就地修改列表。还有一个 sorted() 内置函数，可从迭代器构建新的排序列表。</p>
<p>因为 Python3 中 sorted() 和 list.sort() 放弃了类似 C++ 中的 cmp 写法，本文将展示官方推荐替代解决方案，以实现自定义的两个参数的比较函数，并详细分析了 cmp_to_key 函数实现原理。</p>
<span id="more"></span>
<h1 id="排序基础">排序基础</h1>
<p>一个简单的升序排序非常容易：只需调用 sorted() 函数即可。它返回一个新的排序列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([5, 2, 3, 1, 4])</span></span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>你也可以使用 list.sort() 方法。它就地修改列表（并返回 None 以避免混淆）。通常，它不如 sorted() 方便（如果你不需要原始列表，则效率会略高一些）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = [5, 2, 3, 1, 4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.sort()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a</span></span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>另一个区别是 list.sort() 方法仅为列表定义。而 sorted() 函数接受任何可迭代的对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted(&#123;1: <span class="string">&#x27;D&#x27;</span>, 2: <span class="string">&#x27;B&#x27;</span>, 3: <span class="string">&#x27;B&#x27;</span>, 4: <span class="string">&#x27;E&#x27;</span>, 5: <span class="string">&#x27;A&#x27;</span>&#125;)</span></span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<h1 id="key-functions">Key Functions</h1>
<p>list.sort() 和 sorted() 都有一个 key 参数，用于指定在进行比较之前在每个列表元素上要调用的函数。例如，这是不区分大小写的字符串比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted(<span class="string">&quot;This is a test string from Andrew&quot;</span>.<span class="built_in">split</span>(), key=str.lower)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;Andrew&#x27;, &#x27;from&#x27;, &#x27;is&#x27;, &#x27;string&#x27;, &#x27;test&#x27;, &#x27;This&#x27;]</span><br></pre></td></tr></table></figure>
<p><strong>key 参数的值应该是一个采用单个参数并返回用于排序目的的键的函数。</strong> 这种技术之所以快捷，是因为对于每个输入记录，key function 都只被调用一次。</p>
<p>一种常见的模式是使用某些对象的索引作为键来对复杂的对象进行排序。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; student_tuples = [</span></span><br><span class="line">...     (&#x27;john&#x27;, &#x27;A&#x27;, 15),</span><br><span class="line">...     (&#x27;jane&#x27;, &#x27;B&#x27;, 12),</span><br><span class="line">...     (&#x27;dave&#x27;, &#x27;B&#x27;, 10),</span><br><span class="line">... ]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted(student_tuples, key=lambda student: student[2])   <span class="comment"># sort by age</span></span></span><br><span class="line">[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)]</span><br></pre></td></tr></table></figure>
<p>具有命名属性的对象也可以使用相同的技术。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; class Student:</span></span><br><span class="line">...     def __init__(self, name, grade, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.grade = grade</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def __repr__(self):</span><br><span class="line">...         return repr((self.name, self.grade, self.age))</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; student_objects = [</span></span><br><span class="line">...     Student(&#x27;john&#x27;, &#x27;A&#x27;, 15),</span><br><span class="line">...     Student(&#x27;jane&#x27;, &#x27;B&#x27;, 12),</span><br><span class="line">...     Student(&#x27;dave&#x27;, &#x27;B&#x27;, 10),</span><br><span class="line">... ]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted(student_objects, key=lambda student: student.age)   <span class="comment"># sort by age</span></span></span><br><span class="line">[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)]</span><br></pre></td></tr></table></figure>
<h1 id="为什么取消-cmp-参数">为什么取消 cmp 参数</h1>
<p>所有 Py2.x 版本都支持 cmp 参数来处理用户指定的比较功能。</p>
<p>在 Py3.0 中，完全删除了 cmp 参数（这是简化和统一语言的较大工作的一部分，从而消除了丰富的比较与 <code>__cmp__()</code> 魔术方法之间的冲突）。</p>
<h1 id="在-py2.x-中使用-cmp-参数">在 Py2.x 中使用 cmp 参数</h1>
<p>Py2.x 中，sort 允许一个可选函数，可以进行比较。该函数应该接受两个参数进行比较，如果是小于等于的返回负值，如果相等则返回零，如果是大于等于的返回正值。例如，我们可以做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def numeric_compare(x, y):</span></span><br><span class="line">...     return x - y</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)</span></span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>或者，你可以通过以下方式反转比较顺序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def reverse_numeric(x, y):</span></span><br><span class="line">...     return y - x</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)</span></span><br><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<h1 id="使用-cmp_to_key-函数实现自定义比较函数">使用 <code>cmp_to_key</code> 函数实现自定义比较函数</h1>
<p>当将代码从 Python 2.x 移植到 3.x 时，如果你有使用自定义比较功能的函数，需要将其转换为 Key function，我们可以使用 functools 提供的 <code>cmp_to_key()</code> 来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp_to_key</span>(<span class="params">mycmp</span>):</span><br><span class="line">    <span class="string">&#x27;Convert a cmp= function into a key= function&#x27;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">K</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj, *args</span>):</span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure>
<p>要转换为 Key Function，只需包装旧的比较函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from functools import cmp_to_key</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))</span></span><br><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<p>在 Python 3.2 中，<code>functools.cmp_to_key()</code> 函数已添加到标准库的 functools 模块中。</p>
<h1 id="理解-cmp_to_key-函数">理解 cmp_to_key 函数</h1>
<p>如果你明白了 Key Function 的作用，那么再看 cmp_to_key 的代码就非常容易理解了。</p>
<p>cmp_to_key 接收一个比较函数作为内部类实例比较时执行的函数，并返回这个类。根据 <code>key=com_to_key(mycmp)</code> 可以知道最终作为 Key Function 的是一个类，这个类就是 cmp_to_key 返回的类 <code>K</code>。因为 Key Function 是作用在可迭代对象的每个元素上的，那么这个类又是怎么作用到每个元素的呢。</p>
<p>这里，你可能需要明确一点，Key Function 允许接受的来源不一定是函数，实际上它可以接受一切可调用对象，而类也是一个可调用对象。</p>
<p>据 "流畅的python" 中关于可调用对象的描述，类是 Python 数据模型文档列出的 7 种可调用对象中的一种：</p>
<blockquote>
<p>调用类时会运行类的 <code>__new__</code> 方法创建一个实例，然后运行 <code>__init__</code> 方法，初始化实例，最后把实例返回给调用方。因为 Python 没有 new 运算符，所以调用类相当于调用函数。（通常，调用类会创建 那个类的实例，不过覆盖 <code>__new__</code> 方法的话，也可能出现其他行为。）</p>
</blockquote>
<p>到此，我们可以知道 cmp_to_key 函数返回的类作用到每个元素的结果了，这个类的作用结果就是：创建一个 <code>K</code> 类的实例，这个实例接收当前作用元素进行初始化，返回初始化后的实例。</p>
<p>在 K 类的实例间进行比较时，就会调用相应的特殊方法，如 <code>&lt;</code> 将调用 <code>__lt__</code> 方法，而 <code>K</code> 类实现的 <code>__lt__</code> 将使用我们自己定义的函数进行比较。</p>
<h1 id="references">References</h1>
<p><a href="https://docs.python.org/3/howto/sorting.html#sortinghowto">https://docs.python.org/3/howto/sorting.html#sortinghowto</a></p>
]]></content>
      <categories>
        <category>programming-language</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>远程连接MongoDB</title>
    <url>/posts/7043b2c8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/74a90895f17097ef8c1a4fe90737282c.png" alt="robo3t" /></p>
<span id="more"></span>
<h1 id="配置远程连接-mongodb">配置远程连接 MongoDB</h1>
<h2 id="ip-绑定">IP 绑定</h2>
<p>默认情况下，MongoDB 启动时将 <code>bindIp</code> 设置为 <code>127.0.0.1</code>，绑定到 localhost 网络接口。这意味着 mongod 只能接受来自同一计算机上运行的客户端的连接。远程客户端将无法连接到 mongod，并且 mongod将无法初始化副本集，除非将此值设置为有效的网络接口。</p>
<p>可以一下两种方式配置绑定的 IP：</p>
<ul>
<li>在带有 <code>bindIp</code> 的 MongoDB 配置文件中（默认 /etc/mongod.conf）</li>
<li>或者通过命令行参数 <code>--bind_ip</code></li>
</ul>
<blockquote>
<p>WARNING</p>
<p>Before binding to a non-localhost (e.g. publicly accessible) IP address, ensure you have secured your cluster from unauthorized access. For a complete list of security recommendations, see <a href="https://docs.mongodb.com/manual/administration/security-checklist/">Security Checklist</a>. At minimum, consider <a href="https://docs.mongodb.com/manual/administration/security-checklist/#checklist-auth">enabling authentication</a> and <a href="https://docs.mongodb.com/manual/core/security-hardening/">hardening network infrastructure</a>.</p>
</blockquote>
<h2 id="端口绑定">端口绑定</h2>
<p>端口默认绑定到 27017，可以根据需要进行配置，配置方法与配置 IP 绑定类似。</p>
<ul>
<li>在带有 <code>port</code> 的 MongoDB 配置文件中（默认 /etc/mongod.conf）</li>
<li>或者通过命令行参数 <code>--port</code></li>
</ul>
<h2 id="不启用认证">不启用认证</h2>
<p>在不启用认证的情况下，要想远程连接到 MongoDB，需要将 IP 绑定到 <code>0.0.0.0</code>，以修改配置文件为例，编辑 /etc/mongod.conf 文件：</p>
<p>将 <code>bindIp: 127.0.0.1</code> 替换为 <code>bindIp: 0.0.0.0</code></p>
<p>修改完成后，重启 mongod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mongod</span><br></pre></td></tr></table></figure>
<p><strong>如果你的防火墙对端口有限制，请关闭防火墙或开放相应的端口。</strong></p>
<h2 id="启用认证">启用认证</h2>
<p>不需要认证的远程连接方式具有很大的安全风险，所以一般远程连接都采用认证的方式。</p>
<p>启用访问控制时，请确保你在管理数据库中拥有一个具有 userAdmin 或 userAdminAnyDatabase 角色的用户。该用户可以管理用户和角色，例如：创建用户，向用户授予或撤消角色，以及创建或修改自定义角色。</p>
<p><strong>启用认证的简要步骤：</strong></p>
<ul>
<li>不启用访问控制的情况下运行 MongoDB</li>
<li>使用 mongo shell 连接到运行的 mongod 实例</li>
<li>创建一个具有 userAdmin 或 userAdminAnyDatabase 角色的用户</li>
<li>启用访问控制</li>
<li>重启 MongoDB</li>
</ul>
<p>以上步骤假定你的管理数据库中没有一个具有 userAdmin 或 userAdminAnyDatabase 角色的用户。</p>
<h3 id="创建一个认证用户">创建一个认证用户</h3>
<p>下面将创建一个具有 userAdmin 或 userAdminAnyDatabase 角色的用户 myUserAdmin。</p>
<h4 id="不启用访问控制的情况下启动-mongodb">(1) 不启用访问控制的情况下启动 MongoDB</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --port 27017 --dbpath /var/lib/mongodb</span><br></pre></td></tr></table></figure>
<p><strong>你可以使用 systemd 的方式启动管理 mongod：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mongod</span><br></pre></td></tr></table></figure>
<h4 id="连接到-mongodb-运行的实例">(2) 连接到 MongoDB 运行的实例</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure>
<h4 id="创建管理员用户-root">(3) 创建管理员用户 root</h4>
<p>在 mongo shell 中，在 admin 数据库中添加一个具有 userAdminAnyDatabase 角色的用户。包括此用户所需的其他角色。例如，以下代码在 admin 数据库中使用 userAdminAnyDatabase 角色和 readWriteAnyDatabase 角色创建用户 myUserAdmin。</p>
<blockquote>
<p>TIP</p>
<p>Starting in version 4.2 of the <a href="https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo"><code>mongo</code></a> shell, you can use the <a href="https://docs.mongodb.com/manual/reference/method/passwordPrompt/#passwordPrompt"><code>passwordPrompt()</code></a> method in conjunction with various user authentication/management methods/commands to prompt for the password instead of specifying the password directly in the method/command call. However, you can still specify the password directly as you would with earlier versions of the <a href="https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo"><code>mongo</code></a> shell.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;myUserAdmin&quot;,</span><br><span class="line">    pwd: passwordPrompt(), // or cleartext password</span><br><span class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125;, &quot;readWriteAnyDatabase&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE</p>
<p>The database where you create the user (in this example, <code>admin</code>) is the user’s <a href="https://docs.mongodb.com/manual/core/security-users/#user-authentication-database">authentication database</a>. Although the user would authenticate to this database, the user can have roles in other databases; i.e. the user’s authentication database does not limit the user’s privileges.</p>
</blockquote>
<h4 id="启用访问控制重启-mongodb">(4) 启用访问控制重启 MongoDB</h4>
<ul>
<li><p>关闭 mongod 实例。例如，在 mongo shell 中，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.adminCommand( &#123; shutdown: 1 &#125; )</span><br></pre></td></tr></table></figure></li>
<li><p>退出 mongo shell</p></li>
<li><p>在终端上，使用 <code>--auth</code> 命令行选项重新启动 mongod 实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --auth --port 27017 --dbpath /var/lib/mongodb</span><br></pre></td></tr></table></figure>
<p>现在，连接到该实例的客户端必须将自己认证为 MongoDB 用户。客户只能执行由其分配的角色确定的操作。</p></li>
</ul>
<p><strong>如果你是通过 systemd 的方式利用配置文件启动的：</strong></p>
<ul>
<li><p>创建完认证用户后，退出 mongo shell</p></li>
<li><p>编辑配置文件 /etc/mongod.conf</p>
<p>在 security 下添加 authorization，删除 security 前面的注释符号 <code>#</code>，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure></li>
<li><p>重启 mongod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mongod</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="以用户管理员身份连接并进行身份验证">(5) 以用户管理员身份连接并进行身份验证</h4>
<p>使用 mongo shell，你可以：</p>
<ul>
<li>通过连接时传递用户凭据以验证身份</li>
<li>或首先连接而不进行身份验证，然后通过 <code>db.auth()</code> 方法进行身份验证</li>
</ul>
<p><strong>连接时认证：</strong></p>
<p>使用 <a href="https://docs.mongodb.com/manual/reference/program/mongo/#cmdoption-mongo-username"><code>-u</code></a>, <a href="https://docs.mongodb.com/manual/reference/program/mongo/#cmdoption-mongo-password"><code>-p</code></a>, 和 <a href="https://docs.mongodb.com/manual/reference/program/mongo/#cmdoption-mongo-authenticationdatabase"><code>--authenticationDatabase</code></a> 命令行选项启动 mongo shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017  --authenticationDatabase &quot;admin&quot; -u &quot;myUserAdmin&quot; -p</span><br></pre></td></tr></table></figure>
<p>出现提示时输入密码。</p>
<p><strong>连接后认证：</strong></p>
<p>将 mongo shell 连接到 mongod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure>
<p>在 mongo shell 中，切换到身份验证数据库（在本例中为 admin），然后使用 <a href="https://docs.mongodb.com/manual/reference/method/db.auth/#db.auth"><code>db.auth(&lt;username&gt;, &lt;pwd&gt;)</code></a>方法进行身份验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(&quot;myUserAdmin&quot;, passwordPrompt()) // or cleartext password</span><br></pre></td></tr></table></figure>
<h4 id="根据部署需要创建其他用户">(6) 根据部署需要创建其他用户</h4>
<p>通过身份验证为用户管理员后，可以使用 <a href="https://docs.mongodb.com/manual/reference/method/db.createUser/#db.createUser"><code>db.createUser()</code></a> 创建其他用户。你可以将任何 <a href="https://docs.mongodb.com/manual/reference/built-in-roles/">built-in roles</a> 或 <a href="https://docs.mongodb.com/manual/core/security-user-defined-roles/">user-defined roles</a> 分配给用户。</p>
<p>以下操作将用户 myTester 添加到 test 数据库，该用户在 test 数据库中具有 <a href="https://docs.mongodb.com/manual/reference/built-in-roles/#readWrite"><code>readWrite</code></a> 角色，在 reporting 数据库中具有 <a href="https://docs.mongodb.com/manual/reference/built-in-roles/#read"><code>read</code></a> 角色。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;myTester&quot;,</span><br><span class="line">    pwd:  passwordPrompt(),   // or cleartext password</span><br><span class="line">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;,</span><br><span class="line">             &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建其他用户后，断开 mongo shell 的连接。</p>
<h4 id="连接到实例并通过-mytester-进行身份验证">(7) 连接到实例并通过 myTester 进行身份验证</h4>
<p>以 myUserAdmin 断开 mongo shell 的连接后，以 myTester 的身份重新连接。你可以：</p>
<p>连接时验证身份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017 -u &quot;myTester&quot; --authenticationDatabase &quot;test&quot; -p</span><br></pre></td></tr></table></figure>
<p>或者连接后验证身份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">db.auth(&quot;myTester&quot;, passwordPrompt())  // or cleartext password</span><br></pre></td></tr></table></figure>
<p>出现提示时输入密码。</p>
<h4 id="作为-mytester-插入文档">(8) 作为 myTester 插入文档</h4>
<p>作为 myTester，你有权在 test 数据库中执行读取和写入操作（以及在 reporting 数据库中执行读取操作）。 通过 myTester 身份验证后，将文档插入 test 数据库的集合中。例如，你可以在测试数据库中执行以下插入操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.foo.insert( &#123; x: 1, y: 1 &#125; )</span><br></pre></td></tr></table></figure>
<h1 id="robo-3t-远程连接-mongodb">robo 3t 远程连接 MongoDB</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c3a83f29cb3ce61063b69faa7d241245.png" alt="robo3t-connection" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/494ef8a5da007d7d7d116f1321a9f631.png" alt="robo3t-authentication" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/808f1a4900a943ead09686433051e1c1.png" alt="robo3t-test" /></p>
<h1 id="references">References</h1>
<p><a href="https://docs.mongodb.com/manual/tutorial/enable-authentication/">https://docs.mongodb.com/manual/tutorial/enable-authentication/</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>robo3t</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装及卸载MongoDB</title>
    <url>/posts/696d9dac/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1fe9c6f8b2d85e81b79e17c93396ad4c.jpg" alt="mongodb" /></p>
<span id="more"></span>
<h1 id="安装-mongodb-社区版本">安装 MongoDB 社区版本</h1>
<h2 id="配置-yum-包管理系统">配置 yum 包管理系统</h2>
<p>创建 <code>/etc/yum.repos.d/mongodb-org-4.2.repo</code> 文件，这样你就可以使用 yum 安装 MongoDB，文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mongodb-org-4.2]</span></span><br><span class="line"><span class="attr">name</span>=MongoDB Repository</span><br><span class="line"><span class="attr">baseurl</span>=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/<span class="number">4.2</span>/x<span class="number">86_64</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://www.mongodb.org/static/pgp/server-<span class="number">4.2</span>.asc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can also download the <code>.rpm</code> files directly from the <a href="https://repo.mongodb.org/yum/redhat/">MongoDB repository</a>. Downloads are organized by Red Hat / CentOS version (e.g. <code>7</code>), then MongoDB <a href="https://docs.mongodb.com/manual/reference/versioning/">release version</a> (e.g. <code>4.2</code>), then architecture (e.g. <code>x86_64</code>).</p>
</blockquote>
<h2 id="安装-mongodb">安装 MongoDB</h2>
<p>执行下列命令安装最新稳定版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>
<p>如果要安装特定版本的 MongoDB，请分别指定每个组件软件包，并将版本号附加到软件包名称中，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org-4.2.3 mongodb-org-server-4.2.3 mongodb-org-shell-4.2.3 mongodb-org-mongos-4.2.3 mongodb-org-tools-4.2.3</span><br></pre></td></tr></table></figure>
<p>你可以指定任何可用的 MongoDB 版本。但是，当有较新版本时，yum会升级软件包。为防止意外升级，请固定包。要固定软件包，请在 <code>/etc/yum.conf</code> 文件中添加以下 exclude 指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools</span><br></pre></td></tr></table></figure>
<h2 id="运行-mongodb">运行 MongoDB</h2>
<p><strong>运行前需要确认数据目录和日志目录是否存在，如果是初次尝试使用 MongoDB，建议使用默认目录。</strong></p>
<h3 id="目录路径">目录路径</h3>
<h4 id="使用默认目录">使用默认目录</h4>
<p>默认情况下，MongoDB 使用 mongod 用户帐户运行，并使用以下默认目录：</p>
<ul>
<li><code>/var/lib/mongo</code> (数据目录)</li>
<li><code>/var/log/mongodb</code> (日志目录)</li>
</ul>
<p>如果你是通过软件包管理器安装的，将会自动创建默认目录，并将这些目录的所有者和组设置为 mongod。</p>
<p>如果你是通过下载压缩包进行安装，未创建默认 MongoDB 目录的，需要手动创建 MongoDB 数据和日志目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/lib/mongo</span><br><span class="line">sudo mkdir -p /var/log/mongodb</span><br></pre></td></tr></table></figure>
<p>创建后，将这些目录的所有者和组设置为 mongod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R mongod:mongod &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;directory&gt;</code> 为你创建的目录。</p>
<h4 id="使用非默认目录">使用非默认目录</h4>
<p>要使用默认目录以外的数据目录和/或日志目录：</p>
<ul>
<li><p>创建一个或多个新目录。</p></li>
<li><p>编辑配置文件 <code>/etc/mongod.conf</code> 并相应地修改以下字段：</p>
<ul>
<li><code>storage.dbPath</code> 以指定新的数据目录路径（例如 /some/data/directory）</li>
<li><code>systemLog.path</code> 以指定新的日志文件路径（例如 /some/log/directory/mongod.log）</li>
</ul></li>
<li><p>确保运行 MongoDB 的用户有权访问这些非默认目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R mongod:mongod &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>如果更改运行 MongoDB 进程的用户，则必须授予新用户访问这些目录的权限。</p></li>
<li><p>配置 SELinux</p></li>
</ul>
<h3 id="配置-selinux">配置 SELinux</h3>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/#configure-selinux">Configure SELinux</a></p>
<h3 id="管理-mongod">管理 mongod</h3>
<p>请按照以下步骤在系统上运行 MongoDB Community Edition。这些说明假定你使用的是默认设置。</p>
<p>要运行和管理 mongod 进程，你将使用操作系统的内置初始化系统。Linux 的最新版本趋向于使用 systemd（使用 systemctl 命令），而 Linux 的较早版本趋向于使用 System V init（使用 service 命令）。</p>
<p>以 systemd（使用 systemctl 命令）为例：</p>
<ul>
<li><p>启动 mongod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mongod</span><br></pre></td></tr></table></figure>
<p>如果启动 mongod 时收到与以下类似的错误：</p>
<p><strong>Failed to start mongod.service: Unit mongod.service not found.</strong></p>
<p>首先运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>然后再次运行上面的启动命令。</p></li>
<li><p>验证 MongoDB 是否已成功启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status mongod</span><br></pre></td></tr></table></figure>
<p>你可以选择执行以下命令来确保 MongoDB 在系统启动时启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable mongod</span><br></pre></td></tr></table></figure></li>
<li><p>停止 mongod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop mongod</span><br></pre></td></tr></table></figure></li>
<li><p>重启 mongod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mongod</span><br></pre></td></tr></table></figure>
<p>你可以通过查看 /var/log/mongodb/mongod.log 文件中的输出来跟踪错误或重要消息的进程状态。</p></li>
<li><p>使用 MongoDB</p>
<p>在与 mongod 相同的主机上启动 mongo shell，你可以在没有任何命令行选项的情况下运行 mongo shell，这将使用默认端口 27017 连接到在本地主机上运行的 mongod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>
<p>有关使用 <a href="https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo">mongo</a> shell 连接的更多信息，例如连接到在其他主机和/或端口上运行的 mongod 实例，请参阅 <a href="https://docs.mongodb.com/manual/mongo/">mongo Shell</a>。</p></li>
</ul>
<h1 id="卸载-mongodb-社区版本">卸载 MongoDB 社区版本</h1>
<p>要从系统中完全删除 MongoDB，必须删除 MongoDB 应用程序本身，配置文件以及所有包含数据和日志的目录。以下部分将指导你完成必要的步骤：</p>
<blockquote>
<p>WARNING</p>
<p>This process will <em>completely</em> remove MongoDB, its configuration, and <em>all</em> databases. This process is not reversible, so ensure that all of your configuration and data is backed up before proceeding.</p>
</blockquote>
<ul>
<li><p>停止 mongod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mongod stop</span><br></pre></td></tr></table></figure></li>
<li><p>删除 MongoDB 包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum erase $(rpm -qa | grep mongodb-org)</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据和日志目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -r /var/log/mongodb</span><br><span class="line">sudo rm -r /var/lib/mongo</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="references">References</h1>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>打印二叉树</title>
    <url>/posts/91f36751/</url>
    <content><![CDATA[<p>本文将使用两种展示方式打印一颗二叉树，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">├── 12</span><br><span class="line">│   ├── 14</span><br><span class="line">│   │   ├── 20</span><br><span class="line">│   │   │   └── 15</span><br><span class="line">│   │   └── 13</span><br><span class="line">│   └── 10</span><br><span class="line">│       ├── 11</span><br><span class="line">│       └── 9</span><br><span class="line">└── 4</span><br><span class="line">    ├── 6</span><br><span class="line">    │   ├── 7</span><br><span class="line">    │   └── 5</span><br><span class="line">    └── 2</span><br><span class="line">        ├── 3</span><br><span class="line">        └── 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 /----- 20</span><br><span class="line">                 |       \----- 15</span><br><span class="line">         /----- 14</span><br><span class="line">         |       \----- 13</span><br><span class="line"> /----- 12</span><br><span class="line"> |       |       /----- 11</span><br><span class="line"> |       \----- 10</span><br><span class="line"> |               \----- 9</span><br><span class="line">8</span><br><span class="line"> |               /----- 7</span><br><span class="line"> |       /----- 6</span><br><span class="line"> |       |       \----- 5</span><br><span class="line"> \----- 4</span><br><span class="line">         |       /----- 3</span><br><span class="line">         \----- 2</span><br><span class="line">                 \----- 1</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="构建二叉树">构建二叉树</h1>
<p>为了方便测试，我们需要构建一颗二叉树，这里使用前序遍历序列和中序遍历序列来重建二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   Tree.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/03/23 17:46:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> :   1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Contact</span> :   15wylu@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@License</span> :   (C)Copyright 2020, wylu-CHINA-SHENZHEN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>    :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">mk</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> startPre, <span class="type">int</span> endPre,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre == endPre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[startPre]);</span><br><span class="line">        <span class="comment">// 中序遍历序列根结点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> startIn;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; endIn &amp;&amp; in[idx] != root.val) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树序列长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> idx - startIn;</span><br><span class="line">        <span class="comment">// 左右子树序列中点（右子树序列起始点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mpre</span> <span class="operator">=</span> startPre + <span class="number">1</span> + llen;</span><br><span class="line">        root.left = mk(pre, in, startPre + <span class="number">1</span>, mpre, startIn, idx - <span class="number">1</span>);</span><br><span class="line">        root.right = mk(pre, in, mpre, endPre, idx + <span class="number">1</span>, endIn);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用前序遍历序列和中序遍历序列构建一颗二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre 前序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in  中序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">mkTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length == <span class="number">0</span> || pre.length != in.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mk(pre, in, <span class="number">0</span>, pre.length, <span class="number">0</span>, in.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Case 1</span></span><br><span class="line">    <span class="type">int</span>[] pre = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] in = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> Tree.mkTree(pre, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树打印类">二叉树打印类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span> : TreePrinter.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span> : 2020/03/23 17:47:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : wylu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Contact</span> : 15wylu@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@License</span> : (C)Copyright 2020, wylu-CHINA-SHENZHEN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span> :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreePrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">linuxStyle</span><span class="params">(TreeNode root, StringBuilder sb, String prefix, String childPrefix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(prefix);</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        linuxStyle(root.right, sb, childPrefix + <span class="string">&quot;├── &quot;</span>, childPrefix + <span class="string">&quot;│   &quot;</span>);</span><br><span class="line">        linuxStyle(root.left, sb, childPrefix + <span class="string">&quot;└── &quot;</span>, childPrefix + <span class="string">&quot;    &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">getLinuxStyle</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        linuxStyle(root, sb, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * z</span></span><br><span class="line"><span class="comment">     * ├── c</span></span><br><span class="line"><span class="comment">     * │ ├── a</span></span><br><span class="line"><span class="comment">     * │ └── b</span></span><br><span class="line"><span class="comment">     * └── d</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prtLinuxStyle</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        System.out.println(getLinuxStyle(root).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">horizontalStyle</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            horizontalStyle(root.right, sb, <span class="literal">true</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            horizontalStyle(root.left, sb, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">horizontalStyle</span><span class="params">(TreeNode root, StringBuilder sb, <span class="type">boolean</span> isRight,</span></span><br><span class="line"><span class="params">            String indent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            horizontalStyle(root.right, sb, <span class="literal">true</span>, indent + (isRight ? <span class="string">&quot;        &quot;</span> : <span class="string">&quot; |      &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(indent);</span><br><span class="line">        sb.append(isRight ? <span class="string">&quot; /&quot;</span> : <span class="string">&quot; \\&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;----- &quot;</span>);</span><br><span class="line">        sb.append(root.val).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            horizontalStyle(root.left, sb, <span class="literal">false</span>, indent + (isRight ? <span class="string">&quot; |      &quot;</span> : <span class="string">&quot;        &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *                 /----- 20</span></span><br><span class="line"><span class="comment">     *                 |       \----- 15</span></span><br><span class="line"><span class="comment">     *         /----- 14</span></span><br><span class="line"><span class="comment">     *         |       \----- 13</span></span><br><span class="line"><span class="comment">     * /----- 12</span></span><br><span class="line"><span class="comment">     * |       |       /----- 11</span></span><br><span class="line"><span class="comment">     * |       \----- 10</span></span><br><span class="line"><span class="comment">     * |               \----- 9</span></span><br><span class="line"><span class="comment">     * 8</span></span><br><span class="line"><span class="comment">     * |              /----- 7</span></span><br><span class="line"><span class="comment">     * |      /----- 6</span></span><br><span class="line"><span class="comment">     * |      |       \----- 5</span></span><br><span class="line"><span class="comment">     * \----- 4</span></span><br><span class="line"><span class="comment">     *        |       /----- 3</span></span><br><span class="line"><span class="comment">     *        \----- 2</span></span><br><span class="line"><span class="comment">     *                \----- 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prtHorizontalStyle</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        System.out.println(horizontalStyle(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Case 1</span></span><br><span class="line">        <span class="type">int</span>[] pre = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] in = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> Tree.mkTree(pre, in);</span><br><span class="line">        TreePrinter.prtLinuxStyle(root);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 2</span></span><br><span class="line">        pre = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        root = Tree.mkTree(pre, in);</span><br><span class="line">        TreePrinter.prtLinuxStyle(root);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram">https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下安装拳皇97</title>
    <url>/posts/7de10289/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/47388022e4a3b798095c5d9db042a1a5.jpeg" alt="kof97" /></p>
<span id="more"></span>
<h1 id="系统环境">系统环境</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsb_release -a</span></span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 18.04.3 LTS</span><br><span class="line">Release:	18.04</span><br><span class="line">Codename:	bionic</span><br></pre></td></tr></table></figure>
<h1 id="安装-mame-模拟器">安装 <a href="https://www.mamedev.org/">MAME</a> 模拟器</h1>
<p><a href="https://en.wikipedia.org/wiki/MAME">MAME</a>（最初是 Multiple Arcade Machine Emulator 的缩写）是一种免费的开源模拟器，旨在在现代个人计算机和其他平台上的软件中重新创建街机游戏系统的硬件。MAME 目的是通过防止老式游戏丢失或遗忘来保留游戏历史，并为模拟街机的内部工作提供参考，其实际玩游戏的能力被认为是“不错的副作用”。</p>
<p>执行以下命令安装 MAME 模拟器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install mame</span></span><br></pre></td></tr></table></figure>
<h1 id="测试-mame-是否安装成功">测试 MAME 是否安装成功</h1>
<p>执行 <code>mame</code> 命令启动模拟器，如果启动后界面如下，说明模拟器安装成功，按 <code>ESC</code> 键可退出程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2938522a5e40a5dfd2608ebd476204c4.png" alt="mame" /></p>
<h1 id="下载-kof97.zip-rom">下载 kof97.zip rom</h1>
<p>因为大多数游戏数据都是存储于只读存储器，渐渐地不管这些文件原先是被存储于怎样的介质，读取后的文件都通称为 ROM 映像档或 ROM。在要运行某一特定的游戏时，MAME 就需要这些读取自原始街机的整组文件，这一整组的文件称之为“ROM 集合”，但是碍于法规 MAME 不会自带这些文件。</p>
<p>所以想要在 MAME 中玩拳皇97还需要下载游戏的 rom 包，MAME 支持的游戏 rom 包可以到 <a href="https://www.planetemu.net/roms/mame-roms">https://www.planetemu.net/roms/mame-roms</a> 下载。</p>
<p>这是拳皇97的 rom：<a href="https://www.planetemu.net/rom/mame-roms/kof97">kof97.zip</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6cda02f480b578316d17c0a5357a2e05.png" alt="download-kof97" /></p>
<p>拳皇97风云再起的 rom: <a href="https://www.planetemu.net/rom/mame-roms/kof97pls">kof97pls.zip</a>，该 rom 依赖于 kof97.zip</p>
<h1 id="下载-neogeo.zip">下载 neogeo.zip</h1>
<p>neogeo.zip 是玩所有 NEOGEO 公司出品的游戏所必需的 BIOS 文件，需要和其它游戏 ROM 一起放在模拟器的 roms 文件夹下。</p>
<p>Mame 0.198 街机 BIOS 文件 neogeo.zip 进行了更新，新增 uni-bios_3_3.rom，sp1-u3.bin sp1-j3.bin 驱动。</p>
<p><a href="https://source.mamecn.com/newrom2018/0.198mameBIOS/neogeo.zip">https://source.mamecn.com/newrom2018/0.198mameBIOS/neogeo.zip</a></p>
<h1 id="将-kof97.zip-和-neogeo.zip-放到-mame-的-roms-目录下">将 kof97.zip 和 neogeo.zip 放到 MAME 的 roms 目录下</h1>
<p>使用 apt 安装 MAME 时，默认会将模拟器安装在 <code>/usr/share/games/mame</code>，所以 MAME 的 roms 目录在 <code>/usr/share/games/mame/roms</code>，将 kof97.zip 和 neogeo.zip 都拷贝到 roms 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wylu @ X555LJ <span class="keyword">in</span> /usr/share/games/mame/roms [23:28:54]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> ~/Downloads/kof97.zip .</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wylu @ X555LJ <span class="keyword">in</span> /usr/share/games/mame/roms [23:29:54]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> ~/Downloads/neogeo.zip .</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wylu @ X555LJ <span class="keyword">in</span> /usr/share/games/mame/roms [23:30:11]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 30M</span><br><span class="line">-rw-r--r-- 1 root root  28M Feb  2 23:29 kof97.zip</span><br><span class="line">-rw-r--r-- 1 root root 1.7M Feb  2 23:30 neogeo.zip</span><br></pre></td></tr></table></figure>
<h1 id="验证-rom-是否正确可用">验证 rom 是否正确可用</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mame -verifyroms kof97</span></span><br><span class="line">romset kof97 [neogeo] is good</span><br><span class="line">1 romsets found, 1 were OK.</span><br></pre></td></tr></table></figure>
<p>验证成功，如果提示你的 neogeo.zip 缺少文件导致无法运行，请尝试获取最新的 neogeo.zip 文件然后重试。</p>
<h1 id="运行游戏">运行游戏</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mame kof97</span></span><br></pre></td></tr></table></figure>
<p>执行以上命令即可启动游戏，默认 MAME 运行时是全屏，使用组合键 <code>Alt + Enter</code> 可切换成窗口模式；按 <code>p</code> 键暂停游戏并释放鼠标；按 <code>Tab</code> 键可进行相应的设置，按 <code>Esc</code> 退出 MAME。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/fa2bd08f3fe5eed992ab014923140d8e.png" alt="run-kof97" /></p>
<h1 id="配置视图长宽比aspect-ratio">配置视图长宽比（Aspect Ratio）</h1>
<p>如果你成功运行了 kof97，并尝试进行设置，你会发现视图的长宽比始终为 4:3，且无法调整，导致整个视图看起来非常窄，为了能够调整长宽比，我查阅了许多资料，后来发现一个帖子，它基本上解决了我遇到的问题：</p>
<p><a href="http://forum.arcadecontrols.com/index.php?topic=154130.0">Correct Aspect Ratio for vertical games on 16:9 screens??</a></p>
<p>我的方法就是修改模拟器的配置文件，首先进入到 MAME 配置文件目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/mame</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 8.0K</span><br><span class="line">-rw-r--r-- 1 root root 1.9K Aug 30  2017 mame.ini</span><br><span class="line">drwxr-xr-x 2 root root 4.0K Feb  2 22:29 presets</span><br></pre></td></tr></table></figure>
<p>然后编辑 mame.ini 文件，在文件末尾加上如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keepaspect              0</span><br><span class="line">unevenstretch           1</span><br><span class="line">autostretchxy           0</span><br></pre></td></tr></table></figure>
<p>保存退出，最后重新运行游戏 <code>mame kof97</code></p>
<h1 id="reference">Reference</h1>
<p><a href="https://www.mamecn.com/jiejiyouxixiazaijieshao/13814.html">https://www.mamecn.com/jiejiyouxixiazaijieshao/13814.html</a></p>
<p><a href="http://forum.arcadecontrols.com/index.php?topic=154130.0">http://forum.arcadecontrols.com/index.php?topic=154130.0</a></p>
<p><a href="https://docs.mamedev.org/advanced/multiconfig.html">https://docs.mamedev.org/advanced/multiconfig.html</a></p>
<p><a href="https://strategywiki.org/wiki/MAME/Configure">https://strategywiki.org/wiki/MAME/Configure</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>MAME</tag>
        <tag>kof97</tag>
        <tag>拳皇97</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+jsDelivr打造稳定快速、高效免费图床</title>
    <url>/posts/e714e6f9/</url>
    <content><![CDATA[<p>jsDelivr 是 ProspectOne 开发的公共开源 CDN（Content Delivery Network），专注于性能，可靠性和安全性。每个人均可免费使用，没有带宽限制。jsDelivr 是唯一由中国政府签发并具有有效 ICP 许可证的公共 CDN，并且直接在中国大陆拥有数百个地点。</p>
<p>jsDelivr 有一个十分好用的功能，它可以加速 Github 仓库的文件访问，借助 jsDelivr 我们可以搭建一个稳定快速、高效免费的图床。</p>
<span id="more"></span>
<h1 id="新建-github-仓库">新建 Github 仓库</h1>
<p>要实现一个 Github 图床，首先我们需要在 Github 创建一个仓库，用来存放我们的图片，假设新仓库名为 figure-bed。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bc452531b7bd26908cb1446d7a727f95.png" alt="create-a-new-repo" /></p>
<h1 id="clone-仓库到本地">Clone 仓库到本地</h1>
<p>复制图床仓库地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5c19b62faff0a4e83d2779bd5b1cb1dc.png" alt="clone-repo" /></p>
<p>执行 <code>git clone</code>，将 figure-bed 克隆到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:wylu/figure-bed.git</span></span><br></pre></td></tr></table></figure>
<h1 id="上传图片到仓库">上传图片到仓库</h1>
<p>复制需要上传的图片或其它资源，如 js、css等，现假设我们将三张图片放到 figure-bed 仓库的 blog 目录下，其目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree figure-bed</span></span><br><span class="line">figure-bed</span><br><span class="line">├── blog</span><br><span class="line">│   ├── 1.jpg</span><br><span class="line">│   ├── 2.jpg</span><br><span class="line">│   └── 3.png</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure>
<p>执行以下命令，推送资源到远程库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;initial commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push</span></span><br></pre></td></tr></table></figure>
<h1 id="通过-jsdelivr-引用图片">通过 jsDelivr 引用图片</h1>
<p>在将图片推送到远程库后，我们就可以用 jsDelivr 引用仓库中的图片了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/14d7d416708f7aa8a9fc1dbfa7be6520.png" alt="push-asset" /></p>
<p>引用方法为："<a href="https://cdn.jsdelivr.net/gh/Github用户名/仓库名/" class="uri">https://cdn.jsdelivr.net/gh/Github用户名/仓库名/</a>文件路径"</p>
<p>以上面的 figure-bed 为例，假如我们要引用名为 <code>1.jpg</code> 的图片，使用方法为：</p>
<p><a href="https://cdn.jsdelivr.net/gh/wylu/figure-bed/blog/1.jpg" class="uri">https://cdn.jsdelivr.net/gh/wylu/figure-bed/blog/1.jpg</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/28000ecdb815ba01808de6a496160ac6.png" alt="ref-asset" /></p>
<p>更多引用 Github 资源的写法请参考 <a href="https://github.com/jsdelivr/jsdelivr">jsdelivr GitHub</a>。</p>
<h1 id="利用-picgo-上传图片到图床">利用 PicGo 上传图片到图床</h1>
<p>如果你不想手动地 commit 图片到图床，而是想通过简单的拖拽的方式就能实现图片的上传，那么 PicGo 工具是一个不错的选择。</p>
<p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo使用文档</a></p>
<p>具体操作可参考 THRX 博客 <a href="https://www.itrhx.com/2019/08/01/A27-image-hosting/">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></p>
<h1 id="references">References</h1>
<p><a href="https://github.com/jsdelivr/jsdelivr">https://github.com/jsdelivr/jsdelivr</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>jsDelivr</tag>
        <tag>图床</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 图片caption出现多次</title>
    <url>/posts/7bd83fc5/</url>
    <content><![CDATA[<p>在使用 Hexo + NexT 搭建个人博客的过程中一直有个问题没有解决，直到今天才找到了解决方法。问题就是在展示同一张图片中，caption出现了两次，如图：</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0c4822c37849a99d0fb4321898857fc7.png" alt="multiple-captions" /></p>
<h1 id="问题分析">问题分析</h1>
<p>图片正下方的 image-caption 是 NexT 给 fancybox 加上的；而图片左下方的 figcaption 是因为使用了 hexo-renderer-pandoc Markdown 渲染器导致的，hexo-renderer-pandoc 将 Markdown 文件渲染成 HTML 时，会对图片进行渲染，然后生成一个 figcaption 的标签。</p>
<p>很多人可能不会有这样的问题，因为 Hexo 默认的 Markdown 渲染器是 hexo-renderer-marked，hexo-renderer-marked 渲染图片时不会生成 figcaption。</p>
<p>如果你使用的是 hexo-renderer-marked 渲染器，就不会有这样的问题，但是相信很多人都是因为需要使用 mathjax，所以都将默认的 Hexo 默认的 Markdown 渲染器换成了 hexo-renderer-pandoc，hexo-renderer-pandoc 功能强大（依赖与 pandoc 自身强大的功能），它对数学公式的渲染简直可以说是吊打 hexo-renderer-marked，这也是我一直使用它的原因。</p>
<p>所以为了在使用 hexo-renderer-pandoc 的同时，把图片 caption 出现了两次的问题解决，我提过 issue，查阅了许多资料，终于找到了解决的方法。</p>
<h1 id="解决方法">解决方法</h1>
<p>编辑站点配置文件 <code>_config.yml</code>，添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pandoc:</span></span><br><span class="line">  <span class="attr">extensions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-implicit_figures&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行下列命令重新生成站点，展示效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -o</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b24b1cca6708ffdb71c6e6a1c75c36ad.png" alt="single-caption" /></p>
<h1 id="隐藏-fancybox-的-caption">隐藏 fancybox 的 caption</h1>
<p>以 NexT v7.7.0 为例，通过查看 hexo-theme-next/source/js/utils.js 源码，发现 NexT 在使用 fancybox 时，如果图片 title 或 alt 属性不为空时，就会 fancybox 添加一个子标签展示图片的 title 或 alt 属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imageTitle = $image.<span class="title function_">attr</span>(<span class="string">&#x27;title&#x27;</span>) || $image.<span class="title function_">attr</span>(<span class="string">&#x27;alt&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (imageTitle) &#123;</span><br><span class="line">  $imageWrapLink.<span class="title function_">append</span>(<span class="string">`&lt;p class=&quot;image-caption&quot;&gt;<span class="subst">$&#123;imageTitle&#125;</span>&lt;/p&gt;`</span>);</span><br><span class="line">  <span class="comment">// Make sure img title tag will show correctly in fancybox</span></span><br><span class="line">  $imageWrapLink.<span class="title function_">attr</span>(<span class="string">&#x27;title&#x27;</span>, imageTitle).<span class="title function_">attr</span>(<span class="string">&#x27;data-caption&#x27;</span>, imageTitle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想通过配置支持选择是否展示 caption，可以参考下方的方法（在 NexT v7.7.0 已测试过），其实不管 NexT 的版本如何，解决方法的思路基本是一致的。</p>
<p>首先修改主题配置文件 <code>_config.yml</code>，找到 fancybox 的配置，将 fancybox 的配置改成如下所示内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">caption:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>其中，enable 控制是否启用 fancybox，而 caption 控制是否展示 caption (当然只有在 enable 为 true 时，caption 配置才有效)，如果你不启用 fancybox 自然也不会有 caption。</p>
<p>然后，编辑 hexo-theme-next/source/js/utils.js 文件，将上面的代码修改成如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imageTitle = $image.<span class="title function_">attr</span>(<span class="string">&#x27;title&#x27;</span>) || $image.<span class="title function_">attr</span>(<span class="string">&#x27;alt&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (imageTitle) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">CONFIG</span>.<span class="property">fancybox</span>.<span class="property">caption</span>) &#123;</span><br><span class="line">    $imageWrapLink.<span class="title function_">append</span>(<span class="string">`&lt;p class=&quot;image-caption&quot;&gt;<span class="subst">$&#123;imageTitle&#125;</span>&lt;/p&gt;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Make sure img title tag will show correctly in fancybox</span></span><br><span class="line">  $imageWrapLink.<span class="title function_">attr</span>(<span class="string">&#x27;title&#x27;</span>, imageTitle).<span class="title function_">attr</span>(<span class="string">&#x27;data-caption&#x27;</span>, imageTitle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，编辑 hexo-theme-next/source/js/next-boot.js 文件，将 <code>CONFIG.fancybox &amp;&amp; NexT.utils.wrapImageWithFancyBox();</code> 替换成如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register JS handlers by condition option.</span></span><br><span class="line"><span class="comment"> * Need to add config option in Front-End at &#x27;layout/_partials/head.swig&#x27; file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable constant_">CONFIG</span>.<span class="property">fancybox</span>.<span class="property">enable</span> &amp;&amp; <span class="title class_">NexT</span>.<span class="property">utils</span>.<span class="title function_">wrapImageWithFancyBox</span>();</span><br></pre></td></tr></table></figure>
<p>相信你可以发现，我们这里将 <code>CONFIG.fancybox</code> 替换成 <code>CONFIG.fancybox.enable</code>，正是因为我们自定义的配置是通过 fancybox 下的 enable 的值来确定是否启用的。另外从源码上方的注释可以看到，CONFIG 下的配置项需要在前端文件 'layout/_partials/head.swig' （实际上该文件在'layout/_partials/head/head.swig'）中加上。</p>
<p>所以最后，我们需要在 <code>layout/_partials/head/head.swig</code> 中修改一下上面我们所使用 <code>CONFIG.fancybox.caption</code> 配置。参照其它配置，这里需要将 <code>fancybox: &#123;&#123; theme.fancybox &#125;&#125;</code>，修改成如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox</span>: &#123;&#123; theme.<span class="property">fancybox</span> | json &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>重新生成，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f54b951b2622035fc0267a3492e4149a.png" alt="no-caption" /></p>
<h1 id="references">References</h1>
<p><a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/34">https://github.com/wzpan/hexo-renderer-pandoc/issues/34</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next/issues/857">https://github.com/theme-next/hexo-theme-next/issues/857</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Git子模块</title>
    <url>/posts/3504e7d9/</url>
    <content><![CDATA[<p>Git 子模块(Git submodules)允许你将 git repo 保留为另一个 git repo 的子目录。Git 子模块只是在特定时间快照上对另一个 repo 的引用。Git 子模块使 Git repo 能够合并和跟踪外部代码的版本历史。</p>
<span id="more"></span>
<h1 id="添加子模块">添加子模块</h1>
<p>通过下列命令，可以将在一个已存在的 Git 仓库添加为当前工作的仓库的子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add &lt;repo url&gt; [submodule path]</span></span><br></pre></td></tr></table></figure>
<p>例如，在一个 Hexo 博客仓库下添加一个主题仓库 NexT：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/wylu/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，如果没有指定子模块存放路径，子模块将会放到一个与仓库同名的目录中。如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径，本例中子模块将会 clone 到 "themes/next" 目录下。</p>
<p>命令执行完成后，会在当前工作仓库根目录下生成 .gitmodules 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    path = themes/next</span><br><span class="line">    url = https://github.com/wylu/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>该文件保存了项目 URL 与已经拉取的本地目录之间的映射，如果有多个子模块，该文件中就会有多条记录。要重点注意的是，该文件应像 .gitignore 文件一样受到（通过）版本控制，和该项目的其他部分一同被拉取推送。有了映射关系，克隆该项目的人就知道去哪获得子模块了。</p>
<p>添加子模块完成后，当在父仓库时，Git 仍然不会跟踪 submodule 的文件， 而是将它看作该仓库中的一个特殊提交。</p>
<p>推送到远程仓库后，远程仓库中 submodule 会和指定的 commit 关联起来。如果需要指定分支，可以在 ".gitmodules" 文件中加上 branch 配置，如 <code>branch = develop</code>。</p>
<h1 id="克隆含有子模块的项目">克隆含有子模块的项目</h1>
<p>接下来我们将会克隆（clone）一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件，你需要执行两个命令以拉取子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update</span></span><br></pre></td></tr></table></figure>
<p><code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从子项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recursive &lt;parent repo url&gt;</span><br></pre></td></tr></table></figure>
<h1 id="删除子模块">删除子模块</h1>
<ol type="1">
<li><p>把子模块从版本控制系统中移除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached &lt;submodule path&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除子模块目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf &lt;submodule path&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编辑 ".gitmodules"，移除相应 submodule 节点内容</p></li>
<li><p>编辑 ".git/config"，移除相应 submodule 配置</p></li>
<li><p>如果有 ".git/modules" 目录，还应删除其下的相应子模块的目录</p></li>
</ol>
<p>以上面的 NexT 子模块为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached themes/next</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf themes/next</span></span><br></pre></td></tr></table></figure>
<p>然后删除 ".gitmodules" 中如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    path = themes/next</span><br><span class="line">    url = https://github.com/wylu/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>最后删除 ".git/config" 中如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    url = https://github.com/wylu/hexo-theme-next</span><br><span class="line">    active = true</span><br></pre></td></tr></table></figure>
<p>要把此次修改同步到远程库，还需要 push 一下。</p>
<h1 id="references">References</h1>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title>Git在同一机器下配置多个github账号</title>
    <url>/posts/e186bfe8/</url>
    <content><![CDATA[<p>大多数人有时会需要在同一台机器上管理多个 github 账号，本文以管理两个 github 账号为例，记录了配置 git 的过程，方便下次遇到相同问题时，能节省处理时间。</p>
<span id="more"></span>
<h1 id="约定">约定</h1>
<ul>
<li>github 账号 1： wylu, 对应邮箱为 wylu@gmail.com</li>
<li>github 账号 2： 15wylu, 对应邮箱为 15wylu@gmail.com</li>
</ul>
<h1 id="生成第一对-ssh-key">生成第一对 SSH key</h1>
<p>第一个密钥对以 wylu 账号为例，在生成之前，我们可以通过 <code>ls -al ~/.ssh</code> 查看是否已有 SSH key。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al ~/.ssh</span></span><br><span class="line">total 24</span><br><span class="line">drwx------  2 wylu wylu 4096 Nov 24  2018 .</span><br><span class="line">drwxr-xr-x 66 wylu wylu 4096 Jan  7 00:00 ..</span><br><span class="line">-rw-------  1 wylu wylu 1675 Nov 24  2018 id_rsa</span><br><span class="line">-rw-r--r--  1 wylu wylu  398 Nov 24  2018 id_rsa.pub</span><br><span class="line">-rw-r--r--  1 wylu wylu 4841 Dec 22 21:46 known_hosts</span><br></pre></td></tr></table></figure>
<p>如果 <code>~/.ssh</code> 下有 "id_rsa"（私钥） 和 "id_rsa.pub"（公钥），说明之前已生成过 SSH key 了，我们可以直接复用这个密钥对（SSH key）。</p>
<p>如果你没有 SSH key 或者你想要重新生成一个 SSH key，可以执行以下命令生成：</p>
<ul>
<li>不存在 SSH Key 时。</li>
</ul>
<p>遇到输入一路回车使用默认配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;wylu@gmail.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/pi/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/home/pi/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/pi/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/pi/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:nGAMmHYEKfJ3/iEDLxOsg1xinfg/IzuYTQVggEnVSWQ wylu@gmail.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|==+B*E.          |</span><br><span class="line">|* =.o=           |</span><br><span class="line">|.+ooo +          |</span><br><span class="line">| +.+=o.o .       |</span><br><span class="line">|o.+o.*  S        |</span><br><span class="line">|..ooo = .        |</span><br><span class="line">|  =..o + .       |</span><br><span class="line">| o + +  .        |</span><br><span class="line">|   .+ o          |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<ul>
<li>已存在 SSH Key 时。</li>
</ul>
<p>当询问是否 <code>Overwrite (y/n)?</code> 已存在的 <code>id_rsa</code> 时，直接输入 <code>y</code> 然后回车，其余的一路回车使用默认配置就好。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;wylu@gmail.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/pi/.ssh/id_rsa):</span><br><span class="line">/home/pi/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/pi/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/pi/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:rPh6Y081aG7URerEmd6aA5FVYi+1w0KPHR59KggFwLk wylu@gmail.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|     ..o.o*.*.   |</span><br><span class="line">|      o .* # +. .|</span><br><span class="line">|       .o.X.X  o |</span><br><span class="line">|      E. B.=...  |</span><br><span class="line">|        S * ..   |</span><br><span class="line">|     . = o +     |</span><br><span class="line">|    . . + +      |</span><br><span class="line">|     .+o   .     |</span><br><span class="line">|    .+.o.        |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>我们以此 SSH Key 作为默认的密钥对。</p>
<h1 id="生成第二对-ssh-key">生成第二对 SSH Key</h1>
<p>假设我们已经拥有了一对 SSH Key 对应于管理 wylu 的 github 账号，现在需要生成另外一对 SSH Key 用于管理 15wylu 的 github 账号。</p>
<p>执行下面的命令生成另一对 SSH Key：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;15wylu@gmail.com&quot;</span> -f <span class="string">&quot;15wylu_id_rsa&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in 15wylu_id_rsa.</span><br><span class="line">Your public key has been saved in 15wylu_id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:6cQHRLvxRovTNQgPh1JiMCe4U1tFgkxe541ZGN+NiHA 15wylu@gmail.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|   +=oB=E+o      |</span><br><span class="line">|  ..+*oOo&amp; + o   |</span><br><span class="line">|   o.o .O B = .  |</span><br><span class="line">|  o .  . X o .   |</span><br><span class="line">|   .    S *      |</span><br><span class="line">|       o +       |</span><br><span class="line">|        .        |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>方法与上面生成第一对 SSH Key 一样，一路回车，这里使用 <code>-f</code> 选项的作用是指定生成的密钥对文件的名称，以避免覆盖之前的密钥对文件。从输出信息中可以看到，此次生成的私钥文件名为 <code>15wylu_id_rsa</code>，公钥文件名为 <code>15wylu_id_rsa.pub</code>。这样同一台机器下，wylu 和 15wylu 都拥有了各自的 SSH Keys：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al ~/.ssh</span></span><br><span class="line">total 24</span><br><span class="line">drwx------ 2 pi pi 4096 Jan  6 17:00 .</span><br><span class="line">drwxr-xr-x 7 pi pi 4096 Jan  6 16:55 ..</span><br><span class="line">-rw------- 1 pi pi 1823 Jan  6 17:00 15wylu_id_rsa</span><br><span class="line">-rw-r--r-- 1 pi pi  396 Jan  6 17:00 15wylu_id_rsa.pub</span><br><span class="line">-rw------- 1 pi pi 1823 Jan  6 16:38 id_rsa</span><br><span class="line">-rw-r--r-- 1 pi pi  396 Jan  6 16:38 id_rsa.pub</span><br></pre></td></tr></table></figure>
<h1 id="在对应的-github-账号中添加-ssh-key">在对应的 github 账号中添加 SSH key</h1>
<p>参考文章 <a href="https://wylu.github.io/posts/5b767b23/">Git配置SSH Key</a> 中的 <strong>添加 SSH Key 到 Github</strong> 部分，分别将 <code>id_rsa.pub</code> 文件中的公钥添加到 wylu 账号，将 <code>15wylu_id_rsa.pub</code> 文件中的公钥添加到 15wylu 账号。</p>
<h1 id="使用-ssh-agent-注册新的-ssh-密钥">使用 ssh-agent 注册新的 SSH 密钥</h1>
<p>ssh-agent：是一个可以控制和保存公钥身份验证所使用的私钥的程序，可以理解为一个密钥管理器，ssh-agent 是一个守护进程（daemon），设计它的唯一目的就是对解密的专用私钥进行高速缓存。</p>
<p><strong>如果没有正在运行的 ssh-agent，则执行 <code>eval "$(ssh-agent -s)"</code> 以确保 ssh-agent 运行。</strong></p>
<p>然后使用 ssh-add 添加私钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/id_rsa</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/15wylu_id_rsa</span></span><br></pre></td></tr></table></figure>
<p>使用 ssh-add 将私钥交给 ssh-agent 保管，其他程序需要身份验证时，ssh 将直接从 ssh-agent 获取私钥，而不会提示你输入密码口令以获取私钥，这样就不需要经常输入密码了。可以使用 <code>ssh-add -l</code> 查看已添加到 ssh-agent 中的密钥。</p>
<p>接下来，<strong>需要使 ssh-agent 对不同的 SSH 主机使用各自的 SSH 密钥</strong>，这是关键部分，我们有两种不同的方法（使用其中一种即可）：</p>
<ul>
<li>使用 SSH 配置文件</li>
<li>在 ssh-agent 中只有一个活动的 SSH 密钥</li>
</ul>
<h1 id="使用-ssh-配置文件推荐">使用 SSH 配置文件（推荐）</h1>
<p>使用 <code>~/.ssh/config</code> 作为我们的配置文件，如果文件不存在，我们就创建它。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> config</span></span><br></pre></td></tr></table></figure>
<p>编辑 <code>~/.ssh/config</code>，使相关 GitHub 帐户的配置类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># github: wylu, email: wylu@gmail.com</span><br><span class="line"># the default config</span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># github: 15wylu, email: 15wylu@gmail.com</span><br><span class="line">Host 15wylu.github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~/.ssh/15wylu_id_rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>Host: 别名，用于区分多个 git 账号，可随意</li>
<li>HostName: 要连接的服务器的主机名</li>
<li>IdentityFile: ssh 连接使用的私钥</li>
</ul>
<p>上面的配置要求 ssh-agent：</p>
<ul>
<li>使用 <code>id_rsa</code> 作为使用 <span class="citation" data-cites="github.com">@github.com</span> 的任何 Git URL 的密钥</li>
<li>对于使用 <span class="citation" data-cites="15wylu.github.com">@15wylu.github.com</span> 的任何 Git URL，则使用 <code>15wylu_id_rsa</code> 密钥</li>
</ul>
<p>其规则就是：从上至下读取 config 的内容，在每个 Host 下寻找对应的私钥，你可以根据需要添加更多的 Host。</p>
<h2 id="clone-新仓库">clone 新仓库</h2>
<p><strong>注意：如果使用 SSH 配置文件前，仓库已存在，参考下方 "对于已存在的仓库" 的内容。</strong></p>
<p>这里以上面的配置为例，假设要克隆 15wylu 账号的一个项目，原来使用的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git@github.com:15wylu/15wylu.github.io.git</span></span><br></pre></td></tr></table></figure>
<p>但是经过配置，我们已经将 15wylu 的 Host 设为了 <code>15wylu.github.com</code>，而不再是原来的 <code>github.com</code>，所以相应地 clone 的命令也变成如下：</p>
<p>（请注意克隆时我们使用了 SSH 配置中使用的主机名）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git@15wylu.github.com:15wylu/15wylu.github.io.git</span></span><br></pre></td></tr></table></figure>
<h2 id="对于已存在的仓库">对于已存在的仓库</h2>
<p>假设在配置之前，我们就已经 clone 了仓库。</p>
<p>首先使用 <code>git remote -v</code> 列出本地仓库对应的远程库，检查该 URL 是否与要使用的 GitHub 主机匹配，否则更新远程原始 URL：</p>
<p>以 15wylu 账号的仓库为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote set-url origin git@15wylu.github.com:15wylu/15wylu.github.io.git</span></span><br></pre></td></tr></table></figure>
<p>确保 <code>@</code> 和 <code>:</code> 之间的字符串与我们在 SSH 配置中指定的主机（Host）匹配。</p>
<h2 id="对于本地创建新的仓库">对于本地创建新的仓库</h2>
<p>在项目文件夹中使用 <code>git init</code> 中初始化目录为一个 Git 仓库。然后在 GitHub 帐户中创建新的仓库，将其作为远程库添加到本地仓库中：</p>
<p>同样以 15wylu 账号为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin git@15wylu.github.com:15wylu/remote_repo_name.git</span></span><br></pre></td></tr></table></figure>
<p>确保 <code>@</code> 和 <code>:</code> 之间的字符串与我们在 SSH 配置中指定的主机（Host）匹配。将初始提交推送到 GitHub 仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;initial commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin master</span></span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p><strong>在这里，我们实际上是在为不同的主机（Host）添加 SSH 配置规则，说明要在哪个域中使用哪个身份文件（SSH key）。</strong></p>
<h2 id="测试">测试</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line">The authenticity of host &#x27;github.com (13.250.177.223)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;github.com,13.250.177.223&#x27; (RSA) to the list of known hosts.</span><br><span class="line">Hi wylu! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@15wylu.github.com</span></span><br><span class="line">Hi 15wylu! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>第一次执行 <code>ssh -T git@github.com</code> 时会有一段警告，直接输入 yes 回车既可。从输出的信息可以看到，wylu 和 15wylu 都认证成功了。</p>
<h1 id="在-ssh-agent-中只有一个活动的-ssh-密钥">在 ssh-agent 中只有一个活动的 SSH 密钥</h1>
<p>这种方法不需要 SSH 配置规则，而是我们手动确保 ssh-agent 在执行任何 Git 操作时仅附加了相关的密钥。</p>
<p><code>ssh-add -l</code> 将列出附加到 ssh-agent 的所有 SSH 密钥，删除所有这些密钥后，添加你将要使用的一个密钥，以确保 ssh-agent 中只有一个活动的密钥。</p>
<p>例如，假设你要使用 git 操作 15wylu 账号，首先使用下面的命令删除 ssh-agent 中的所有密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add -D</span></span><br></pre></td></tr></table></figure>
<p>然后添加 15wylu 账号对应的密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/15wylu_id_rsa</span></span><br></pre></td></tr></table></figure>
<p>此时，ssh-agent 已将密钥映射到 15wylu GitHub 帐户，当我们使用 git 推送、克隆等操作时都是对 15wylu 账号的仓库进行操作。</p>
<p>类似地，假如要使用 git 操作 wylu 账号，则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add -D</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add ~/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure>
<h1 id="为本地仓库设置-git-remote-url">为本地仓库设置 git remote url</h1>
<p>clone 或创建本地 Git 仓库后，请确保 Git 配置的用户名和电子邮件正是你想要的。GitHub 通过 commit 描述附随的电子邮件 ID 来标识任何提交的作者。</p>
<p>要在本地 Git 目录（本地 Git 仓库下）中列出配置名称和电子邮件，请执行 <code>git config user.name</code> 和 <code>git config user.email</code>。如果找不到，则需要进行相应的更新，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name <span class="string">&quot;wylu&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.email <span class="string">&quot;wylu@gmail.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://www.freecodecamp.org/news/manage-multiple-github-accounts-the-ssh-way-2dadc30ccaca/">How to manage multiple GitHub accounts on a single machine with SSH keys</a></p>
<p><a href="https://www.jianshu.com/p/89cb26e5c3e8">同一客户端下使用多个git账号</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>git多用户</tag>
        <tag>git多账号</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 简介与使用指南</title>
    <url>/posts/996c49c/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/600886d7f700cb3af3eb87635868ba4a.png" alt="tmux-logo" /></p>
<p>tmux 是一个终端复用器（terminal multiplexer），它使你能够轻松地在多个终端程序之间来回切换，同时你还可以脱离它们（它们将在后台继续运行），然后在另一个终端窗口重新连接它们。</p>
<p>tmux 提升工作效率的两个主要功能：</p>
<ul>
<li><p>窗口分割。在一个终端窗口中，可以随意进行水平或垂直分割，让你在一个窗口中运行多个独立的终端实例，这样你就无需打开多个终端窗口了。通过简单的组合键，你可以轻松在多个独立运行的终端实例间进行切换。</p></li>
<li><p>基于会话的访问控制。在使用 SSH 工作的情况下，tmux 能避免工作现场丢失。假设在你执行某条命令的过程中，因为某些不可抗的因素（如网络问题）导致连接断开，这时你可能很难确定刚才的命令是否执行成功；又或者当你处一个较深层次的目录位置时，若 SSH 连接断开，你不得不重新进入到之前的工作目录。如果使用了 tmux，就可以在 SSH 重新连接后，连接到 tmux 之前的 session，这样就可以回到原来的工作环境。</p></li>
</ul>
<span id="more"></span>
<h1 id="tmux-工作原理">tmux 工作原理</h1>
<p>本文将为您提供有关 tmux 的简要介绍，然后是安装和使用指南。</p>
<ul>
<li><a href="https://github.com/tmux/tmux/blob/master/.github/README.md">tmux README</a></li>
<li><a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">tmux 使用手册</a></li>
</ul>
<p>tmux 使用 C/S 模型构建，主要包含以下几个概念：</p>
<ul>
<li>Server：服务器，若当前没有 Server 进程，则执行 tmux 命令时会启动一个 Server</li>
<li>Session：会话，一个 Server 可以包含多个 Session</li>
<li>Window：窗口，一个 Session 可以包含多个 Window</li>
<li>Pane：窗格，一个 Window 可以包含多个 Pane</li>
</ul>
<p>当 tmux 启动时，它将创建一个具有单个 Window 的新 Session，这个 Window 中默认只包含一个 Pane，并将其显示在屏幕上。屏幕底部的状态栏显示了当前会话的信息，并用于输入交互式命令。</p>
<p><strong>注：这里包括以下所说的屏幕指的是当前仿真终端窗口的屏幕区域，因为在执行 tmux 命令前首先需要打开一个终端模拟器。</strong></p>
<p>Session 是“在 tmux 管理下的伪终端”的单个集合。每个会话都有一个或多个链接到它的 Window。Window 占据整个屏幕，并且可以分成多个矩形 Pane，每个 Pane 都是独立的伪终端。任意数量的 tmux 实例可以连接到同一个 Session，并且同一 Session 中可以存在任意数量的 Window。一旦所有的 Session 都被杀死，tmux 就会退出。</p>
<p>每个 Session 都是持久的，并且可以在意外断开连接（例如 ssh 连接超时）或故意断开连接（使用 <code>C-b d</code> 组合键）时幸免。可以使用以下方法重新连接 tmux：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach</span></span><br></pre></td></tr></table></figure>
<p><strong>在 tmux 中，Session 由 Client 显示在屏幕上，所有的 Session 均有单个 Server 管理。Server 和每个 Client 都是独立的进程，它们通过 /tmp 中的 socket 进行通信。</strong></p>
<p>不使用 tmux 时，是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f8434484401473708f7aedcc1c1bd213.png" alt="without-tmux" /></p>
<p>使用 tmux 时，是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/349fb265232a6d5fca03e7ee3684acfa.png" alt="use-tmux" /></p>
<h1 id="安装">安装</h1>
<p>Ubuntu / Debian 及其衍生版只需执行以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>CentOS 上安装执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y install tmux</span><br></pre></td></tr></table></figure>
<p>如果是 Mac，则执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<h1 id="开启你的第一个-session">开启你的第一个 Session</h1>
<p>对于你的的第一个 Session，你只需要简单的启动 tmux 即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure>
<p>这将创建一个新的 tmux Session，底部带有一个绿色的状态栏：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8ccdcba289453fccd42446d12bdfeded.png" alt="first-tmux-session" /></p>
<p>状态栏是 tmux 的重要组成部分。除了当前打开的窗口（在左侧）之外，它还显示一些系统信息，例如日期和时间（在右侧），此外状态栏也可以自定义。</p>
<h1 id="分割-pane">分割 Pane</h1>
<p>现在，我们已经创建了第一个 Session，接着通过分屏我们可以了解 Pane。当创建新 Session 时，默认情况下，tmux 将自动为我们创建一个 Window 和 一个内部 Pane，现在我们进行分屏操作。</p>
<p>tmux 中的所有命令均由 <code>前缀键+命令键</code> 触发。默认情况下，tmux 使用 <code>C-b</code> 作为前缀键，<code>C-</code> 表示“按住Ctrl键”，<code>C-b</code> 表示同时按下 <code>Ctrl</code> 和 <code>b</code> 键。</p>
<p>将一个 Pane 分割成左右两个 Pane 的快捷键是 <code>C-b %</code>，这里前缀键为 <code>C-b</code>，命令键为 <code>%</code>，这意味着你需要同时按住 <code>Ctrl</code> 和 <code>b</code>，然后松开这两个键，最后输入 <code>%</code> 键，这样就可以将一个 Pane 垂直分割为两个 Pane 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2eb0eb7d09536df22c65fb4ababa714b.png" alt="split-pane" /></p>
<p>想要水平分割成上下两个 Pane 则使用 <code>C-b "</code>。</p>
<h1 id="在-pane-间切换">在 Pane 间切换</h1>
<p>假如我们在新的右侧的 Pane 中了，现在想回到左侧的 Pane 可以使用 <code>C-b Left</code>，其中 <code>Left</code> 为左方向键。根据 Pane 的排布，你可以输入不同的方向键去到你想去的 Pane 中，每次输入方向键前，都需要输入前缀键 <code>C-b</code>。</p>
<h1 id="关闭-pane">关闭 Pane</h1>
<p>关闭 Pane 输入 <code>exit</code> 然后回车或直接使用快捷键 <code>C-d</code> 就可以了。</p>
<h1 id="创建-window">创建 Window</h1>
<p>tmux 中创建一个新的 Window 可以类比于创建一个新的虚拟桌面。创建一个新的 Window 很简单，只需输入 <code>C-b c</code> 就可以了。<strong>通过底部状态栏的星号，你就可以知道当前你所在的 Window 是哪个了。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/de870030d6238465e53e20dab71e854c.png" alt="create-window" /></p>
<p>要切换到上一个 Window (根据状态栏中的顺序)，请使用 <code>C-b p</code>，要切换到下一个 Window，请使用 <code>C-b n</code>。如果创建了许多窗口，则使用 <code>C-b &lt;number&gt;</code> 会更加高效，其中 <code>&lt;number&gt;</code> 是指定要切换到的 Window 的前面的数字。</p>
<h1 id="session-管理">Session 管理</h1>
<p>如果你已完成或未完成你想要进行的工作，你都可以使用 <code>C-b d</code> 断开 detach 你当前的 Session，这样将会断开你的连接，但是这个 Session 仍会保留在后台中以供重新连接到该 Session 继续之前的工作。</p>
<p>假设你已经 detach 了你的 Session，当你想要重新连接 attach 之前 Session 时，你需要先确定是哪个 Session，通过以下命令可以查看当前所有的 Session：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>
<p>这将为你展示所有正在运行的会话的列表，在我们的示例中，该列表应类似于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0: 2 windows (created Sun Nov 10 22:30:50 2019) [80x12]</span><br></pre></td></tr></table></figure>
<p>要连接到该会话，需要再次启动tmux，但这一次告诉它要 attach 到哪个 Session：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux attach -t 0</span><br></pre></td></tr></table></figure>
<p>注：<code>-t 0</code> 是告诉 tmux attach 到哪个会话的参数，"0" 是 <code>tmux ls</code> 输出的第一部分。</p>
<p>如果你希望为 Session 指定一个更有意义的名称（而不是以 0 开头的数字），则可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new -s database</span><br></pre></td></tr></table></figure>
<p>这将创建一个名为 "database" 的新 Session。</p>
<p>你还可以重命名现有会话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux rename-session -t 0 database</span><br></pre></td></tr></table></figure>
<p>下次连接到该会话时，只需使用 <code>tmux attach -t database</code>，如果一次使用多个 Session，这对于我们区分不同的 Session 很有帮助。</p>
<p>当你想关闭 Session 时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t session-name</span><br></pre></td></tr></table></figure>
<h1 id="复制模式-copy-mode">复制模式 Copy Mode</h1>
<ol type="1">
<li><p>使用 <code>C-b :</code> 进入 tmux 末行模式，设置 Copy 模式使用按键模式为 vi 模式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:setw -g mode-keys vi</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>C-b [</code> 进入 Copy 模式</li>
<li>按 <code>Spacebar</code> 开始选中，移动光标选择选中区域</li>
<li>按 <code>Enter</code> 复制选中区域内容并退出 Copy 模式</li>
<li><p>将光标移动到指定位置，使用 <code>C-b ]</code> 粘贴</p></li>
</ol>
<h1 id="tmux-常用按键">tmux 常用按键</h1>
<h2 id="session">Session</h2>
<ul>
<li><p>创建一个新 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new-session</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:new</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个名为 "mysession" 的新 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new -s mysession</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:new -s mysession</span><br></pre></td></tr></table></figure></li>
<li><p>关闭或删除名为 "mysession" 的 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-sess -t mysession</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-session -t mysession</span></span><br></pre></td></tr></table></figure></li>
<li><p>关闭或删除当前会话以外的所有 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-session -a</span></span><br></pre></td></tr></table></figure></li>
<li><p>关闭或删除名为 "mysession" 会话以外的所有 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-session -a -t mysession</span></span><br></pre></td></tr></table></figure></li>
<li><p>重命名 Session</p>
<p><code>C-b $</code></p></li>
<li><p>Detach Session</p>
<p><code>C-b d</code></p></li>
<li><p>Detach others on the Session</p>
<p>通过 detach 其它 client 来最大化窗口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:attach -d</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux list-sessions</span></span><br></pre></td></tr></table></figure>
<p><code>C-b s</code></p></li>
<li><p>Attach 到最近的 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux at</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach-session</span></span><br></pre></td></tr></table></figure></li>
<li><p>Attach 到名为 "mysession" 的 Session</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux a -t mysession</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux at -t mysession</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach -t mysession</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach-session -t mysession</span></span><br></pre></td></tr></table></figure></li>
<li><p>切换到上一个 Session</p>
<p><code>C-b (</code></p></li>
<li><p>切换到下一个 Session</p>
<p><code>C-b )</code></p></li>
</ul>
<h2 id="window">Window</h2>
<ul>
<li><p>创建一个名为 "mysession" 的新 Session 并指定创建 Window 的名称为 "mywindow"</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new -s mysession -n mywindow</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建 Window</p>
<p><code>C-b c</code></p></li>
<li><p>重命名当前 Window</p>
<p><code>C-b ,</code></p></li>
<li><p>关闭当前 Window</p>
<p><code>C-b &amp;</code></p></li>
<li><p>切换到上一个 Window</p>
<p><code>C-b p</code></p></li>
<li><p>切换到下一个 Window</p>
<p><code>C-b n</code></p></li>
<li><p>根据数字切换 Window</p>
<p><code>C-b 0~9</code></p></li>
<li><p>重新排序窗口，交换编号为 2 和 1 的窗口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:swap-window -s 2 -t 1</span><br></pre></td></tr></table></figure></li>
<li><p>将当前窗口向左移动一个位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:swap-window -t -1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="pane">Pane</h2>
<ul>
<li><p>切换到上一次活动的 Pane</p>
<p><code>C-b ;</code></p></li>
<li><p>垂直分割 Pane</p>
<p><code>C-b %</code></p></li>
<li><p>水平分割 Pane</p>
<p><code>C-b "</code></p></li>
<li><p>向左移动当前 Pane</p>
<p><code>C-b &#123;</code></p></li>
<li><p>向右移动当前 Pane</p>
<p><code>C-b &#125;</code></p></li>
<li><p>切换到箭头方向的 Pane</p>
<p><code>C-b UP</code> <code>C-b DOWN</code> <code>C-b LEFT</code> <code>C-b RIGHT</code></p></li>
<li><p>切换到同步 Pane（将命令发送到所有 Pane）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:setw synchronize-panes</span><br></pre></td></tr></table></figure></li>
<li><p>在 Pane 布局之间切换</p>
<p><code>C-b Spacebar</code></p></li>
<li><p>切换到下一个 Pane</p>
<p><code>C-b o</code></p></li>
<li><p>展示 Pane 编号</p>
<p><code>C-b q</code></p></li>
<li><p>按编号切换 Pane</p>
<p><code>C-b q 0~9</code></p></li>
<li><p>缩放当前 Pane</p>
<p><code>C-b z</code></p></li>
<li><p>将 Pane 转换成 Window</p>
<p><code>C-b !</code></p></li>
<li><p>调整当前 Pane 的高度（按住第二个键是可选的）</p>
<p><code>C-b-UP</code> <code>C-b C-UP</code> <code>C-b-DOWN</code> <code>C-b C-DOWN</code></p></li>
<li><p>调整当前 Pane 的宽度（按住第二个键是可选的）</p>
<p><code>C-b-LEFT</code> <code>C-b C-LEFT</code> <code>C-b-RIGHT</code> <code>C-b C-RIGHT</code></p></li>
<li><p>关闭当前 Pane</p>
<p><code>C-b x</code></p></li>
</ul>
<h2 id="copy-mode">Copy Mode</h2>
<ul>
<li><p>设置 Copy 模式下使用 vi 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:setw -g mode-keys vi</span><br></pre></td></tr></table></figure></li>
<li><p>进入 Copy 模式</p>
<p><code>C-b [</code></p></li>
<li><p>进入 Copy 模式并向上滚动一页</p>
<p><code>C-b PgUp</code></p></li>
<li><p>退出 Copy 模式</p>
<p><code>q</code></p></li>
<li><p>转到第一行</p>
<p><code>g</code></p></li>
<li><p>转到最后一行</p>
<p><code>G</code></p></li>
<li><p>向上滚动</p>
<p><code>UP</code></p></li>
<li><p>向下滚动</p>
<p><code>DOWN</code></p></li>
<li><p>向左移动光标</p>
<p><code>h</code></p></li>
<li><p>向下移动光标</p>
<p><code>j</code></p></li>
<li><p>向上移动光标</p>
<p><code>k</code></p></li>
<li><p>向右移动光标</p>
<p><code>l</code></p></li>
<li><p>一次将光标向前移动一个单词</p>
<p><code>w</code></p></li>
<li><p>一次将光标向后移动一个单词</p>
<p><code>b</code></p></li>
<li><p>向前搜索</p>
<p><code>/</code></p></li>
<li><p>向后搜索</p>
<p><code>?</code></p></li>
<li><p>搜索结果中，跳到下一个关键字出现位置</p>
<p><code>n</code></p></li>
<li><p>搜索结果中，跳到上一个关键字出现位置</p>
<p><code>N</code></p></li>
<li><p>开始选中内容</p>
<p><code>Spacebar</code></p></li>
<li><p>清空选中内容</p>
<p><code>Esc</code></p></li>
<li><p>复制选中内容</p>
<p><code>Enter</code></p></li>
<li><p>粘贴 buffer_0 的内容</p>
<p><code>C-b ]</code></p></li>
<li><p>展示 buffer_0 的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:show-buffer</span><br></pre></td></tr></table></figure></li>
<li><p>将 Pane 中的所有可见内容复制到缓冲区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:capture-pane</span><br></pre></td></tr></table></figure></li>
<li><p>显示所有缓冲区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:list-buffers</span><br></pre></td></tr></table></figure></li>
<li><p>显示所有缓冲区并粘贴所选</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:choose-buffer</span><br></pre></td></tr></table></figure></li>
<li><p>将缓冲区内容保存到 buf.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:save-buffer buf.txt</span><br></pre></td></tr></table></figure></li>
<li><p>删除 buffer_1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:delete-buffer -b 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="misc">Misc</h2>
<ul>
<li><p>进入命令模式</p>
<p><code>C-b :</code></p></li>
<li><p>为所有 Session 设置 OPTION</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set -g OPTION</span><br></pre></td></tr></table></figure></li>
<li><p>为所有 Window 设置 OPTION</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:setw -g OPTION</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="help">Help</h2>
<ul>
<li><p>展示快捷键帮助</p>
<p><code>C-b ?</code></p></li>
<li><p>显示当前时间</p>
<p><code>C-b t</code></p></li>
</ul>
<h1 id="references">References</h1>
<p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/</a></p>
<p><a href="https://tmuxcheatsheet.com/">https://tmuxcheatsheet.com/</a></p>
<p><a href="https://github.com/tmux/tmux/blob/master/.github/README.md">https://github.com/tmux/tmux/blob/master/.github/README.md</a></p>
<p><a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">http://man.openbsd.org/OpenBSD-current/man1/tmux.1</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>CGI、FastCGI、WSGI、uwsgi、uWSGI</title>
    <url>/posts/60a486d8/</url>
    <content><![CDATA[<p>CGI、FastCGI、WSGI、uwsgi、uWSGI 的联系与区别。</p>
<span id="more"></span>
<h1 id="cgi">CGI</h1>
<h2 id="cgi-简介">CGI 简介</h2>
<p>CGI，（Common Gateway Interface）通用网关接口，是一个协议，是外部应用程序（CGI 程序）与 WEB 服务器之间的接口标准，该协议定义了 Web 服务器调用外部应用程序的时候需要输入的参数和给 Web 服务器的返回结果。</p>
<blockquote>
<p>最早的 Web 服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态 html。随着不断地发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php，asp 这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是我把请求参数发送给你，然后我接收你的处理结果给客户端。那这个约定就是 common gateway interface，简称 cgi。这个协议可以用 vb，c，php，python 来实现。cgi 只是接口协议，根本不是什么语言。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/186e51675e1703b5f78a80df497d8da9.png" alt="CGI" /></p>
<h2 id="web-服务器与-cgi-程序的交互">Web 服务器与 CGI 程序的交互</h2>
<p>WEB 服务器将根据 CGI 程序的类型决定向 CGI 程序的传送数据的方式，一般是通过标准输入/输出流和环境变量来与 CGI 程序间传递数据。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/30a4874213d4f92cef530f22aaac6ebf.png" alt="Web服务器与CGI程序的交互" /></p>
<p>CGI 程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI 程序还通过环境变量来得到输入，操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。Web 服务器和 CGI 接口又另外设置了一些环境变量，用来向 CGI 程序传递一些重要的参数。</p>
<p>常用 CGI 环境变量：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONTENT_TYPE</td>
<td>这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded，它表示数据来自于 HTML 表单。</td>
</tr>
<tr class="even">
<td>CONTENT_LENGTH</td>
<td>如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。</td>
</tr>
<tr class="odd">
<td>HTTP_COOKIE</td>
<td>客户机内的 COOKIE 内容。</td>
</tr>
<tr class="even">
<td>HTTP_USER_AGENT</td>
<td>提供包含了版本数或其他专有数据的客户浏览器信息。</td>
</tr>
<tr class="odd">
<td>PATH_INFO</td>
<td>这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。</td>
</tr>
<tr class="even">
<td>QUERY_STRING</td>
<td>如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号'?'分隔。</td>
</tr>
<tr class="odd">
<td>REMOTE_ADDR</td>
<td>这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。</td>
</tr>
<tr class="even">
<td>REMOTE_HOST</td>
<td>这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。</td>
</tr>
<tr class="odd">
<td>REQUEST_METHOD</td>
<td>提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。</td>
</tr>
<tr class="even">
<td>SCRIPT_FILENAME</td>
<td>CGI 脚本的完整路径</td>
</tr>
<tr class="odd">
<td>SCRIPT_NAME</td>
<td>CGI 脚本的的名称</td>
</tr>
<tr class="even">
<td>SERVER_NAME</td>
<td>这是你的 WEB 服务器的主机名、别名或 IP 地址。</td>
</tr>
<tr class="odd">
<td>SERVER_SOFTWARE</td>
<td>这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)</td>
</tr>
</tbody>
</table>
<h2 id="cgi-工作原理">CGI 工作原理</h2>
<p>每当客户请求 CGI 的时候，WEB 服务器就请求操作系统生成一个新的 CGI 解释器进程(如 php-cgi.exe)，CGI 的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。当然，这样在访问量很少没有并发的情况也行。但当访问量增大，并发存在，这种方式就不适合了，于是就有了 FastCGI。</p>
<h1 id="fastcgi">FastCGI</h1>
<h2 id="fastcgi-简介">FastCGI 简介</h2>
<p>CGI 的一个扩展，像是一个常驻(long-live)型的 CGI ，废除了 CGI fork-and-execute （来一个请求 fork 一个新进程处理，处理完再把进程 kill 掉）的工作方式，转而使用一种长生存期的方法，减少了进程消耗，提升了性能。</p>
<h2 id="fastcgi-工作原理">FastCGI 工作原理</h2>
<ul>
<li>（1）Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module)</li>
<li>（2）FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程(可见多个 php-cgi)并等待来自 Web Server 的连接。</li>
<li>（3）当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi。</li>
<li>（4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便被告知处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器(运行在 Web Server 中)的下一个连接。在 CGI 模式中， php-cgi 在此便退出了。</li>
</ul>
<h1 id="wsgi">WSGI</h1>
<p>WSGI，（WEB SERVER GATEWAY INTERFACE），Web 服务器网关接口，是一种 Web 服务器网关接口，它是一个 Web 服务器（如 Nginx，uWSGI 等服务器）与 web 应用（如 Flask 框架写的程序）通信的一种规范。</p>
<p>当前运行在 WSGI 协议之上的 Web 框架有 Bottle，Flask，Django</p>
<h1 id="uwsgi">uwsgi</h1>
<p>uwsgi 是一种线路协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型（type of information），每一个 uwsgi packet 前4 byte 为传输信息类型的描述，与 WSGI 协议是两种东西。</p>
<blockquote>
<p>对于 uwsgi，个人比较认同 <a href="https://baijiahao.baidu.com/s?id=1590941335729952485&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1590941335729952485&amp;wfr=spider&amp;for=pc</a> 的观点，"它是用于前端服务器与 uwsgi 的通信规范，相当于 FastCGI 的作用"。</p>
</blockquote>
<h1 id="uwsgi-1">uWSGI</h1>
<p>uWSGI 是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http等协议。</p>
<p>uWSGI 也可以当做中间件。</p>
<ul>
<li>如果是 Nginx+uWSGI+App，那 uWSGI 就是一个中间件</li>
<li>如果是 uWSGI+App，那它就是服务器</li>
</ul>
<h1 id="区分-wsgiuwsgiuwsgi">区分 WSGI、uwsgi、uWSGI</h1>
<ul>
<li>WSGI 是一种通信协议</li>
<li>uwsgi 是一种通信协议，常用于在 uWSGI 服务器与其他网络服务器的数据通信</li>
<li>而 uWSGI 是实现了 uwsgi 和 WSGI 两种协议的Web服务器</li>
</ul>
<blockquote>
<p>百度百科上说 uwsgi 是一种线路协议而不是通信协议，个人更倾向于 uwsgi 是类似 WSGI 的通信协议的说法，uwsgi 和 WSGI 都是基于 CGI 扩展出来的。</p>
</blockquote>
<h1 id="这些名词的关系">这些名词的关系</h1>
<p>假设我们使用 python 的 Django 框架写了一个网站，现在要将它挂在网上运行，我们一般需要：</p>
<ul>
<li>Nginx 做为代理服务器：负责静态资源发送（js、css、图片等）、动态请求转发以及结果的回复。</li>
<li>uWSGI 做为后端服务器：负责接收 Nginx 转发的请求并处理后发给 Django 应用以及接收 Django 应用返回信息转发给 Nginx。</li>
<li>Django 应用收到请求后处理数据并渲染相应的返回页面给 uWSGI 服务器。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/66e494e3f924aca43eeb30f6e8d9c92c.png" alt="这些名词的关系" /></p>
<h1 id="有-uwgsi-了-django-为什么还需要-nginx">有 uWGSI 了 Django 为什么还需要 Nginx</h1>
<p>Nginx 是一个 HTTP 和反向代理服务器</p>
<ul>
<li><p>正向代理</p>
<p>正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器</p></li>
<li><p>反向代理</p>
<p>反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器</p></li>
</ul>
<blockquote>
<p>更多关于正向代理和反向代理的内容可参考：</p>
<p><a href="https://www.cnblogs.com/Anker/p/6056540.html">https://www.cnblogs.com/Anker/p/6056540.html</a></p>
</blockquote>
<p>使用 Nginx 作为反向代理服务器的好处：</p>
<ul>
<li><p>安全</p>
<p>不管什么请求都要经过代理服务器，可以避免外部程序直接攻击 Web 服务器</p></li>
<li><p>负载均衡</p>
<p>根据请求情况和服务器负载情况，将请求分配给不同的 Web 服务器，保证服务器性能</p></li>
<li><p>提高 Web 服务器的 IO 性能</p>
<p>请求从客户端传到 Web 服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以由反向代理完整接受该请求，然后再传给 Web 服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过 Web 服务器</p></li>
</ul>
<h1 id="references">References</h1>
<p><a href="https://www.cnblogs.com/wanghetao/p/3934350.html">https://www.cnblogs.com/wanghetao/p/3934350.html</a></p>
<p><a href="https://baike.baidu.com/item/fastcgi/10880685">https://baike.baidu.com/item/fastcgi/10880685</a></p>
<p><a href="https://www.jianshu.com/p/679dee0a4193">https://www.jianshu.com/p/679dee0a4193</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1590941335729952485&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1590941335729952485&amp;wfr=spider&amp;for=pc</a></p>
<p><a href="https://blog.csdn.net/qq_35318838/article/details/61198183">https://blog.csdn.net/qq_35318838/article/details/61198183</a></p>
]]></content>
      <categories>
        <category>programming-language</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>常见HTTP状态码</title>
    <url>/posts/25bce1a2/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码（HTTP Status Code）</a>是用以表示网页服务器超文本传输协议响应状态的 3 位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。</p>
<span id="more"></span>
<h1 id="状态码的作用">状态码的作用</h1>
<p>HTTP 状态码的核心作用是 Web Server 用来告诉客户端，当前的网页请求发生了什么事，或者是当前 Web 服务器的响应状态。所以HTTP 状态码常用来判断和分析当前 Web 服务器的运行状况。</p>
<p>状态码位于 HTTP Response 的第一行中，会返回一个"三位数字的状态码"和一个"状态消息"。"三位数字的状态码"便于程序进行处理， "状态消息"便于人理解。</p>
<h1 id="http-状态码分类"><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码分类</a></h1>
<table>
<thead>
<tr class="header">
<th>状态码</th>
<th>响应类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1XX</td>
<td>消息（Informational）</td>
<td>请求已被服务器接收，继续处理</td>
</tr>
<tr class="even">
<td>2XX</td>
<td>成功（Success）</td>
<td>请求已成功被服务器接收、理解、并接受</td>
</tr>
<tr class="odd">
<td>3XX</td>
<td>重定向（Redirection）</td>
<td>需要后续操作才能完成这一请求</td>
</tr>
<tr class="even">
<td>4XX</td>
<td>请求错误（Client Error）</td>
<td>请求含有词法错误或者无法被执行</td>
</tr>
<tr class="odd">
<td>5XX</td>
<td>服务器错误（Server Error）</td>
<td>服务器在处理某个正确请求时发生错误</td>
</tr>
</tbody>
</table>
<h1 id="常见状态码">常见状态码</h1>
<h2 id="xx-信息性">1XX 信息性</h2>
<p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p>
<ul>
<li><p>100 Continue</p>
<p>这个临时响应是用来通知客户端它的请求头已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求主体，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p></li>
<li><p>101 Switching Protocols</p>
<p>服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。</p>
<p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。</p></li>
<li><p>102 Processing</p>
<p>WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。</p></li>
</ul>
<h2 id="xx-成功">2XX 成功</h2>
<p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<ul>
<li><p>200 OK</p>
<p>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。</p></li>
<li><p>204 No Content</p>
<p>服务器成功处理了请求，没有返回任何内容。</p>
<p>浏览器向服务器发送请求后收到了 204，那么浏览器页面不会发生更新，一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。</p></li>
<li><p>206 Partial Content</p>
<p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p></li>
</ul>
<h2 id="xx-重定向">3XX 重定向</h2>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p>
<ul>
<li><p>301 Moved Permanently</p>
<p>永久重定向，表示请求的资源已经永久的搬到了其他位置。</p>
<p>就是说资源已经被分配了新的 URI，新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p></li>
<li><p>302 Found</p>
<p>临时重定向，表示请求的资源临时搬到了其他位置。</p>
<p>请求的资源暂时被配到到了新的 URI 和301很像，只不过资源是临时移动，资源在将来可能还会改变；同样地，新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p></li>
<li><p>303 See Other</p>
<p>表示请求资源存在另一个 URI，应使用 GET 定向获取请求资源。</p>
<p>303 功能与 302 一样，区别只是 303 明确客户端应该使用 GET访问。</p>
<p>注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p></li>
<li><p>304 Not Modified</p>
<p>表示资源在由请求头中的 If-Modified-Since 或 If-None-Match 参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。虽然 304 被划分在 3XX，但和重定向并没有关系。</p></li>
<li><p>307 Temporary Redirect</p>
<p>临时重定向，和 302 有着相同含义。</p>
<p>尽管 302 标准禁止 POST 变为 GET，但没人听他的，而 307 就会遵照标准，不会从 POST 变为 GET，但处理响应行为，各个浏览器可能不同。</p></li>
</ul>
<h2 id="xx-客户端错误">4XX 客户端错误</h2>
<p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<ul>
<li><p>400 Bad Request</p>
<p>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</p></li>
<li><p>401 Unauthorized</p>
<p>该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p>
<p>注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。</p></li>
<li><p>403 Forbidden</p>
<p>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</p></li>
<li><p>404 Not Found</p>
<p>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p></li>
</ul>
<h2 id="xx-服务器错误">5XX 服务器错误</h2>
<p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p>
<ul>
<li><p>500 Internal Server Error</p>
<p>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。可能是 Web 应用有 bug 或临时故障，更有可能是服务器源代码有 bug。</p></li>
<li><p>503 Service Unavailable</p>
<p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。</p></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e/</url>
    <content><![CDATA[<p>在软件工程中，<a href="https://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a> 是一种软件设计模式，它将类的实例化限制为一个“单个”实例。当恰好需要一个对象来协调整个系统中的操作时，这是非常有用的。这个术语来自于单例的数学概念。单例模式中的“单例”通常用来代表那些本质上具有唯一性的系统组件（或者叫做资源），比如文件系统、资源管理器等等。</p>
<span id="more"></span>
<p>原文请看 刘望舒 博客 <a href="https://blog.csdn.net/itachi85/article/details/50510124">设计模式（二）单例模式的七种写法</a></p>
<h1 id="饿汉式">饿汉式</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快，这种基于类加载机制的方式避免了多线程的同步问题。</p>
<h1 id="懒汉式线程不安全">懒汉式（线程不安全）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍慢，而且多线程下不能保证唯一单例。</p>
<h1 id="懒汉式线程安全">懒汉式（线程安全）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程安全，但是每次调用 getInstance 方法时都需要进行同步，造成不必要的同步开销，而且大部分时候是不需要同步的，所以不建议用这种模式。</p>
<h1 id="双重检查加锁dcl">双重检查加锁（DCL）</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在 getInstance 方法中对 singleton 进行了两次判空，第一字是为了不必要的同步，第二次是在 singleton 等于 null 的情况下才创建实例。</p>
<p>DCL 优点是资源利用率高，第一次执行 getInstance 时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢，在高并发环境下也有一定的缺陷，虽然发生的概率很小。</p>
<p>DCL 虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但在某些情况也会出现失效的问题，也就是 DCL 失效，在《java并发编程实践》中建议用 <strong>静态内部类单例模式</strong> 来替代 DCL。</p>
<h1 id="静态内部类单例模式">静态内部类单例模式</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载 Singleton 类时并不会初始化 singleton，只要第一次调用 getInstance 方法时，虚拟机才加载 SingletonHolder 并初始化 singleton，这样不仅能确保线程安全也能保证 Singleton 类的唯一性，所以推荐使用静态内部类单例模式。</p>
<h1 id="枚举单例">枚举单例</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例.</p>
<p>而上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p>
<p>反序列化操作提供了 readResolve 方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException&#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举。</p>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Singleton_pattern">https://en.wikipedia.org/wiki/Singleton_pattern</a></p>
<p><a href="https://blog.csdn.net/itachi85/article/details/50510124">https://blog.csdn.net/itachi85/article/details/50510124</a></p>
]]></content>
      <categories>
        <category>cs</category>
        <category>software-engineering</category>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>design-pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类关系</title>
    <url>/posts/2f907c09/</url>
    <content><![CDATA[<p>设计模式之依赖、关联、聚合、组合关系的区别与联系。</p>
<span id="more"></span>
<h1 id="泛化关系">泛化关系</h1>
<p>对于面向对象编程语言，UML 中所说的泛化关系（Generalization）就是指类的继承关系。</p>
<p>如果一个类是另一个类的子类，那么 UML 通过使用一个实线连接两个类的 UML 图来表示二者之间的继承关系，实线的起始端是子类，终点端是父类，终点端使用一个空心的三角形表示实线的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b5dca2b6e1701f31101e5f1f92ace5da.png" alt="generalization" /></p>
<h1 id="实现关系">实现关系</h1>
<p>如果一个类实现了一个接口，那么类和接口的关系是实现关系（Realization）。</p>
<p>UML 通过使用虚线连接类和它所实现的接口，虚线的起始端是类，终点端是它实现的接口，终点端使用一个空心的三角形表示虚线的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/042280e2c8cdfe06e3226d3fadb8369d.png" alt="realization" /></p>
<h1 id="依赖关系">依赖关系</h1>
<p>如果 A 类中 <strong>某个方法的参数</strong> 用 B 类来声明的变量或某个方法返回的数据类型是 B 类型的，那么 A 和 B 的关系是依赖关系（Dependency），称 A 依赖于 B。</p>
<blockquote>
<p>在 java 中，依赖表现为：局部变量，方法中的参数和对静态方法的调用。</p>
</blockquote>
<p>如果 A 依赖于 B，那么 UML 通过使用一个虚线连接 A 和 B，虚线的起始端是 A，终点端是 B，终点端使用一个指向 B 的方向箭头表示虚线的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/987bc90abd9e364314bb32ebcf96d8a1.png" alt="dependency" /></p>
<h1 id="关联关系">关联关系</h1>
<p>如果 A 类的成员变量是用 B 类来声明的变量，那么 A 和 B 的关系是关联关系（Association），称 A 关联与 B。</p>
<blockquote>
<p>在 Java 语言中，关联关系一般使用成员变量来实现。</p>
</blockquote>
<p>如果 A 关联与 B，那么 UML 通过使用一个实线连接 A 和 B，实线的起始端是 A，终点端是 B，终点端使用一个指向 B 的方向箭头表示实线的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/478a722ef418c2878d8a6f504fa0bca5.png" alt="association" /></p>
<h2 id="聚合关系">聚合关系</h2>
<p>聚合（Aggregation）关系是关联关系的一种，是整体和个体之间的关系，如雁群和大雁的关系，即 <strong>has-a</strong> 关系。</p>
<p>在聚合关系中，两个类时处在不平等层次上的，一个代表整体，一个代表个体。</p>
<blockquote>
<p>在 Java 中，与关联关系一样，聚合关系也是通过成员变量实现的。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f531c43bad586c3c62bb655587dbdabe.png" alt="aggregation" /></p>
<h2 id="组合关系">组合关系</h2>
<p>组合（Composition）关系是关联关系的一种，是整体与部分的关系，这里的整体与部分是不可分的，如大雁和翅膀的关系，即 <strong>contains-a</strong> 关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cb2a1a986b157a99a3f164a86024080f.png" alt="composition" /></p>
<h1 id="耦合度强弱">耦合度强弱</h1>
<p>耦合度由弱至强：</p>
<p><strong>依赖关系 &lt; 关联关系 &lt; 聚合关系 &lt; 组合关系</strong></p>
]]></content>
      <categories>
        <category>cs</category>
        <category>software-engineering</category>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>design-pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现请求分页虚存页面替换算法</title>
    <url>/posts/a3679bbe/</url>
    <content><![CDATA[<p>请求分页虚存管理在地址映射过程中，若页表中发现所要访问的页不在主存，则产生缺页异常，操作系统接到此信号后，就调出缺页异常处理程序，根据页表中给出的磁盘地址，将该页面调入主存，是作业继续运行下去。如果主存中有空闲块，则分配一个页框，将新调入页面装入，并修改页表中相应页表项的驻留位及相应的主存块号；若此时主存中没有空闲块，则要淘汰某页面，若该页在此期间被修改过，要将其先写回磁盘，这个过程就是页面替换。</p>
<p>页面替换算法是虚拟存储管理实现的关键，好的算法能够减少和避免“颠簸”现象，本文在模拟实现 FIFO，LRU 和 OPT 几种经典页面替换算法的基础上，比较各种替换算法的效率及优缺点，从而了解虚拟存储实现的过程，理解内存页面调度的机制。</p>
<span id="more"></span>
<h1 id="数据结构设计">数据结构设计</h1>
<ol type="1">
<li>在请求分页虚存页面替换算法中，为实现从请求页到主存块的替换，需要在模拟程序中维护两个数据结构，即请求页面队列和主存块队列。</li>
<li>请求页面队列为进程所用，记录当前进程请求的页面块信息。</li>
<li>主存队列由系统维护，该队列保存当前系统中各主存块的状态（包括最后访问时间、闲忙状态等）。</li>
<li>以这两个数据结构为基础，实现各种替换算法，在系统中为用户请求寻找物理块。</li>
<li>本项目设计含有以下功能：
<ul>
<li>接收用户输入参数，包括程序长度（页面数）、页框个数及页面访问序列。</li>
<li>程序结果采用不同的标志区分命中、替换及直接加入空闲块。</li>
<li>实现 OPT、FIFO、LRU 等替换算法，并显示算法对应替换页面的过程。</li>
<li>计算各种页面替换算法的缺页中断率。</li>
</ul></li>
</ol>
<h1 id="程序设计">程序设计</h1>
<h2 id="页面替换算法基本思路">页面替换算法基本思路</h2>
<p>本程序并没有进入系统空间对实际进程页面进行控制，而是在用户空间用线性表的连续存储方式对进程页面替换进行模拟。</p>
<ol type="1">
<li><p>最佳页面替换算法（OPT）</p>
<p>淘汰以后不再需要的或者最远的将来才会用到的页面。</p></li>
<li><p>先进先出页面替换算法（FIFO）</p>
<p>淘汰最先调入主存的页面，或者说在主存中驻留时间最长的那一页。</p></li>
<li><p>最近最少使用页面替换算法（LRU）</p>
<p>淘汰在最近一段时间里较久未被访问的页面。它是根据程序执行时所具有的局部性来考虑的，即那些刚被使用过的页面可能马上还要被使用，而那些在较长时间里未被使用的页面一般可能不会马上使用。</p></li>
</ol>
<h2 id="请求页面队列">请求页面队列</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Page</span> &#123;</span> <span class="comment">// 页面</span></span><br><span class="line">    <span class="type">int</span> pageID;     <span class="comment">//页号</span></span><br><span class="line">&#125; Page;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PageQueue</span> &#123;</span> <span class="comment">//页面队列</span></span><br><span class="line">    Page page;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PageQueue</span> *<span class="title">next</span>;</span> <span class="comment">//下一页面</span></span><br><span class="line">&#125; PageQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process</span> &#123;</span> <span class="comment">// 进程结构</span></span><br><span class="line">    PageQueue pages; <span class="comment">//页面</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pageLength; <span class="comment">// 页面数</span></span><br><span class="line">&#125; process;<span class="comment">//进程</span></span><br></pre></td></tr></table></figure>
<h2 id="主存块队列">主存块队列</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Block</span> &#123;</span> <span class="comment">//块记录结构</span></span><br><span class="line">    Page *page; <span class="comment">//页面</span></span><br><span class="line">    <span class="type">long</span> time; <span class="comment">//最后访问时间</span></span><br><span class="line">    <span class="type">int</span> state; <span class="comment">//页块是否空闲</span></span><br><span class="line">&#125; Block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BlockQueue</span> &#123;</span> <span class="comment">//块队列</span></span><br><span class="line">    Block block;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BlockQueue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; BlockQueue;</span><br></pre></td></tr></table></figure>
<h2 id="进程">进程</h2>
<p>初始化进程以及进程需要访问的页面的序列，这里仅仅展示了进程接收输入序列作为页面访问序列的代码，本程序还提供了由系统自动生成的页面访问序列，可以指定访问页面的最大序号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageQueue *<span class="title function_">InitializePageQueueWithInput</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pageLength)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化页面，把首地址返回。如果分配失败，返回NULL</span></span><br><span class="line">    PageQueue *head = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pageLength; i++) &#123;</span><br><span class="line">        p = (PageQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PageQueue));</span><br><span class="line">        p-&gt;page.pageID = pages[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;page.pageID);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeProcessWithInput</span><span class="params">(process *proc, <span class="type">unsigned</span> <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化进程，接收手动输入的页面访问序列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程初始化：\n&quot;</span>);</span><br><span class="line">    proc-&gt;pageLength = pageSize;</span><br><span class="line">    proc-&gt;pages.next = InitializePageQueueWithInput(pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机生成页面访问序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageQueue *<span class="title function_">InitializePageQueue</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pageLength, <span class="type">int</span> maxPageID)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化页面，把首地址返回。如果分配失败，返回NULL</span></span><br><span class="line">    srand(<span class="number">100</span>);</span><br><span class="line">    PageQueue *head = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pageLength; i++) &#123;</span><br><span class="line">        p = (PageQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PageQueue));</span><br><span class="line">        p-&gt;page.pageID = rand() % (maxPageID + <span class="number">1</span>);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;page.pageID);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主存">主存</h2>
<p>接收用户输入参数，作为初始化主存的块数，也即页框数，使用一个单向链表模拟实现主存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BlockQueue *<span class="title function_">InitializeBlockQueue</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化主存块，把首地址返回，如果分配失败返回NULL</span></span><br><span class="line">    BlockQueue *block = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        p = (BlockQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BlockQueue));</span><br><span class="line">        p-&gt;block.time = <span class="number">0</span>;</span><br><span class="line">        p-&gt;block.state = <span class="number">0</span>;</span><br><span class="line">        p-&gt;block.page = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">NULL</span>) block = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主存队列的维护">主存队列的维护</h2>
<p>这里只展示主存队列一些重要操作的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BlockQueue *<span class="title function_">SearchPage</span><span class="params">(BlockQueue *blockQueue, Page page)</span> &#123;</span><br><span class="line">    <span class="comment">//搜索特定页面,根据页面ID进行匹配</span></span><br><span class="line">    BlockQueue *p = blockQueue;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;block.page-&gt;pageID == page.pageID)</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BlockQueue *<span class="title function_">SearchIdleBlock</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//搜索空闲块</span></span><br><span class="line">    BlockQueue *p = blockQueue;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.state == IDLE) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BlockQueue *<span class="title function_">GetOldestBlock</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//取得主存中停留最久的页面，返回它的地址</span></span><br><span class="line">    BlockQueue *p = blockQueue, *oldestAddr;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">long</span> oldest = p-&gt;block.time;</span><br><span class="line">    oldestAddr = p;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.time &lt; oldest) &#123;</span><br><span class="line">            oldest = p-&gt;block.time;</span><br><span class="line">            oldestAddr = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldestAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BlockQueue *<span class="title function_">GetLongestWithoutAccess</span><span class="params">(BlockQueue *blockQueue, PageQueue *currentPage)</span>&#123;</span><br><span class="line">    <span class="comment">//获取主存中最长时间将不会被访问的页面，返回其地址</span></span><br><span class="line">    BlockQueue *p = blockQueue, *longestAddr;</span><br><span class="line">    PageQueue *q = currentPage-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">    longestAddr = p;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;block.page-&gt;pageID == q-&gt;page.pageID) <span class="keyword">break</span>;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; max_count)&#123;</span><br><span class="line">            max_count = count;</span><br><span class="line">            longestAddr = p;</span><br><span class="line">        &#125;</span><br><span class="line">        q = currentPage-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="opt">OPT</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OPT</span><span class="params">(BlockQueue *blockQueue,process *proc)</span>&#123;</span><br><span class="line">    <span class="comment">//最佳页面替换算法</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SearchPage(blockQueue, currentPage-&gt;page) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetLongestWithoutAccess(blockQueue,currentPage);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fifo">FIFO</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FIFO</span><span class="params">(BlockQueue *blockQueue, process *proc)</span> &#123;</span><br><span class="line">    <span class="comment">//先进先出算法</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SearchPage(blockQueue, currentPage-&gt;page) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetOldestBlock(blockQueue);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lru">LRU</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LRU</span><span class="params">(BlockQueue *blockQueue, process *proc)</span> &#123;</span><br><span class="line">    <span class="comment">//最近最少使用</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BlockQueue *searchedBlock = SearchPage(blockQueue, currentPage-&gt;page);</span><br><span class="line">        <span class="keyword">if</span> (searchedBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            searchedBlock-&gt;block.time = Time++;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetOldestBlock(blockQueue);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="页面替换算法测试">页面替换算法测试</h1>
<p>测试页面访问序列（页框数为3）</p>
<p><code>7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2ed005480aea73531270b259c516ecf8.png" alt="main" /></p>
<h2 id="opt-1">OPT</h2>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |  缺页! 主存不存在该页面，载入空闲页框1</span><br><span class="line">页框2 |     |</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，载入空闲页框2</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  缺页! 主存不存在该页面，载入空闲页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  3  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  4  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  4  |</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  4  |</span><br><span class="line">页框3 |  3  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  3  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">缺页中断率为：45.00%</span><br></pre></td></tr></table></figure>
<p>运行结果部分截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/19b991f9fc2ce0f2ca54b7943d1e96cc.png" alt="OPT-run-res" /></p>
<p>对比准确数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/18e2d38666bc3c46ddfbc02e53b24f2c.png" alt="OPT-accurate-res" /></p>
<h2 id="fifo-1">FIFO</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |  缺页! 主存不存在该页面，载入空闲页框1</span><br><span class="line">页框2 |     |</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，载入空闲页框2</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  缺页! 主存不存在该页面，载入空闲页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  3  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  0  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  0  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |</span><br><span class="line">页框2 |  2  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  0  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |</span><br><span class="line">页框2 |  2  |</span><br><span class="line">页框3 |  3  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  2  |</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  2  |</span><br><span class="line">页框3 |  3  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  2  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  1  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  1  |</span><br><span class="line">页框3 |  2  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  1  |</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  1  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  1  |</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">缺页中断率为：75.00%</span><br></pre></td></tr></table></figure>
<p>运行结果部分截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9ab25e1471efa6fc84b89e866e179fa9.png" alt="FIFO-run-res" /></p>
<p>对比准确数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6656fcbdd9f3d4abc27c0bfa385b0f84.png" alt="FIFO-accurate-res" /></p>
<h2 id="lru-1">LRU</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |  缺页! 主存不存在该页面，载入空闲页框1</span><br><span class="line">页框2 |     |</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，载入空闲页框2</span><br><span class="line">页框3 |     |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  7  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |  缺页! 主存不存在该页面，载入空闲页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  1  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  3  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  2  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  3  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  2  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  4  |</span><br><span class="line">页框2 |  3  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  3  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  0  |</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  2  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |  缺页! 主存不存在该页面，替换页框1</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |</span><br><span class="line">页框2 |  3  |</span><br><span class="line">页框3 |  2  |  命中! 主存已存在该页面，位于页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |</span><br><span class="line">页框2 |  0  |  缺页! 主存不存在该页面，替换页框2</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  2  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  7  |  缺页! 主存不存在该页面，替换页框3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |</span><br><span class="line">页框2 |  0  |  命中! 主存已存在该页面，位于页框2</span><br><span class="line">页框3 |  7  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">页框1 |  1  |  命中! 主存已存在该页面，位于页框1</span><br><span class="line">页框2 |  0  |</span><br><span class="line">页框3 |  7  |</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">缺页中断率为：60.00%</span><br></pre></td></tr></table></figure>
<p>运行结果部分截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/07c11492cec05191921444f8e1ac9262.png" alt="LRU-run-res" /></p>
<p>对比准确数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3823955d9cd366853047ca90065bfef4.png" alt="LRU-accurate-res" /></p>
<h1 id="总结">总结</h1>
<p>分页虚拟存储管理既有优点又有缺点，优点是作业的程序和数据可按页分散存放在主存中，有效解决了碎片问题； 既有利于改进主存利用率，又有利于多道程序运行。缺点是要有硬件支持，要进行缺页中断处理，机器成本增加，系统开销加大。缺页中断率小是虚拟存储管理目标之一，而影响缺页中断率的因素主要有：主存页框数、页面大小、页面分配机制，替换算法、程序的局部性。好的页面替换算法能够降低缺页中断率。</p>
<h1 id="完整源码">完整源码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by wylu on 2018/1/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUSY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDLE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_Exist 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_NotExist_IDLE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_NotExist_NoIDLE 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> hitCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pages[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Page</span> &#123;</span> <span class="comment">// 页面</span></span><br><span class="line">    <span class="type">int</span> pageID;     <span class="comment">//页号</span></span><br><span class="line">&#125; Page;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PageQueue</span> &#123;</span> <span class="comment">//页面队列</span></span><br><span class="line">    Page page;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PageQueue</span> *<span class="title">next</span>;</span> <span class="comment">//下一页面</span></span><br><span class="line">&#125; PageQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Block</span> &#123;</span> <span class="comment">//块记录结构</span></span><br><span class="line">    Page *page; <span class="comment">//页面</span></span><br><span class="line">    <span class="type">long</span> time; <span class="comment">//最后访问时间</span></span><br><span class="line">    <span class="type">int</span> state; <span class="comment">//页块是否空闲</span></span><br><span class="line">&#125; Block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BlockQueue</span> &#123;</span> <span class="comment">//块队列</span></span><br><span class="line">    Block block;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BlockQueue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; BlockQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process</span> &#123;</span> <span class="comment">// 进程结构</span></span><br><span class="line">    PageQueue pages; <span class="comment">//页面</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pageLength; <span class="comment">// 页面数</span></span><br><span class="line">&#125; process;<span class="comment">//进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">GetSystemUtime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取系统当前时间的微秒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">nowit</span>;</span></span><br><span class="line">    gettimeofday(&amp;nowit, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span> * nowit.tv_sec + nowit.tv_usec;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockQueue *<span class="title function_">InitializeBlockQueue</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化主存块，把首地址返回，如果分配失败返回NULL</span></span><br><span class="line">    BlockQueue *block = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        p = (BlockQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BlockQueue));</span><br><span class="line">        p-&gt;block.time = <span class="number">0</span>;</span><br><span class="line">        p-&gt;block.state = <span class="number">0</span>;</span><br><span class="line">        p-&gt;block.page = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">NULL</span>) block = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetBlockQueueSize</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//获取块长度</span></span><br><span class="line">    BlockQueue *presentBlock = blockQueue;</span><br><span class="line">    <span class="type">int</span> blockQueueSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (presentBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        blockQueueSize++;</span><br><span class="line">        presentBlock = presentBlock-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> blockQueueSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ResetBlockQueue</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//清空块内容</span></span><br><span class="line">    BlockQueue *presentBlock = blockQueue;</span><br><span class="line">    <span class="keyword">while</span> (presentBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        presentBlock-&gt;block.page = <span class="literal">NULL</span>;</span><br><span class="line">        presentBlock-&gt;block.state = IDLE;</span><br><span class="line">        presentBlock-&gt;block.time = <span class="number">0</span>;</span><br><span class="line">        presentBlock = presentBlock-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PageQueue *<span class="title function_">InitializePageQueue</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pageLength, <span class="type">int</span> maxPageID)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化页面，把首地址返回。如果分配失败，返回NULL</span></span><br><span class="line">    srand(<span class="number">100</span>);</span><br><span class="line">    PageQueue *head = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pageLength; i++) &#123;</span><br><span class="line">        p = (PageQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PageQueue));</span><br><span class="line">        p-&gt;page.pageID = rand() % (maxPageID + <span class="number">1</span>);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;page.pageID);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PageQueue *<span class="title function_">InitializePageQueueWithInput</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pageLength)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化页面，把首地址返回。如果分配失败，返回NULL</span></span><br><span class="line">    PageQueue *head = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pageLength; i++) &#123;</span><br><span class="line">        p = (PageQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PageQueue));</span><br><span class="line">        p-&gt;page.pageID = pages[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;page.pageID);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) head = p;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeProcess</span><span class="params">(process *proc, <span class="type">unsigned</span> <span class="type">int</span> pageSize, <span class="type">unsigned</span> <span class="type">int</span> maxPageID)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化进程，随机生成进程页面访问序列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程初始化：\n&quot;</span>);</span><br><span class="line">    proc-&gt;pageLength = pageSize;</span><br><span class="line">    proc-&gt;pages.next = InitializePageQueue(pageSize, maxPageID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeProcessWithInput</span><span class="params">(process *proc, <span class="type">unsigned</span> <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化进程，接收手动输入的页面访问序列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程初始化：\n&quot;</span>);</span><br><span class="line">    proc-&gt;pageLength = pageSize;</span><br><span class="line">    proc-&gt;pages.next = InitializePageQueueWithInput(pageSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockQueue *<span class="title function_">SearchPage</span><span class="params">(BlockQueue *blockQueue, Page page)</span> &#123;</span><br><span class="line">    <span class="comment">//搜索特定页面</span></span><br><span class="line">    BlockQueue *p = blockQueue;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;block.page-&gt;pageID == page.pageID)</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockQueue *<span class="title function_">SearchIdleBlock</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//搜索空闲块</span></span><br><span class="line">    BlockQueue *p = blockQueue;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.state == IDLE) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetBlockLable</span><span class="params">(BlockQueue *blockQueue, BlockQueue *goalBlock)</span> &#123;</span><br><span class="line">    <span class="comment">//返回块号，编号从1开始</span></span><br><span class="line">    BlockQueue *p = blockQueue;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != goalBlock) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockQueue *<span class="title function_">GetOldestBlock</span><span class="params">(BlockQueue *blockQueue)</span> &#123;</span><br><span class="line">    <span class="comment">//取得主存中停留最久的页面，返回它的地址</span></span><br><span class="line">    BlockQueue *p = blockQueue, *oldestAddr;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">long</span> oldest = p-&gt;block.time;</span><br><span class="line">    oldestAddr = p;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;block.time &lt; oldest) &#123;</span><br><span class="line">            oldest = p-&gt;block.time;</span><br><span class="line">            oldestAddr = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldestAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockQueue *<span class="title function_">GetLongestWithoutAccess</span><span class="params">(BlockQueue *blockQueue, PageQueue *currentPage)</span>&#123;</span><br><span class="line">    <span class="comment">//获取主存中最长时间将不会被访问的页面，返回其地址</span></span><br><span class="line">    BlockQueue *p = blockQueue, *longestAddr;</span><br><span class="line">    PageQueue *q = currentPage-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">    longestAddr = p;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;block.page-&gt;pageID == q-&gt;page.pageID) <span class="keyword">break</span>;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; max_count)&#123;</span><br><span class="line">            max_count = count;</span><br><span class="line">            longestAddr = p;</span><br><span class="line">        &#125;</span><br><span class="line">        q = currentPage-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintBlockList</span><span class="params">(BlockQueue *blockQueue, <span class="type">int</span> pageID, <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    <span class="comment">//打印块信息</span></span><br><span class="line">    BlockQueue *presentBlock = blockQueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GetBlockQueueSize(blockQueue); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (presentBlock == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;页框%d &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (presentBlock-&gt;block.state == IDLE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;|     |\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (presentBlock-&gt;block.page-&gt;pageID != pageID) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %d  |\n&quot;</span>, presentBlock-&gt;block.page-&gt;pageID);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">                    <span class="keyword">case</span> COLOR_Exist:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;|  %d  |  命中! 主存已存在该页面，位于页框%d\n&quot;</span>,</span><br><span class="line">                               pageID, GetBlockLable(blockQueue, presentBlock));</span><br><span class="line">                        hitCount++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> COLOR_NotExist_IDLE:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;|  %d  |  缺页! 主存不存在该页面，载入空闲页框%d\n&quot;</span>,</span><br><span class="line">                               pageID, GetBlockLable(blockQueue, presentBlock));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> COLOR_NotExist_NoIDLE:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;|  %d  |  缺页! 主存不存在该页面，替换页框%d\n&quot;</span>,</span><br><span class="line">                               pageID, GetBlockLable(blockQueue, presentBlock));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        presentBlock = presentBlock-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FIFO</span><span class="params">(BlockQueue *blockQueue, process *proc)</span> &#123;</span><br><span class="line">    <span class="comment">//先进先出算法</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SearchPage(blockQueue, currentPage-&gt;page) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetOldestBlock(blockQueue);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LRU</span><span class="params">(BlockQueue *blockQueue, process *proc)</span> &#123;</span><br><span class="line">    <span class="comment">//最近最少使用</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BlockQueue *searchedBlock = SearchPage(blockQueue, currentPage-&gt;page);</span><br><span class="line">        <span class="keyword">if</span> (searchedBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            searchedBlock-&gt;block.time = Time++;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetOldestBlock(blockQueue);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OPT</span><span class="params">(BlockQueue *blockQueue, process *proc)</span>&#123;</span><br><span class="line">    <span class="comment">//最佳页面替换算法</span></span><br><span class="line">    PageQueue *currentPage = proc-&gt;pages.next;</span><br><span class="line">    <span class="keyword">while</span> (currentPage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SearchPage(blockQueue, currentPage-&gt;page) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PrintBlockList(blockQueue, currentPage-&gt;page.pageID, COLOR_Exist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BlockQueue *idleBlock = SearchIdleBlock(blockQueue);</span><br><span class="line">            <span class="keyword">if</span> (idleBlock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                idleBlock-&gt;block.state = BUSY;</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page = (Page *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Page));</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_IDLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idleBlock = GetLongestWithoutAccess(blockQueue,currentPage);</span><br><span class="line">                idleBlock-&gt;block.time = Time++;</span><br><span class="line">                idleBlock-&gt;block.page-&gt;pageID = currentPage-&gt;page.pageID;</span><br><span class="line">                PrintBlockList(blockQueue,</span><br><span class="line">                               currentPage-&gt;page.pageID, COLOR_NotExist_NoIDLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPage = currentPage-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectAlgorithm</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n========================================================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1.OPT\t2.FIFO\t3.LRU\t0.exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;========================================================\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">bool</span> isGoOn = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (isGoOn)&#123;</span><br><span class="line">        <span class="comment">//主存块数，即页框数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> blockNumber;</span><br><span class="line">        <span class="comment">//进程页面数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> pageNumber;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入主存块数(即页框数)：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;blockNumber);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入进程页面数：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;pageNumber);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;========================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t主存页框数: %u, 进程页面数: %u\n&quot;</span>, blockNumber, pageNumber);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;========================================================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BlockQueue *blocks;</span><br><span class="line">        process proc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是否手动输入访问序列? y/n\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (getchar() == <span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入访问序列：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pageNumber; ++i) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pages[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            InitializeProcessWithInput(&amp;proc,pageNumber);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            InitializeProcess(&amp;proc, pageNumber, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        blocks = InitializeBlockQueue(blockNumber);</span><br><span class="line"></span><br><span class="line">        SelectAlgorithm();</span><br><span class="line">        <span class="type">int</span> oper;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;oper))&#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">            hitCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    OPT(blocks, &amp;proc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    FIFO(blocks, &amp;proc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    LRU(blocks, &amp;proc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    SelectAlgorithm();</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;非法输入!请重新输入：&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;缺页中断率为：%.2lf%%\n&quot;</span>,(<span class="number">1</span>-(hitCount/pageNumber))*<span class="number">100</span>);</span><br><span class="line">            ResetBlockQueue(blocks);</span><br><span class="line">            SelectAlgorithm();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是否重新输入访问序列? y/n\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(getchar() != <span class="string">&#x27;y&#x27;</span>) isGoOn = <span class="literal">false</span>;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>os</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件权限</title>
    <url>/posts/1915f42e/</url>
    <content><![CDATA[<p>Linux 文件权限笔记，摘自《Linux命令行与shell脚本编程大全》，方便以后查阅。</p>
<span id="more"></span>
<h1 id="使用文件权限符">使用文件权限符</h1>
<p><code>ls</code> 命令可以查看 Linux 系统上的文件、目录和设备的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> –l</span></span><br><span class="line">total 68</span><br><span class="line">-rw-rw-r-- 1 rich rich 50 2010-09-13 07:49 file1.gz</span><br><span class="line">-rw-rw-r-- 1 rich rich 23 2010-09-13 07:50 file2</span><br><span class="line">-rw-rw-r-- 1 rich rich 48 2010-09-13 07:56 file3</span><br><span class="line">-rw-rw-r-- 1 rich rich 34 2010-09-13 08:59 file4</span><br><span class="line">-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog</span><br><span class="line">-rw-rw-r-- 1 rich rich 237 2010-09-18 13:58 myprog.c</span><br><span class="line">drwxrwxr-x 2 rich rich 4096 2010-09-03 15:12 test1</span><br><span class="line">drwxrwxr-x 2 rich rich 4096 2010-09-03 15:12 test2</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 代表文件</span><br><span class="line">d 代表目录</span><br><span class="line">l 代表链接</span><br><span class="line">c 代表字符型设备</span><br><span class="line">b 代表块设备</span><br><span class="line">n 代表网络设备</span><br></pre></td></tr></table></figure>
<p>之后有 3 组三字符的编码，每组定义了 3 种访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r 代表对象是可读的</span><br><span class="line">w 代表对象是可写的</span><br><span class="line">x 代表对象是可执行的</span><br></pre></td></tr></table></figure>
<p>若没有某种权限，在该权限位会出现单破折线 <code>-</code>。这 3 组权限分别对应对象的 3 个安全级别：</p>
<ul>
<li>对象的属主</li>
<li>对象的属组</li>
<li>系统的其他用户</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f7e251f2dfc9f1e7a3bdd9581cf69038.png" alt="linux-file-permission" /></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog</span><br></pre></td></tr></table></figure>
<p>文件 myprog 有下面3组权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwx: 文件的属主（设为登录名rich）</span><br><span class="line">rwx: 文件的属组（设为组名rich）</span><br><span class="line">r-x: 系统上的其他人</span><br></pre></td></tr></table></figure>
<p>这些权限说明登录名为 rich 的用户可以读取、写入以及执行这个文件（可以看作拥有全部权限）。类似地，rich 组的成员也可以读取、写入和执行这个文件。然而不属于 rich 组的其他用户只能读取和执行这个文件：<code>w</code> 被单破折线 <code>-</code> 取代了，说明这个安全级别没有写入权限。</p>
<h1 id="默认文件权限">默认文件权限</h1>
<p><code>umask</code> 命令用来设置所创建文件和目录的默认权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> newfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al newfile</span></span><br><span class="line">-rw-r--r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p><code>touch</code> 命令用分配给我的用户账户的默认权限创建了这个文件。umask 命令可以显示和设置这个默认权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span></span></span><br><span class="line">0022</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>第一位代表了一项特别的安全特性，叫作粘着位（sticky bit），后面的 3 位表示文件或目录对应的 umask 八进制值。要理解 umask 是怎么工作的，得先理解八进制模式的安全性设置。</p>
<p>八进制模式的安全性设置先获取这 3 个 <code>rwx</code> 权限的值，然后将其转换成 3 位二进制值，用一个八进制值来表示。在这个二进制表示中，每个位置代表一个二进制位。因此，如果读权限是唯一置位的权限，权限值就是 <code>r--</code>，转换成二进制值就是 100，代表的八进制值是 4。下表列出了可 能会遇到的组合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2cff36c2043d5335ed3654981871c965.png" alt="permission-combination" /></p>
<p>八进制模式先取得权限的八进制值，然后再把这三组安全级别（属主、属组和其他用户）的八进制值顺序列出。因此，八进制模式的值 664 代表属主和属组成员都有读取和写入的权限，而其他用户都只有读取权限。</p>
<p>八进制的 umask 值是 0022，而上面所创建的文件的八进制权限却是 644。umask 值只是个掩码，它会屏蔽掉不想授予该安全级别的权限。要把 umask 值从对象的全权限值中减掉。对文件来说，全权限的值是 666（所有用户都有读和写的权限）；而对目录来说，则是 777（所有用户都有读、写、执行权限）。所以在上例中，文件一开始的权限是 666，减去 umask 值 022 之后，剩下的文件权限就成了 644。</p>
<p>在大多数 Linux 发行版中，umask 值通常会设置在 <code>/etc/profile</code> 启动文件中，可以用 umask 命令为默认 umask 设置指定一个新值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> 026</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> newfile2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l newfile2</span></span><br><span class="line">-rw-r----- 1 rich rich 0 Sep 20 19:46 newfile2</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>在把 umask 值设成 026 后，默认的文件权限变成了 640，因此新文件现在对组成员来说是只读的，而系统里的其他成员则没有任何权限。umask 值同样会作用在创建目录上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> newdir</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">drwxr-x--x 2 rich rich 4096 Sep 20 20:11 newdir/</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>由于目录的默认权限是 777，umask 作用后生成的目录权限不同于生成的文件权限。umask 值 026 会从 777 中减去，留下来 751 作为目录权限设置。</p>
<h1 id="改变权限">改变权限</h1>
<p><code>chmod</code> 命令用来改变文件和目录的安全性设置。该命令的格式如下：</p>
<p><code>chmod options mode file</code></p>
<p>mode 参数可以使用 <strong>八进制模式</strong> 或 <strong>符号模式</strong> 进行安全性设置。八进制模式设置非常直观，直接用期望赋予文件的标准 3 位八进制权限码即可。</p>
<h2 id="options">options</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 或 --changes： 效果类似 &quot;-v&quot; 参数，但仅回报更改的部分</span><br><span class="line">-f 或 --quiet 或 --silent： 不显示错误信息</span><br><span class="line">-R 或 --recursive： 递归处理，将指令目录下的所有文件及子目录一并处理</span><br><span class="line">-v 或 --verbose： 显示指令执行过程</span><br></pre></td></tr></table></figure>
<h2 id="八进制模式">八进制模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 760 newfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rwxrw---- 1 rich rich 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>八进制文件权限会自动应用到指定的文件上。</p>
<h2 id="符号模式">符号模式</h2>
<p>与通常用到的 3 组三字符权限字符不同，chmod 命令采用了另一种方法。下面是在符号模式下指定权限的格式。</p>
<p><code>[ugoa…][[+-=][rwxXstugo…]</code></p>
<ul>
<li><p>第一组字符定义了权限作用的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u 代表用户</span><br><span class="line">g 代表组</span><br><span class="line">o 代表其他</span><br><span class="line">a 代表上述所有</span><br></pre></td></tr></table></figure></li>
<li><p>第二组的符号表示在现有权限基础上增加权限 <code>+</code>，还是在现有权限基础上移除权限 <code>-</code>，或是将权限设置成后面的值 <code>=</code>。</p></li>
<li><p>第三组符合代表作用到设置上的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X：如果对象是目录或者它已有执行权限，赋予执行权限。</span><br><span class="line">s：运行时重新设置 UID 或 GID。</span><br><span class="line">t：保留文件或目录。</span><br><span class="line">u：将权限设置为跟属主一样。</span><br><span class="line">g：将权限设置为跟属组一样。</span><br><span class="line">o：将权限设置为跟其他用户一样。</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+r newfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lF newfile</span></span><br><span class="line">-rwxrw-r-- 1 rich rich 0 Sep 20 19:16 newfile*</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>不管其他用户在这一安全级别之前都有什么权限，<code>o+r</code> 都给这一级别添加读取权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u-x newfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lF newfile</span></span><br><span class="line">-rw-rw-r-- 1 rich rich 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p><code>u-x</code> 移除了属主已有的执行权限。注意 ls 命令的 <code>-F</code> 选项，它能够在具有执行权限的文件名后加一个星号。</p></li>
</ul>
<p>options 为 chmod 命令提供了另外一些功能。<code>-R</code> 选项可以让权限的改变递归地作用到文件和子目录。你可以使用通配符指定多个文件，然后利用一条命令将权限更改应用到这些文件上。</p>
<h1 id="改变所属关系">改变所属关系</h1>
<h2 id="chown">chown</h2>
<p><code>chown</code> 命令用来改变文件的属主，格式如下：</p>
<p><code>chown options owner[.group] file</code></p>
<p>可用登录名或 UID 来指定文件的新属主。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chown</span> dan newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>chown 命令也支持同时改变文件的属主和属组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chown</span> dan.shared newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>可以只改变一个目录的默认属组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chown</span> .rich newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>如果 Linux 系统采用和用户登录名匹配的组名，可以只用一个条目就改变二者。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chown</span> <span class="built_in">test</span>. newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rw-rw-r-- 1 test test 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>chown 命令采用一些不同的选项参数。<code>-R</code> 选项配合通配符可以递归地改变子目录和文件的所属关系。<code>-h</code> 选项可以改变该文件的所有符号链接文件的所属关系。</p>
<p><strong>只有 root 用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须是原属组和目标属组的成员。</strong></p>
<h2 id="chgrp">chgrp</h2>
<p><code>chgrp</code> 命令用来改变文件的默认属组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> shared newfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l newfile</span></span><br><span class="line">-rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>用户账户必须是这个文件的属主，除了能够更换属组之外，还得是新组的成员。现在 shared 组的任意一个成员都可以写这个文件了。这是 Linux 系统共享文件的一个途径。</p>
<h1 id="references">References</h1>
<p>《Linux命令行与shell脚本编程大全》Richard Blum Christine Bresnahan</p>
<p><a href="http://man.linuxde.net/chmod">http://man.linuxde.net/chmod</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下读取Linux系统文件 Paragon ExtFS for Windows</title>
    <url>/posts/2882d36c/</url>
    <content><![CDATA[<p>Paragon ExtFS for Windows 拥有简洁美观的界面，能够实现 Windows 下读写 Linux 系统文件，读写 ext 文件系统的文件。</p>
<span id="more"></span>
<h1 id="说明">说明</h1>
<ul>
<li>很多人在刚开始想在物理机上玩耍 Linux 的时候，都会选择安装双系统，一般会保留原来的 Windows，然后再装一个 Linux。</li>
<li>Windows 和 Linux 的文件系统不同，linux 使用的是 ext(Ext2、Ext3、Ext4)，因为 Linux 支持很多不同的文件系统也包括 ntfs，所以 Linux 系统下一般能直接访问 ntfs 格式的移动硬盘或者 U 盘；</li>
<li>但是，在 Windows 下要访问 Linux 的文件系统比较困难，需要借助第三方软件，Windows 目前使用的文件系统主要是 ntfs，也支持(FAT、FAT32);</li>
<li>如果你装了双系统，在 Windows 中是看不到任何 ext 格式的磁盘分区的。</li>
</ul>
<h1 id="paragon-extfs">Paragon ExtFS</h1>
<ul>
<li>Paragon ExtFS for Windows 是一款适用于 Windows 操作系统的软件，也有 for Mac 的，支持读写 ext2/ext3/ext4 文件系统，操作简单方便，界面简洁美观。</li>
<li>更多介绍详见 <a href="https://www.paragon-software.com/business/extfs-for-windows/">官网</a></li>
</ul>
<h1 id="下载">下载</h1>
<ul>
<li><p>这是一款收费的软件，要 120RMB，可以试用 10 天，网上有破解版的，这里提供一下链接：</p>
<p><a href="https://pan.baidu.com/s/1r6Tzga6gOoqLKDaaQW2cRQ">https://pan.baidu.com/s/1r6Tzga6gOoqLKDaaQW2cRQ</a></p></li>
<li><p>该文件是一个压缩包，里面包含了 Paragon ExtFS for Windows 4.2.651 和用于破解的注册机 v1.2</p></li>
</ul>
<h1 id="安装激活">安装激活</h1>
<h2 id="安装">安装</h2>
<ul>
<li>将下载的压缩包解压</li>
<li>运行 Setup.msi 安装 Paragon ExtFS，进入软件安装向导，点击 next</li>
<li>勾选接受许可协议条款，点击 next</li>
<li>根据具体情况选择软件安装路径，点击 next</li>
<li>点击 install 安装</li>
<li>安装完成，勾选试用 10 天，点击 next，点击 Finish 退出向导</li>
</ul>
<h2 id="激活">激活</h2>
<ul>
<li><p>安装完成后先不要运行软件，解压注册机压缩包，将 keygen 和另外两个文件放到 ExtFS 的安装目录下</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/af1907ff5c631b5c1d13e7169cbc4b2c.png" alt="keygen" /></p></li>
<li>运行 keygen，点击 Patch RSA 2048，分别把 Paragon Extfs for Windows.exe 和 extservice.exe 这两个文件 patch，patch 成功后在安装录下会生成两个同名的新 exe 文件，原文件被自动备份为后缀名为 bak 的文件</li>
<li>点击 Generate 生成 License，出现提示后点击 ok</li>
<li><p>激活完成，运行软件</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/edef68d102c1dc2e227364a6c88a1938.png" alt="paragon-extfs" /></p>
<h1 id="references">References</h1>
<p><a href="http://www.sdbeta.com/wg/2018/0523/222982.html%20https://blog.csdn.net/myweihp/article/details/83066568">http://www.sdbeta.com/wg/2018/0523/222982.html https://blog.csdn.net/myweihp/article/details/83066568</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04 一键安装深度截图工具 Deepin Screenshot</title>
    <url>/posts/dd26a250/</url>
    <content><![CDATA[<p>Deepin Screenshot，一个简洁易用的截图工具。</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3ef2f6b713fc37904fc8231611445c1a.jpg" alt="deepin-screenshot" /></p>
<h1 id="安装">安装</h1>
<ul>
<li>打开 Ubuntu Software</li>
<li>搜索 deepin</li>
<li>点击 Deepin Screenshot</li>
<li>点击 Install</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/55e3bddee910141b03e77155077d4848.png" alt="search-deepin-screenshot" /></p>
<h1 id="添加快捷键">添加快捷键</h1>
<ul>
<li>打开 Settings</li>
<li>选择 Devices，选择 Keyboard</li>
<li>滑到底部选择添加</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ee5344028e015137a1ddaed77d6a5821.png" alt="keyboard" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e8b0a38f209b49fc7bddc7b6bd6db1f7.png" alt="shortcut" /></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 清除旧版本内核</title>
    <url>/posts/11259beb/</url>
    <content><![CDATA[<p><strong>内核清除须谨慎，建议保留两个内核版本。</strong></p>
<span id="more"></span>
<ol type="1">
<li>查看当前使用内核版本号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0b1b12df0848d9dbe0372a58b412a799.png" alt="show-current-kernel" /></p>
<ol start="2" type="1">
<li>查看所有的版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --get-selections | grep linux</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c8ad1e570fd199b4e7b0fbf925bb12d0.png" alt="show-all-kernel" /></p>
<p>我这里因为已近删除过了，所以只有两个内核版本，一个是当前使用的版本 <code>4.15.0-38-generic</code>，一个是低版本的旧内核。我只保留了两个内核版本，其他都已经删除了。</p>
<p>内核映像文件主要包括以下类型：</p>
<ul>
<li>linux-image-版本号：内核映像文件</li>
<li>linux-headers-版本号：内核头文件</li>
<li>linux-image-extra-版本号：内核扩展文件</li>
</ul>
<ol start="3" type="1">
<li>把标记 install 的 <strong>旧版本</strong> 内核删除</li>
</ol>
<p><strong>一定不能删除当前使用的内核</strong></p>
<p>执行下面的命令进行删除，<strong>具体版本号根据自己的情况选择</strong>，以删除旧版本 <code>4.4.0-138</code> 为例进行说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt autoremove linux-headers-4.4.0-138 linux-image-4.4.0-138-generic</span><br></pre></td></tr></table></figure>
<p>注：这里的 linux-headers-4.4.0-138-generic linux-image-extra-4.4.0-138-generic 两个文件不需要写，在执行上面的命令时会顺带被删除。</p>
<ol start="4" type="1">
<li>再次运行步骤 2 的命令，如果有标记 deinstall 的内核文件，参考下面进行删除</li>
</ol>
<p>根据自己的实际情况选择要删除的文件，下面是示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -P linux-image-4.4.0-138-generic</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>更新引导</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub2</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="http://blog.sciencenet.cn/blog-506416-1040221.html">http://blog.sciencenet.cn/blog-506416-1040221.html</a></p>
<p><a href="https://blog.csdn.net/bless_forever/article/details/79630315">https://blog.csdn.net/bless_forever/article/details/79630315</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 系统托盘topbar隐藏albert图标</title>
    <url>/posts/c4aa3fad/</url>
    <content><![CDATA[<p>albert 是一个类似于 Mac OS Spotlight 的搜索软件，可以设置搜索本地应用、文件，也可以搜索浏览器书签，可以当作计算器等。</p>
<span id="more"></span>
<h1 id="安装-albert">安装 albert</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:nilarimogard/webupd8</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install albert</span><br></pre></td></tr></table></figure>
<h1 id="设置快捷键">设置快捷键</h1>
<p>安装完毕执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(albert &amp;)</span><br></pre></td></tr></table></figure>
<p>因为是第一次运行，会提示你设置快捷键用来弹出 Albert 界面，点击 Yes 进行设置，先设置 Hotkey</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/57bc80d363cc51e99ae5b4abef04f870.png" alt="set-hotkey" /></p>
<p>快捷键的设置看个人喜好，尽量不要与其它快捷键冲突；可以根据需要设置主题，其它配置也是。</p>
<p>设置完后，按下快捷键就会弹出搜索窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4aec73324d4651dda1b9cf062d03ccc8.png" alt="albert-search" /></p>
<p>如果你什么都搜不到，那就重新进入设置界面添加你需要进行搜索的源</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/35f5d261a2ee7ff5e4b367a1974a9376.png" alt="albert-settings" /></p>
<p>这里也是根据个人需要进行选择，比如第二个是添加计算器的功能</p>
<h1 id="设置开机启动">设置开机启动</h1>
<p>参考 <a href="https://wylu.github.io/posts/a4104dc1/">Ubuntu 16.04 设置imwheel开机启动</a></p>
<p>albert 的安装路径可以如下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis albert</span><br></pre></td></tr></table></figure>
<h1 id="隐藏-albert-图标">隐藏 albert 图标</h1>
<p>albert 默认会在系统托盘 topbar 显示图标，如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6b31260fefd827abc518129d781d72ae.png" alt="albert-tray-icon" /></p>
<ul>
<li><p>治标不治本的方法</p>
<p>右击 albert 图标进入 Settings 界面，取消勾选 <code>Show tray icon</code>，这种方法重新系统后还是会显示。</p></li>
<li><p>彻底解决的办法</p>
<p>直接修改 albert 的配置文件，cd 到配置目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.config/albert/</span><br></pre></td></tr></table></figure>
<p>修改 albert.conf 文件的 <code>showTray</code> 属性值，默认 <code>showTray=true</code> 表示在系统托盘展示图标，这里要修改成 <code>showTray=false</code> 表示默认不展示，vim 修改后保存退出即可。</p></li>
</ul>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 设置imwheel开机启动</title>
    <url>/posts/a4104dc1/</url>
    <content><![CDATA[<p>imwheel 是一组命令工具可以用来调节鼠标滚轮的行为，修改滚轮速度。</p>
<span id="more"></span>
<h1 id="安装-imwheel">安装 imwheel</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install imwheel</span><br></pre></td></tr></table></figure>
<p>查看安装位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis imwheel</span><br></pre></td></tr></table></figure>
<h1 id="配置">配置</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.imwheelrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;.*&quot;</span><br><span class="line">None,      Up,      Button4, 2</span><br><span class="line">None,      Down,    Button5, 2</span><br><span class="line">Control_L, Up,      Control_L|Button4</span><br><span class="line">Control_L, Down,    Control_L|Button5</span><br><span class="line">Shift_L,   Up,      Shift_L|Button4</span><br><span class="line">Shift_L,   Down,    Shift_L|Button5</span><br><span class="line">None,      Thumb1,  Alt_L|Left</span><br><span class="line">None,      Thumb2,  Alt_L|Right</span><br></pre></td></tr></table></figure>
<ul>
<li>第二行和第三行中的 "2" 代表滚动的行数，可以根据需要来修改这个配置。</li>
<li>首行中 <code>".*"</code> 用来指定在哪些应用中生效，<code>".*"</code> 表示全部应用生效，可以执行 "man imwheel" 查看更多帮助信息。</li>
<li>第四行和第五行可以让鼠标支持 <code>左Ctrl+上下滚动</code> (比如在浏览器中支持放大)</li>
<li>第六行和第七行可以让鼠标支持 <code>左Shift+上下滚动</code> (不同应用有不同的作用)，实测似乎并没有什么卵用。</li>
<li>最后两行用来开启鼠标侧键功能。</li>
</ul>
<h1 id="启动运行">启动运行</h1>
<p>查看是否有已启动 imwheel 进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep imwheel</span><br></pre></td></tr></table></figure>
<p>为了不要启动多个 imwheel，可以结束已有进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo killall imwheel</span><br></pre></td></tr></table></figure>
<p>然后重新启动程序，修改配置后需要重启才能生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">imwheel</span><br></pre></td></tr></table></figure>
<h1 id="设置开机启动">设置开机启动</h1>
<p>试过在 rc.local 中执行 <code>nohup /usr/bin/imwheel &amp;</code>，排查该命令确实在开机后被执行，但是 <code>ps</code> 却看不到该进程，没找到具体原因。</p>
<p>实测 Ubuntu 16.04 简单有效的方法：</p>
<ul>
<li><p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gnome-session-properties</span><br></pre></td></tr></table></figure></li>
<li>弹出窗口为"启动应用程序首选项"</li>
<li>点击右侧添加</li>
<li>输入描述和软件路径</li>
<li><p>编辑完毕点击保存</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6491c34aa862fa4663c60e655642064e.png" alt="set-imwheel" /></p>
<h1 id="references">References</h1>
<p><a href="http://www.linuxdown.net/install/soft/2016/0314/5034.html">http://www.linuxdown.net/install/soft/2016/0314/5034.html</a></p>
<p><a href="https://blog.csdn.net/u010820857/article/details/82776382">https://blog.csdn.net/u010820857/article/details/82776382</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>vi/vim常用命令</title>
    <url>/posts/706b7df8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0d141a96847df24c99d25a228b63232e.png" alt="vim-editor" /></p>
<p><a href="https://zh.wikipedia.org/wiki/Vim">Vim</a> 是从 vi 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p>
<span id="more"></span>
<h1 id="vi-简介">vi 简介</h1>
<p>vi 是 Unix 和 Linux 操作系统使用的终端文本编辑器，任何一台安装了 Unix 或 Linux 的机器都会提供这套软件，它是系统管理员手中的得力工具。vim 是 vi 的升级版，它不仅兼容 vi 的所有指令（命令），而且还具有一些新特性。</p>
<h1 id="vi-的操作模式">vi 的操作模式</h1>
<p>vi 有三种操作状态：</p>
<ul>
<li>命令模式（command mode）</li>
<li>插入模式（insert mode）</li>
<li>末行模式（last line mode）</li>
</ul>
<p>它们的功能如下：</p>
<ol type="1">
<li><p>命令模式：当执行 vi 后，首先会进入命令模式（指令模式），此时输入的任何字符都被视为命令。命令模式用于控制屏幕光标的移动，文本的删除，移动复制某区段，进入插入模式下，或者进入末行模式。</p></li>
<li><p>插入模式：在命令模式下输入相应的插入命令进入该模式。只有在插入模式下，才可做文字数据输入和其它编辑操作，按 ESC 键可回到命令模式。</p></li>
<li><p>末行模式：在命令模式输入某些特殊字符，如 "/"、"?" 和 ":"，可进入末行模式。在该模式下可存储文件或离开编辑器，也可以设置编辑环境，如寻找字符串、列出行号等。</p></li>
</ol>
<p>vi 三种工作模式的转换如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4fbcfcc788656a7d73ec4045ab862e2b.png" alt="vi工作模式" /></p>
<h1 id="vi-的进入与退出">vi 的进入与退出</h1>
<h2 id="进入-vi">进入 vi</h2>
<p>若要编辑文件 myfile，执行如下执行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">vi myfile</span></span><br></pre></td></tr></table></figure>
<p>终端显示 vi 的编辑窗口，进入命令模式。也可以直接输入 vi 创建一个新文件，然后在退出时保存文件或者丢弃。</p>
<h2 id="退出-vi">退出 vi</h2>
<p>如果在插入模式下，则先利用 ESC 键返回命令模式，然后可选用下列指令退出 vi。</p>
<ul>
<li><code>:q!</code> 离开 vi，并放弃刚才的修改。</li>
<li><code>:wq</code> 保存退出。</li>
<li><code>:ZZ</code> 保存退出。</li>
<li><code>:x</code> 同 <code>:wq</code></li>
<li><code>:w</code> 保存但不退出。</li>
<li><code>:q</code> 退出 vi，若文件被修改过，则会被要求确认是否放弃修改。此指令可以 w 配合使用。</li>
</ul>
<p><strong>注意：如果不知道当前处于何种模式，可以多按几次 ESC 键，以便确认进入命令模式。</strong></p>
<h1 id="vivim-常用命令">vi/vim 常用命令</h1>
<h2 id="命令模式的常用命令">命令模式的常用命令</h2>
<p>在命令模式下可以进行文本的编辑工作。使用下列命令，配合一般键盘上的功能键，如方向键、Insert 键、Delete 键等，就可以利用 vi 来处理文本数据了。</p>
<h3 id="光标的移动">光标的移动</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th>功能键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>h</code></td>
<td>向左移一个字符</td>
<td><span class="math inline">\(\leftarrow\)</span></td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>向右移一个字符</td>
<td><span class="math inline">\(\rightarrow\)</span></td>
</tr>
<tr class="odd">
<td><code>j</code></td>
<td>向上移一个字符</td>
<td><span class="math inline">\(\uparrow\)</span></td>
</tr>
<tr class="even">
<td><code>k</code></td>
<td>向下移一个字符</td>
<td><span class="math inline">\(\downarrow\)</span></td>
</tr>
<tr class="odd">
<td><code>0</code></td>
<td>移至该行之首</td>
<td>Home</td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td>移至该行之末</td>
<td>End</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>移至该行的第一个非空白字符处</td>
<td></td>
</tr>
<tr class="even">
<td><code>H</code></td>
<td>移至窗口的第一行</td>
<td></td>
</tr>
<tr class="odd">
<td><code>M</code></td>
<td>移至窗口的中间那行</td>
<td></td>
</tr>
<tr class="even">
<td><code>L</code></td>
<td>移至窗口的最后一行</td>
<td></td>
</tr>
<tr class="odd">
<td><code>G</code></td>
<td>移至该文件的最后一行</td>
<td></td>
</tr>
<tr class="even">
<td><code>nG</code></td>
<td>移至该文件的第 n 行</td>
<td></td>
</tr>
<tr class="odd">
<td><code>gg</code></td>
<td>移至该文件的第一行</td>
<td></td>
</tr>
<tr class="even">
<td><code>w</code></td>
<td>跳到下一个单词</td>
<td></td>
</tr>
<tr class="odd">
<td><code>b</code></td>
<td>跳到上一个单词</td>
<td></td>
</tr>
<tr class="even">
<td><code>&#123;</code></td>
<td>按段移动，上移</td>
<td></td>
</tr>
<tr class="odd">
<td><code>&#125;</code></td>
<td>按段移动，下移</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="翻屏与滚屏">翻屏与滚屏</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th>功能键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Ctrl+f</code></td>
<td>向后翻一屏</td>
<td>PageDown</td>
</tr>
<tr class="even">
<td><code>Ctrl+b</code></td>
<td>向前翻一屏</td>
<td>PageUp</td>
</tr>
<tr class="odd">
<td><code>Ctrl+d</code></td>
<td>向后翻半屏</td>
<td></td>
</tr>
<tr class="even">
<td><code>Ctrl+u</code></td>
<td>向前翻半屏</td>
<td></td>
</tr>
<tr class="odd">
<td><code>zt</code></td>
<td>光标所在行移动到窗口顶端</td>
<td></td>
</tr>
<tr class="even">
<td><code>zz</code></td>
<td>光标所在行移动到窗口中间</td>
<td></td>
</tr>
<tr class="odd">
<td><code>zb</code></td>
<td>光标所在行移动到窗口底部</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="删除剪切与修改">删除（剪切）与修改</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th>功能键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>x</code></td>
<td>删除光标所在的字符</td>
<td>Delete</td>
</tr>
<tr class="even">
<td><code>X</code></td>
<td>删除光标的前一个字符</td>
<td></td>
</tr>
<tr class="odd">
<td><code>dd</code></td>
<td>删除光标所在的行</td>
<td></td>
</tr>
<tr class="even">
<td><code>ndd</code></td>
<td>删除包括光标所在行的 n 行文本</td>
<td></td>
</tr>
<tr class="odd">
<td><code>d0</code></td>
<td>删除从光标前一个字符开始一直到行首的文本</td>
<td></td>
</tr>
<tr class="even">
<td><code>dw</code></td>
<td>删除从光标开始的一个单词</td>
<td></td>
</tr>
<tr class="odd">
<td><code>D</code></td>
<td>删除从光标开始一直到行末的文本</td>
<td></td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>删除光标所在字符并进入插入模式</td>
<td></td>
</tr>
<tr class="odd">
<td><code>S</code></td>
<td>删除光标所在行并进入插入模式</td>
<td></td>
</tr>
<tr class="even">
<td><code>r</code></td>
<td>替换光标所在字符</td>
<td></td>
</tr>
<tr class="odd">
<td><code>R</code></td>
<td>进入替换状态，替换光标所在字符及以后的字符，按 ESC 退出替换状态</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="复制粘贴">复制粘贴</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>yy</code> 或 <code>Y</code></td>
<td>复制光标所在行</td>
</tr>
<tr class="even">
<td><code>nyy</code> 或 <code>nY</code></td>
<td>复制包括光标所在行开始的 n 行</td>
</tr>
<tr class="odd">
<td><code>p</code> （小写）</td>
<td>粘贴到光标的下一行</td>
</tr>
<tr class="even">
<td><code>P</code> （大写）</td>
<td>粘贴到光标的上一行</td>
</tr>
</tbody>
</table>
<h3 id="撤销与反撤销">撤销与反撤销</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u</code></td>
<td>撤销</td>
</tr>
<tr class="even">
<td><code>Ctrl+r</code></td>
<td>反撤销</td>
</tr>
</tbody>
</table>
<h3 id="可视模式">可视模式</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>v</code></td>
<td>选中文本（按字符移动）</td>
</tr>
<tr class="even">
<td><code>V</code></td>
<td>选中文本（按行移动）</td>
</tr>
</tbody>
</table>
<p><strong>可视模式可以配合 <code>d</code>，<code>y</code> 实现对文本块的删除（剪切），复制。</strong></p>
<p><strong>vim 下还支持配合 <code>&lt;</code>，<code>&gt;</code> 实现对文本块的左右移动，首先使用 <code>v</code> 或 <code>V</code> 选择要移动的部分，然后按 <code>Ctrl+v</code> 选中该文本块，接着可根据需要左移 <code>&lt;</code> 或 右移 <code>&gt;</code> 。</strong></p>
<h3 id="文本行移动缩进">文本行移动（缩进）</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&gt;&gt;</code></td>
<td>向右移动（缩进）</td>
</tr>
<tr class="even">
<td><code>&lt;&lt;</code></td>
<td>向左移动（缩进）</td>
</tr>
<tr class="odd">
<td><code>&gt;</code> （vim 支持）</td>
<td>向右移动（缩进）</td>
</tr>
<tr class="even">
<td><code>&lt;</code> （vim 支持）</td>
<td>向左移动（缩进）</td>
</tr>
</tbody>
</table>
<h3 id="重复命令">重复命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>.</code></td>
<td>重复执行上一次的命令</td>
</tr>
</tbody>
</table>
<h3 id="退出命令">退出命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ZZ</code></td>
<td>退出保存，相当于末行模式下的 <code>:wq</code></td>
</tr>
</tbody>
</table>
<h2 id="插入模式">插入模式</h2>
<p>所有以下命令都能从命令模式进入插入模式。</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>i</code></td>
<td>从光标所在字符前面开始插入字符</td>
</tr>
<tr class="even">
<td><code>I</code></td>
<td>从光标所在行的行首开始插入字符</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>从光标所在字符后面开始插入字符</td>
</tr>
<tr class="even">
<td><code>A</code></td>
<td>从光标所在行的行末开始插入字符</td>
</tr>
<tr class="odd">
<td><code>o</code></td>
<td>光标所在行向下新增一行</td>
</tr>
<tr class="even">
<td><code>O</code></td>
<td>光标所在行向上新增一行</td>
</tr>
</tbody>
</table>
<h2 id="末行模式">末行模式</h2>
<h3 id="查找命令">查找命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/exp</code></td>
<td>往前查找字符串 exp，<code>n</code> 下一个，<code>N</code> 上一个</td>
</tr>
<tr class="even">
<td><code>?exp</code></td>
<td>往后查找字符串 exp，<code>n</code> 下一个，<code>N</code> 上一个</td>
</tr>
</tbody>
</table>
<h3 id="替换命令">替换命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:%s/abc/123/g</code></td>
<td>将当前文件中所有的 abc 替换成 123</td>
</tr>
<tr class="even">
<td><code>:1,10s/abc/123/g</code></td>
<td>将 1 到 10 行的 abc 全部替换成 123</td>
</tr>
</tbody>
</table>
<h3 id="退出命令-1">退出命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:q</code></td>
<td>退出程序</td>
</tr>
<tr class="even">
<td><code>:q!</code></td>
<td>强制退出，不保存修改</td>
</tr>
<tr class="odd">
<td><code>:w</code></td>
<td>保存修改</td>
</tr>
<tr class="even">
<td><code>:w filename</code></td>
<td>将编辑内容存为名为 filename 的文件</td>
</tr>
<tr class="odd">
<td><code>:wq</code></td>
<td>保存退出</td>
</tr>
<tr class="even">
<td><code>:x</code></td>
<td>若有修改保存，退出程序</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>:wq</code> <strong>强制性</strong> 写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。</p>
<p><code>:x</code> 写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。</p>
</blockquote>
<h3 id="其它命令">其它命令</h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:set nu</code></td>
<td>显示行号</td>
</tr>
<tr class="even">
<td><code>:set nonu</code></td>
<td>不显示行号</td>
</tr>
<tr class="odd">
<td><code>:set ff</code></td>
<td>查看文件格式</td>
</tr>
<tr class="even">
<td><code>:set ff=unix</code></td>
<td>修改文件格式为 unix</td>
</tr>
<tr class="odd">
<td><code>:noh</code></td>
<td>取消搜索结果高亮</td>
</tr>
</tbody>
</table>
<h1 id="vivim-键盘图">vi/vim 键盘图</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2e6d55e2974573e5535a96e39222b327.png" alt="vi-vim-cheat-sheet-cn" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a6a85c411f68f37654a409d43b3e2908.gif" alt="vi-vim-cheat-sheet" /></p>
]]></content>
      <categories>
        <category>os</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>多边形游戏</title>
    <url>/posts/56db4dd4/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4f36f336193157e79be59d786cd4bd29.jpg" alt="polygon-game" /></p>
<p>项目要求实现给出得到最高分的删除方案且界面友好。</p>
<span id="more"></span>
<h1 id="游戏简介">游戏简介</h1>
<p>多边形游戏是一个单人玩的游戏，开始时有一个由 n 个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符 <code>+</code> 或 <code>*</code>。所有边依次用整数从 1 到 n 编号，游戏第 1 步，将一条边删除。</p>
<p>随后 n-1 步按以下方式操作：</p>
<ol type="1">
<li><p>选择一条边 E 以及由 E 连接着的两个顶点 <span class="math inline">\(V_1\)</span> 和 <span class="math inline">\(V_2\)</span>;</p></li>
<li><p>用一个新的顶点取代边E以及由E连接着的两个顶点 <span class="math inline">\(V_1\)</span> 和 <span class="math inline">\(V_2\)</span>。将由顶点 <span class="math inline">\(V_1\)</span> 和 <span class="math inline">\(V_2\)</span> 的整数值通过边E上的运算得到的结果赋予新顶点。</p></li>
</ol>
<p>最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。</p>
<p>问题：对于给定的多边形，计算最高分。</p>
<h1 id="算法设计">算法设计</h1>
<h2 id="最优子结构性质">最优子结构性质</h2>
<p>设所给的多边形的顶点和边的顺时针序列为</p>
<p><span class="math display">\[
op[1], v[1], op[2], v[2], ..., op[n], v[n]
\]</span></p>
<p>其中，<span class="math inline">\(op[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 条边所对应的运算符，<span class="math inline">\(v[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 个顶点上的数组，<span class="math inline">\(i=1\sim n\)</span>。</p>
<p>在所给多边形中，从顶点 <span class="math inline">\(i(1 \leq i \leq n)\)</span> 开始，长度为 <span class="math inline">\(j\)</span> (链中有 <span class="math inline">\(j\)</span> )个顶点的顺时针链 <span class="math inline">\(p(i+s)\)</span> 可表示为</p>
<p><span class="math display">\[
v[i], op[i+1], ..., v[i+j-1]
\]</span></p>
<p>如果这条链的最后一次合并运算在 <span class="math inline">\(op[i+s]\)</span> 处发生 <span class="math inline">\((1 \leq s \leq j-1)\)</span>，则可以在 <span class="math inline">\(op[i+s]\)</span> 处将链分割为两个子链 <span class="math inline">\(p(i,s)\)</span> 和 <span class="math inline">\(p(i+s,j-s)\)</span>。</p>
<p>设 <span class="math inline">\(m_1\)</span> 是对子链 <span class="math inline">\(p(i,s)\)</span> 的任意一种合并方式得到的值，而 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 分别是在所有可能的合并中得到的最小值和最大值。<span class="math inline">\(m_2\)</span> 是 <span class="math inline">\(p(i+s,j-s)\)</span> 的任意一种合并方式得到的值，而 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(d\)</span> 分别是在所有可能的合并中得到的最小值和最大值。依此定义有</p>
<p><span class="math display">\[
a \leq m_1 \leq b,\; c \leq m_2 \leq d
\]</span></p>
<p>由于子链 <span class="math inline">\(p(i,s)\)</span> 和 <span class="math inline">\(p(i+s,j-s)\)</span> 的合并方式决定了 <span class="math inline">\(p(i,j)\)</span> 在 <span class="math inline">\(op[i+s]\)</span> 处断开后的合并方式，在 <span class="math inline">\(op[i+s]\)</span> 处合并后其值为</p>
<p><span class="math display">\[
m =(m_1)op[i+s](m_2)
\]</span></p>
<ul>
<li><p>当 <span class="math inline">\(op[i+s]=&#39;+&#39;\)</span> 时，显然有</p>
<p><span class="math display">\[
a+c \leq m \leq b+d
\]</span></p></li>
<li><p>当 <span class="math inline">\(op[i+s]=&#39;*&#39;\)</span> 时，由于 <span class="math inline">\(v[i]\)</span> 可取负整数，子链的最大值相乘未必能得到主链的最大值。但最大值一定是在边界点达到，即</p>
<p><span class="math display">\[
min \left\{ ac,ad, bc,bd \right\} \leq m \leq max \left\{ ac,ad,bc,bd\right\}
\]</span></p>
<p>换句话说，主链的最大值和最小值可由子链的最大值和最小值得到。例如，当 <span class="math inline">\(m=ac\)</span> 时，最大主链由它的两条最小链组成；同理当 <span class="math inline">\(m=bd\)</span> 时，最大主链由它的两条最大子链组成。</p></li>
</ul>
<h2 id="递归求解">递归求解</h2>
<p>为了求链合并的最大值，必须同时求子链合并的最大值和最小值。</p>
<p>设 <span class="math inline">\(m[i,j,0]\)</span> 是链 <span class="math inline">\(p(i,j)\)</span> 合并的最小值，而 <span class="math inline">\(m[i,j,1]\)</span> 是最大值。若最优合并在 <span class="math inline">\(op[i+s]\)</span> 处将 <span class="math inline">\(p(i,j)\)</span> 分成两个长度小于 <span class="math inline">\(j\)</span> 的子链 <span class="math inline">\(p(i,i+s)\)</span> 和 <span class="math inline">\(p(i+s,j-s)\)</span>，且从顶点 <span class="math inline">\(i\)</span> 开始的长度小于 <span class="math inline">\(j\)</span> 的子链的最大值和最小值均已计算出。记</p>
<p><span class="math display">\[
a=m[i,i+s,0]\\
b=m[i,i+s,1]\\
c =m[i+s,j-s,0]\\
d=m[i+s,j-s,1]
\]</span></p>
<ol type="1">
<li>当 <span class="math inline">\(op[i+s]=&#39;+&#39;​\)</span> 时，</li>
</ol>
<p><span class="math display">\[
m[i,j,0]=a+c\\
m[i,j,1]=b+d
\]</span></p>
<ol start="2" type="1">
<li>当 <span class="math inline">\(op[i+s]=&#39;*&#39;\)</span> 时，</li>
</ol>
<p><span class="math display">\[
m[i,j,0]=min\left\{ac,ad,bc,bd\right\}\\
m[i,j,1]=min\left\{ac,ad,bc,bd\right\}
\]</span></p>
<p>综合 (1) 和 (2)，将 <span class="math inline">\(p(i,j)\)</span> 在 <span class="math inline">\(op[i+s]\)</span> 处断开的最大值记为 <span class="math inline">\(maxf(i,j,s)\)</span>，最小值记为 <span class="math inline">\(minf(i,j,s)\)</span>，则</p>
<p><span class="math display">\[
minf(i,j,s)=\left\{\begin{matrix} a+c \qquad \qquad \qquad \qquad \; op[i+s]=&#39;+&#39; \\ min\left\{ ac,ad,bc,bd\right\} \qquad op[i+s]=&#39;*&#39; \end{matrix}\right.
\]</span></p>
<p><span class="math display">\[
maxf(i,j,s)=\left\{\begin{matrix} b+d \qquad \qquad \qquad \qquad \; op[i+s]=&#39;+&#39; \\ min\left\{ ac,ad,bc,bd\right\} \qquad op[i+s]=&#39;*&#39; \end{matrix}\right.
\]</span></p>
<p>由于最优断开位置 <span class="math inline">\(s\)</span> 有 <span class="math inline">\(1 \leq s \leq j-1\)</span> 的 j-1 种情况，由此可知</p>
<p><span class="math display">\[
m[i,j,0] = \min_{i \leq s &lt; j }\left\{minf(i,j,s)\right\} \qquad 1 \leq i,j \leq n \\
m[i,j,1] = \max_{i \leq s &lt; j }\left\{maxf(i,j,s)\right\} \qquad 1 \leq i,j \leq n
\]</span></p>
<p>初始边界为</p>
<p><span class="math display">\[
m[i,1,0]=v[i] \qquad 1 \leq i \leq n \\
m[i,1,1]=v[i] \qquad 1 \leq i \leq n
\]</span></p>
<p><span class="math inline">\(m[i,n,1]\)</span> 即为游戏首次删去第 <span class="math inline">\(i\)</span> 条边后得到的最大得分。</p>
<h1 id="算法描述">算法描述</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PloygonAgent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n; <span class="comment">//多边形边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] op; <span class="comment">//每条边的对应的操作（从1开始计数）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] v; <span class="comment">//每个顶点数值（从1开始计数）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[][][] m; <span class="comment">//m[i][n][1]：代表一开始删除第i条边，长度为n的链（包含n个顶点），所能得到的最大值</span></span><br><span class="line">                          <span class="comment">//m[i][n][0]：代表一开始删除第i条边，长度为n的链，所能得到的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][][] cut; <span class="comment">//记录合并点的数组</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack; <span class="comment">//用栈保存合并边的顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstDelEdge; <span class="comment">//记录最优情况下，第1条删除的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> bestScore; <span class="comment">//记录最优得分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PloygonAgent</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span>[][][] m, <span class="type">char</span>[] op, <span class="type">int</span>[] v)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.op = op;</span><br><span class="line">        <span class="built_in">this</span>.v = v;</span><br><span class="line">        <span class="built_in">this</span>.cut = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Long&gt; <span class="title function_">minMax</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> s, <span class="type">int</span> j, HashMap&lt;String, Long&gt; resMap)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (i+s-<span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> m[i][s][<span class="number">0</span>], b = m[i][s][<span class="number">1</span>], c = m[r][j-s][<span class="number">0</span>], d = m[r][j-s][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(op[r] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            resMap.put(<span class="string">&quot;minf&quot;</span>, a+c);</span><br><span class="line">            resMap.put(<span class="string">&quot;maxf&quot;</span>, b+d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">long</span>[] e = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, a*c, a*d, b*c, b*d&#125;;</span><br><span class="line">            <span class="type">long</span> <span class="variable">minf</span> <span class="operator">=</span> e[<span class="number">1</span>], maxf = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minf &gt; e[k]) minf = e[k];</span><br><span class="line">                <span class="keyword">if</span>(maxf &lt; e[k]) maxf = e[k];</span><br><span class="line">            &#125;</span><br><span class="line">            resMap.put(<span class="string">&quot;minf&quot;</span>, minf);</span><br><span class="line">            resMap.put(<span class="string">&quot;maxf&quot;</span>, maxf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">polyMax</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Long&gt; resMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= n; j++)&#123; <span class="comment">//链的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= n; i++)&#123; <span class="comment">//删除第i条边</span></span><br><span class="line">                m[i][j][<span class="number">0</span>] = Long.MAX_VALUE;</span><br><span class="line">                m[i][j][<span class="number">1</span>] = Long.MIN_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>; s &lt; j; s++)&#123; <span class="comment">//断开的位置</span></span><br><span class="line">                    resMap = <span class="built_in">this</span>.minMax(i, s, j, resMap);</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">0</span>] &gt; resMap.get(<span class="string">&quot;minf&quot;</span>))&#123;</span><br><span class="line">                        m[i][j][<span class="number">0</span>] = resMap.get(<span class="string">&quot;minf&quot;</span>);</span><br><span class="line">                        cut[i][j][<span class="number">0</span>] = s; <span class="comment">//记录该链取得最小值的断点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">1</span>] &lt; resMap.get(<span class="string">&quot;maxf&quot;</span>))&#123;</span><br><span class="line">                        m[i][j][<span class="number">1</span>] = resMap.get(<span class="string">&quot;maxf&quot;</span>);</span><br><span class="line">                        cut[i][j][<span class="number">1</span>] = s; <span class="comment">//记录该链取得最大值的断点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bestScore = m[<span class="number">1</span>][n][<span class="number">1</span>];</span><br><span class="line">        firstDelEdge = <span class="number">1</span>; <span class="comment">//一开始删除的边，初始化为第一条边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bestScore &lt; m[i][n][<span class="number">1</span>])&#123;</span><br><span class="line">                bestScore = m[i][n][<span class="number">1</span>];</span><br><span class="line">                firstDelEdge = i; <span class="comment">//如果一开始删除第i边有更优的结果，则更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123; <span class="comment">//一开始删除第i条边所能得到的最大分数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; &quot;</span> + m[i][n][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDelEdge=&quot;</span> + firstDelEdge);</span><br><span class="line">        getBestSolution(firstDelEdge, n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123; <span class="comment">//打印在删除第firstDelEdge条边后的最优合并顺序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;stack--&gt; &quot;</span> + String.valueOf(stack.pop()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bestScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最优的合并序列，存入stack中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 表示子链从哪个顶点开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 子链的长度（如j=2，表示链中有两个顶点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needMax 是否取链的最大值，如果传入值为false，则取子链的最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getBestSolution</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span> needMax)</span>&#123;</span><br><span class="line">        <span class="type">int</span> s,r;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//链中只有一个顶点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">2</span>)&#123;</span><br><span class="line">            s = cut[i][j][<span class="number">1</span>];</span><br><span class="line">            r = (i+s-<span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">            stack.push(r);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//只有两个顶点时，没有子链，无须递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链中有两个以上的顶点时，将最优的边入栈</span></span><br><span class="line">        s = needMax ? cut[i][j][<span class="number">1</span>] : cut[i][j][<span class="number">0</span>];</span><br><span class="line">        r = (i+s-<span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">        stack.push(r);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.op[r] == <span class="string">&#x27;+&#x27;</span>)&#123; <span class="comment">//当合并计算为&quot;+&quot;操作时</span></span><br><span class="line">            <span class="keyword">if</span>(needMax)&#123; <span class="comment">//如果合并得到的父链需要取得最大值</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">true</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//如果合并得到的父链需要取得最小值</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">false</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//当合并计算为&quot;*&quot;操作时</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> m[i][s][<span class="number">0</span>], b = m[i][s][<span class="number">1</span>], c = m[r][j-s][<span class="number">0</span>], d = m[r][j-s][<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span>[] e = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, a*c, a*d, b*c, b*d&#125;;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mergeMax</span> <span class="operator">=</span> e[<span class="number">1</span>], mergeMin = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>; k&lt;=<span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[k] &gt; mergeMax) mergeMax = e[k];</span><br><span class="line">                <span class="keyword">if</span>(e[k] &lt; mergeMin) mergeMin = e[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">merge</span> <span class="operator">=</span> (needMax) ? mergeMax : mergeMin; <span class="comment">//判断合并得到的父链是取最大还是取最小</span></span><br><span class="line">            <span class="keyword">if</span>(merge == e[<span class="number">1</span>])&#123; <span class="comment">//子链1和子链2都取最小</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">false</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(merge == e[<span class="number">2</span>])&#123; <span class="comment">//子链1取最小，子链2取最大</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">false</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(merge == e[<span class="number">3</span>])&#123; <span class="comment">//子链1取最大，子链2取最小</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">true</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//子链1和子链2都取最大</span></span><br><span class="line">                getBestSolution(i, s, <span class="literal">true</span>);</span><br><span class="line">                getBestSolution(r, j-s, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPolygon</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">midBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">botBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;v.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            midBuilder.append(<span class="string">&quot;|&quot;</span>).append(String.valueOf(v[i])).append(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">            midBuilder.append(<span class="string">&quot;--&quot;</span>).append(op[i + <span class="number">1</span>]).append(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        midBuilder.append(<span class="string">&quot;|&quot;</span>).append(String.valueOf(v[v.length - <span class="number">1</span>])).append(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        botBuilder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;midBuilder.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> || i == midBuilder.length()-<span class="number">2</span>) botBuilder.append(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == (midBuilder.length()-<span class="number">1</span>) / <span class="number">2</span>) botBuilder.append(op[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> botBuilder.append(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(midBuilder.toString());</span><br><span class="line">        System.out.println(botBuilder.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">long</span>[][][] m = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>][n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="type">char</span>[] op = <span class="keyword">new</span> <span class="title class_">char</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                op[i] = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">                v[i] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">PloygonAgent</span> <span class="variable">ploygonAgent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PloygonAgent</span>(n, m, op, v);</span><br><span class="line">            ploygonAgent.showPolygon();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                m[i][<span class="number">1</span>][<span class="number">0</span>] = m[i][<span class="number">1</span>][<span class="number">1</span>] = v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> ploygonAgent.polyMax();</span><br><span class="line">            System.out.println(<span class="string">&quot;BestScore=&quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最优合并顺序">最优合并顺序</h1>
<p>在上述算法中，为了能简单地得到一个最优的合并顺序，使用了一个 <code>cut[][][]</code> 数组来记录断点位置。</p>
<p>其中只在 <code>m[i][j][0]</code> 或 <code>m[i][j][1]</code> 进行更新时，相应地也进行更新，保证 <code>cut[i][j][0]</code> 为 <code>m[i][j][0]</code> 的最优断点，<code>cut[i][j][1]</code> 为 <code>m[i][j][1]</code> 的最优断点。</p>
<p>这里需要说明的是，<code>cut[i][j][]</code> 中保存的 s，指的是距离顶点 i 的距离，若 s=1，即从说明从 i 顶点开始（包括 i 顶点）只包含一个顶点，也就说要从 i 顶点连着的顺时针的边断开。</p>
<p>其实，计算得到最优分数的过程是一个自底向上的过程，而寻找最优合并顺序则相反，是一个自顶向下的过程。</p>
<p>基本的思路就是，使用一个栈来保存合并边的编号</p>
<ul>
<li>(1)从最后的主链开始，找到最优的合并边，入栈</li>
<li>(2)判断合并边的符号，如果是 <code>+</code>，转 (3)；如果是 <code>*</code>，转 (4)</li>
<li>(3)如果为 <code>+</code>，判断主链需要最大还是最小
<ul>
<li>如需最大，则递归取两条子链的最大；</li>
<li>否则，递归取两条子链的最小</li>
</ul></li>
<li>(4)如果为 <code>*</code>，判断主链需要最大还是最小
<ul>
<li>如需最大，则在 <code>&#123;ac, ad, bc, bd&#125;</code> 取最大的情况，进行相应递归调用（如 ac，则递归时，两条子链都需要取最小值）</li>
<li>否则，则在 <code>&#123;ac, ad, bc, bd&#125;</code> 取最小的情况，进行相应递归调用</li>
</ul></li>
</ul>
<h1 id="复杂度分析">复杂度分析</h1>
<ul>
<li><p>寻找最优合并顺序</p>
<p>递归深度最好的情况是 <span class="math inline">\(logn\)</span>，也就说每次都恰好是对半进行合并；最坏情况是 n-1，每次都合并单个顶点;</p>
<p>一次递归的过程中，计算时间为常数级别C，所以整个时间复杂度为递归调用次数，即 <span class="math inline">\(O(C(n-1)) = O(n)\)</span></p></li>
<li><p>总的时间复杂度</p>
<p>动规过程需要 <span class="math inline">\(O(n^3)\)</span> 计算时间，加寻找最优合并顺序的时间 <span class="math inline">\(O(n)\)</span>，总的时间复杂度为 <span class="math inline">\(O(n^3)\)</span></p></li>
</ul>
<h1 id="测试">测试</h1>
<p>这里说明一下 output，前面的 <code>i=x xxx</code> 表示一开始删除那条边所能得到的最高分，接着 <code>firstDelEdge=x</code> 表示一开始删除这条边最终能得到最高分，后面的 <code>stack--&gt; x</code> 是紧接着要按顺序删除的边，最后是该删除方案的得分。</p>
<p>以 Case 1 为例，从左往右对边进行编号，第一条边为 <code>*</code>，连接第一个数字 <code>-5</code> 和最后一个数字 <code>8</code>；类似地，第二条边为 <code>+</code>，连接第一个数字 <code>-5</code> 和第二个数字 <code>-2</code>，其它同理。</p>
<ul>
<li><p>Case 1</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">* -5 + -2 * -8 * -5 + 8</span><br></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-5|--+--|-2|--*--|-8|--*--|-5|--+--|8|</span><br><span class="line"> |_________________*_________________|</span><br><span class="line">i=1 168</span><br><span class="line">i=2 480</span><br><span class="line">i=3 488</span><br><span class="line">i=4 488</span><br><span class="line">i=5 120</span><br><span class="line">firstDelEdge=3</span><br><span class="line">stack--&gt; 2</span><br><span class="line">stack--&gt; 1</span><br><span class="line">stack--&gt; 5</span><br><span class="line">stack--&gt; 4</span><br><span class="line">BestScore=488</span><br></pre></td></tr></table></figure></li>
<li><p>Case 2</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">* -6 + -7 * 0 * 4 + -2</span><br></pre></td></tr></table></figure>
<p>Ouput</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-6|--+--|-7|--*--|0|--*--|4|--+--|-2|</span><br><span class="line"> |________________*_________________|</span><br><span class="line">i=1 26</span><br><span class="line">i=2 12</span><br><span class="line">i=3 26</span><br><span class="line">i=4 16</span><br><span class="line">i=5 48</span><br><span class="line">firstDelEdge=5</span><br><span class="line">stack--&gt; 3</span><br><span class="line">stack--&gt; 2</span><br><span class="line">stack--&gt; 4</span><br><span class="line">stack--&gt; 1</span><br><span class="line">BestScore=48</span><br></pre></td></tr></table></figure></li>
<li><p>Case 3</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">+ 5 * 3 + -2 + 1 * -10 * -2</span><br></pre></td></tr></table></figure>
<p>Ouput</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|5|--*--|3|--+--|-2|--+--|1|--*--|-10|--*--|-2|</span><br><span class="line"> |_____________________+_____________________|</span><br><span class="line">i=1 280</span><br><span class="line">i=2 50</span><br><span class="line">i=3 130</span><br><span class="line">i=4 73</span><br><span class="line">i=5 74</span><br><span class="line">i=6 63</span><br><span class="line">firstDelEdge=1</span><br><span class="line">stack--&gt; 6</span><br><span class="line">stack--&gt; 4</span><br><span class="line">stack--&gt; 2</span><br><span class="line">stack--&gt; 3</span><br><span class="line">stack--&gt; 5</span><br><span class="line">BestScore=280</span><br></pre></td></tr></table></figure></li>
<li><p>Case 4</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">+ -2 + 9 * -5 + -4 * -5 * 0 + 7 * -5</span><br></pre></td></tr></table></figure>
<p>Ouput</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-2|--+--|9|--*--|-5|--+--|-4|--*--|-5|--*--|0|--+--|7|--*--|-5|</span><br><span class="line"> |_____________________________+______________________________|</span><br><span class="line">i=1 2905</span><br><span class="line">i=2 3969</span><br><span class="line">i=3 630</span><br><span class="line">i=4 5080</span><br><span class="line">i=5 3080</span><br><span class="line">i=6 3080</span><br><span class="line">i=7 200</span><br><span class="line">i=8 3080</span><br><span class="line">firstDelEdge=4</span><br><span class="line">stack--&gt; 1</span><br><span class="line">stack--&gt; 8</span><br><span class="line">stack--&gt; 7</span><br><span class="line">stack--&gt; 6</span><br><span class="line">stack--&gt; 2</span><br><span class="line">stack--&gt; 3</span><br><span class="line">stack--&gt; 5</span><br><span class="line">BestScore=5080</span><br></pre></td></tr></table></figure></li>
<li><p>Case 5</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">* 0 * -10 + 8 * -4 + 3 * -7 + 7 * -3 * -4</span><br></pre></td></tr></table></figure>
<p>Ouput</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|0|--*--|-10|--+--|8|--*--|-4|--+--|3|--*--|-7|--+--|7|--*--|-3|--*--|-4|</span><br><span class="line"> |__________________________________*__________________________________|</span><br><span class="line">i=1 2816</span><br><span class="line">i=2 273</span><br><span class="line">i=3 2000</span><br><span class="line">i=4 2816</span><br><span class="line">i=5 5376</span><br><span class="line">i=6 899</span><br><span class="line">i=7 19257</span><br><span class="line">i=8 2758</span><br><span class="line">i=9 2816</span><br><span class="line">firstDelEdge=7</span><br><span class="line">stack--&gt; 4</span><br><span class="line">stack--&gt; 2</span><br><span class="line">stack--&gt; 3</span><br><span class="line">stack--&gt; 1</span><br><span class="line">stack--&gt; 5</span><br><span class="line">stack--&gt; 6</span><br><span class="line">stack--&gt; 9</span><br><span class="line">stack--&gt; 8</span><br><span class="line">BestScore=19257</span><br></pre></td></tr></table></figure></li>
<li><p>Case 6</p>
<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">+ -7 + 4 * 2 * 5</span><br></pre></td></tr></table></figure>
<p>Ouput</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-7|--+--|4|--*--|2|--*--|5|</span><br><span class="line"> |___________+____________|</span><br><span class="line">i=1 33</span><br><span class="line">i=2 33</span><br><span class="line">i=3 7</span><br><span class="line">i=4 6</span><br><span class="line">firstDelEdge=1</span><br><span class="line">stack--&gt; 4</span><br><span class="line">stack--&gt; 3</span><br><span class="line">stack--&gt; 2</span><br><span class="line">BestScore=33</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="项目演示和源码">项目演示和源码</h1>
<p><a href="http://39.108.70.146:8080/PolygonGame/index.html">Demo</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ecaa9576c0440d1196863688a3168c0e.png" alt="demo" /></p>
<p><a href="https://github.com/wylu/PolygonGame">源码</a></p>
<h1 id="references">References</h1>
<p>王晓东《算法设计与分析》第三版</p>
<p><a href="https://www.cnblogs.com/Jason-Damon/p/3320565.html">https://www.cnblogs.com/Jason-Damon/p/3320565.html</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
  </entry>
  <entry>
    <title>CUDA积分法求PI</title>
    <url>/posts/f4a6508a/</url>
    <content><![CDATA[<p>本文将设计并实现一个并行计算程序，该程序利用积分法计算 PI 的值。</p>
<span id="more"></span>
<h1 id="cuda-入门书籍推荐">CUDA 入门书籍推荐</h1>
<p><a href="http://vdisk.weibo.com/s/uGXsmIpCn_4ug?category_id=0">《GPU高性能编程CUDA实战》</a></p>
<h1 id="基本思路">基本思路</h1>
<p><span class="math display">\[
\pi = 4\int_{0}^{1}\frac{1}{1+x^{2}}dx
\]</span></p>
<h1 id="cuda-程序执行的主要步骤">CUDA 程序执行的主要步骤</h1>
<ol type="1">
<li><p>CPU在GPU上申请空间</p>
<p><code>cudaMalloc(起始地址,大小)</code></p></li>
<li><p>CPU将数据从内存拷贝到显存</p>
<p><code>cudaMemcpy(源,目标,大小,方向)</code></p></li>
<li><p>CPU启动GPU上的内核进行计算</p>
<p><code>kernel_name &lt;&lt;&lt;blocks，threads&gt;&gt;&gt;(函数参数)</code></p></li>
<li><p>CPU将处理结果从显存拷贝到内存</p>
<p><code>cudaMemcpy(源,目标,大小,方向)</code></p></li>
</ol>
<h1 id="源码分析">源码分析</h1>
<p>PI.cu 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleError</span><span class="params">(cudaError_t err,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *file,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> line)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s in %s at line %d\n&quot;</span>, cudaGetErrorString(err),</span><br><span class="line">               file, line);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_ERROR(err) (HandleError(err, __FILE__, __LINE__))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_NULL(a) &#123;<span class="keyword">if</span> (a == NULL) &#123; \</span></span><br><span class="line"><span class="meta">                        printf(<span class="string">&quot;Host memory failed in %s at line %d\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                               __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">                        exit(EXIT_FAILURE);&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">64</span>;     <span class="comment">//积分时划分的份数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> threadsPerBlock = <span class="number">256</span>;    <span class="comment">//block中的线程数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> blocksPerGrid = <span class="number">64</span>;       <span class="comment">//grid中的block数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺省__host__，表明CPU运行，CPU调用</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">function_for_cpu</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> / (<span class="number">1</span> + x * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//__device__修饰，只能被内核函数调用，表明GPU运行，GPU调用</span></span><br><span class="line">__device__ <span class="type">double</span> <span class="title function_">function_for_gpu</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> / (<span class="number">1</span> + x * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __global__修饰，内核函数，表明GPU运行，CPU调用</span></span><br><span class="line"><span class="comment"> * 在GPU上使用积分法并行计算PI</span></span><br><span class="line"><span class="comment"> * @param a 积分下界</span></span><br><span class="line"><span class="comment"> * @param b 积分上界</span></span><br><span class="line"><span class="comment"> * @param integral 存储积分结果</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *integral)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * __shared__修饰，声明一个共享内存缓冲区，名字为cache</span></span><br><span class="line"><span class="comment">     * 表示数据存放在共享存储器中，每个线程块都有该变量的一个副本；</span></span><br><span class="line"><span class="comment">     * 只有在块内的线程可以访问，其它块内的线程不能访问；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __shared__ <span class="type">double</span> cache[threadsPerBlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该步的目的是计算初始线程索引，其中threadIdx, blockIdx, blockDim都是内置变量</span></span><br><span class="line"><span class="comment">     * threadIdx是存储线程信息的结构体，对于线程0来说，threadIdx.x=0;</span></span><br><span class="line"><span class="comment">     * blockDim.x表示block在x维度的线程数量，本例中使用的是一维线程块，</span></span><br><span class="line"><span class="comment">     *     因此只需用到blockDim.x</span></span><br><span class="line"><span class="comment">     * blockIdx.x表示block的索引，对于第一个线程块来说，blockIdx.x=0;</span></span><br><span class="line"><span class="comment">     *     对于第二个线程块来说，blockIdx.x=1...</span></span><br><span class="line"><span class="comment">     * 在计算tid线程索引时，需要要在threadIdx.x 的基础上加上一个基地址，</span></span><br><span class="line"><span class="comment">     *     实际上就是将二维索引空间转换为线性空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享内存缓存中的偏移就等于线程索引，线程块索引与该偏移无关，</span></span><br><span class="line"><span class="comment">     * 因为每个线程块都拥有该共享内存的私有副本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> cacheIndex = threadIdx.x;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tid &lt; N) &#123;</span><br><span class="line">        x = *a + (<span class="type">double</span>)(*b - *a) / N * (tid + <span class="number">0.5</span>);</span><br><span class="line">        temp += function_for_gpu(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在每个线程计算完当前索引上的任务后，需要对索引进行递增，</span></span><br><span class="line"><span class="comment">         * 其中，递增的步长为线程格中正在运行的线程数量，</span></span><br><span class="line"><span class="comment">         * 这个数值等于线程块中的线程数量乘以线程格中线程块的数量，</span></span><br><span class="line"><span class="comment">         * 即 blockDim.x * gridDim.x</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 该方法类似于多CPU或多核CPU的并行，数据迭代的增量不是1，</span></span><br><span class="line"><span class="comment">         *     而是CPU的数量；在GPU实现中，一般将并行线程数量看做处理器的数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tid += blockDim.x * gridDim.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置cache中相应位置上的值</span></span><br><span class="line">    cache[cacheIndex] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对线程块中的线程进行同步，该操作用于确保</span></span><br><span class="line"><span class="comment">     *     所有对共享数组cache[]写入操作在读取cache之前完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于归约运算来说，以下代码要求threadsPerBlock必须是2的幂，</span></span><br><span class="line"><span class="comment">     * 因为每次合并，要求分成的两部分数组的长度要一致</span></span><br><span class="line"><span class="comment">     * 基本思想：</span></span><br><span class="line"><span class="comment">     *     每个线程将cache[]中的两个值相加起来，然后将结果保存回cache[]</span></span><br><span class="line"><span class="comment">     *     由于每个线程都将两个值合并为一个值，那么在完成这个步骤后，</span></span><br><span class="line"><span class="comment">     *     得到的结果数量就是计算开始时数值数量的一半。接着，对这一半</span></span><br><span class="line"><span class="comment">     *     进行相同操作，直到cache[]中256个值归约为1个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> i = blockDim.x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; i)</span><br><span class="line">            cache[cacheIndex] += cache[cacheIndex + i];</span><br><span class="line">        __syncthreads();</span><br><span class="line">        i /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将这个值保存到全局内存后，内核函数结束</span></span><br><span class="line">    <span class="comment">//这里使用了索引为0的线程将cache[0]写入全局内存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheIndex == <span class="number">0</span>)</span><br><span class="line">        integral[blockIdx.x] = cache[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在CPU上使用积分法串行计算PI</span></span><br><span class="line"><span class="comment"> * @param a 积分下界</span></span><br><span class="line"><span class="comment"> * @param b 积分上界</span></span><br><span class="line"><span class="comment"> * @param integral 存储积分结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_by_cpu</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> *integral)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> x, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        x = a + (<span class="type">double</span>)(b - a) / N * (i + <span class="number">0.5</span>);</span><br><span class="line">        temp += function_for_cpu(x);</span><br><span class="line">    &#125;</span><br><span class="line">    temp *= (<span class="type">double</span>)(b - a) / N;</span><br><span class="line">    *integral = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">double</span> integral;</span><br><span class="line">    <span class="type">double</span> *partial_integral;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *dev_partial_integral;</span><br><span class="line">    <span class="type">double</span> *dev_a, *dev_b;</span><br><span class="line">    cudaEvent_t start,stop;</span><br><span class="line">    <span class="type">float</span> tm;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> clockBegin, clockEnd;</span><br><span class="line">    <span class="type">float</span> duration;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用CPU计算PI的值</span></span><br><span class="line">    clockBegin = clock();</span><br><span class="line">    trap_by_cpu(a, b, &amp;integral);</span><br><span class="line">    clockEnd = clock();</span><br><span class="line">    duration = (<span class="type">float</span>)<span class="number">1000</span> * (clockEnd - clockBegin) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU Result: %.20lf\n&quot;</span>, integral);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU Elapsed time: %.6lfms\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GPU+CPU计算PI的值</span></span><br><span class="line">    <span class="comment">//使用event计算时间</span></span><br><span class="line">    cudaEventCreate(&amp;start); <span class="comment">//创建event</span></span><br><span class="line">    cudaEventCreate(&amp;stop);  <span class="comment">//创建event</span></span><br><span class="line">    cudaEventRecord(start, <span class="number">0</span>);  <span class="comment">//记录当前时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请CPU存储空间</span></span><br><span class="line">    partial_integral = (<span class="type">double</span>*)<span class="built_in">malloc</span>(blocksPerGrid * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请GPU存储空间</span></span><br><span class="line">    HANDLE_ERROR(cudaMalloc((<span class="type">void</span>**)&amp;dev_a, <span class="keyword">sizeof</span>(<span class="type">double</span>)));</span><br><span class="line">    HANDLE_ERROR(cudaMalloc((<span class="type">void</span>**)&amp;dev_b, <span class="keyword">sizeof</span>(<span class="type">double</span>)));</span><br><span class="line">    HANDLE_ERROR(cudaMalloc((<span class="type">void</span>**)&amp;dev_partial_integral,</span><br><span class="line">                            blocksPerGrid * <span class="keyword">sizeof</span>(<span class="type">double</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将&#x27;a&#x27;和&#x27;b&#x27;复制到GPU</span></span><br><span class="line">    HANDLE_ERROR(cudaMemcpy(dev_a, &amp;a, <span class="keyword">sizeof</span>(<span class="type">double</span>), cudaMemcpyHostToDevice));</span><br><span class="line">    HANDLE_ERROR(cudaMemcpy(dev_b, &amp;b, <span class="keyword">sizeof</span>(<span class="type">double</span>), cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动内核函数，启动的线程块的数量是64个，每个线程块的线程数量是256</span></span><br><span class="line">    trap&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(dev_a, dev_b, dev_partial_integral);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将计算结果数组&#x27;dev_partial_integral&#x27;从GPU复制到CPU</span></span><br><span class="line">    HANDLE_ERROR(cudaMemcpy(partial_integral, dev_partial_integral,</span><br><span class="line">                            blocksPerGrid * <span class="keyword">sizeof</span>(<span class="type">double</span>),</span><br><span class="line">                            cudaMemcpyDeviceToHost));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在CPU上进行归约操作，得到最终的计算结果</span></span><br><span class="line">    integral = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; blocksPerGrid; i++) &#123;</span><br><span class="line">        integral += partial_integral[i];</span><br><span class="line">    &#125;</span><br><span class="line">    integral *= (<span class="type">double</span>)(b - a) / N;</span><br><span class="line"></span><br><span class="line">    cudaEventRecord(stop,<span class="number">0</span>);  <span class="comment">//记录当前时间</span></span><br><span class="line">    cudaEventSynchronize(stop);  <span class="comment">//等待stop event完成</span></span><br><span class="line">    cudaEventElapsedTime(&amp;tm, start, stop);  <span class="comment">//计算时间差（毫秒级）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPU Result: %.20lf\n&quot;</span>, integral);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPU Elapsed time:%.6f ms.\n&quot;</span>, tm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放GPU内存</span></span><br><span class="line">    HANDLE_ERROR(cudaFree(dev_a));</span><br><span class="line">    HANDLE_ERROR(cudaFree(dev_b));</span><br><span class="line">    HANDLE_ERROR(cudaFree( dev_partial_integral));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放CPU内存</span></span><br><span class="line">    <span class="built_in">free</span>(partial_integral);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p>《GPU高性能编程CUDA实战》</p>
]]></content>
      <categories>
        <category>cs</category>
        <category>parallel-programming</category>
      </categories>
      <tags>
        <tag>parallel-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>2048AI设计与实现</title>
    <url>/posts/e45df9a/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bbd03b9c7fb0365f0b41a65dcd9f02e2.png" alt="2048" /></p>
<p>针对 2048 游戏，实现一个 AI 程序，当用户选择提示功能时，系统根据当前局势找出适当的决策帮助用户赢得游戏。系统界面实现由 Android 完成，主体 AI 使用了传统的博弈树模型中常用的算法，即 Minimax 和 Alpha-beta 剪枝，重点落在启发函数的设计上。项目的启发函数从四个方面评估当前的局势，结合迭代深搜，在限定搜索时间内做出决策，赢得游戏的概率高于 90%。</p>
<span id="more"></span>
<h1 id="项目简介">项目简介</h1>
<h2 id="游戏简介">2048 游戏简介</h2>
<p><a href="https://github.com/gabrielecirulli/2048">2048</a> 是一款比较流行的数字游戏，最早于 2014 年 3 月 20 日发行。原版 2048 首先在 GitHub 上发布，原作者是 Gabriele Cirulli，后被移植到各个平台。</p>
<p>游戏规则：</p>
<p>每次可以选择上下左右其中一个方向去滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢外，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出 2048 这个数字就算成功。</p>
<h2 id="智能提示实现">2048 智能提示实现</h2>
<p>系统 AI 提供提示功能，从当前格局出发，寻找所能达到搜索层次的最优的解</p>
<p>点击 <code>Hint</code> 按钮，显示滑动提示</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0fbbdfaea8560362897f5dce77a30d1c.png" alt="hint-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0b92220491512ce3db7a33a8a484cc11.png" alt="hint-2" /></p>
<h1 id="建模">建模</h1>
<blockquote>
<p>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely <a href="http://www.flyingmachinestudios.com/programming/minimax/">minimax</a> <a href="http://xkcd.com/832/">search</a> with <a href="http://cs.ucla.edu/~rosen/161/notes/alphabeta.html">alpha-beta pruning</a>. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the <a href="http://en.wikipedia.org/wiki/Evaluation_function">static evaluation function</a> and which formalize many of the intuitions that other people have expressed here.</p>
</blockquote>
<p>2048 本质上可以抽象成信息对称双人对弈模型（玩家向四个方向中的一个移动，然后计算机在某个空格中填入 2 或 4 ）。这里“信息对称”是指在任一时刻对弈双方对格局的信息完全一致，移动策略仅依赖对接下来格局的推理。作者使用的核心算法为对弈模型中常用的带 Alpha-beta 剪枝的 Minimax。这个算法也常被用于如国际象棋等信息对称对弈 AI 中。</p>
<h1 id="算法分析">算法分析</h1>
<p><a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html">http://blog.codinglabs.org/articles/2048-ai-analysis.html</a></p>
<h1 id="算法实现">算法实现</h1>
<h2 id="格局评估指标">格局评估指标</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格局评估函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前格局的评估值，用于比较判断格局的好坏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">smoothWeight</span> <span class="operator">=</span> <span class="number">0.1</span>, <span class="comment">//平滑性权重系数</span></span><br><span class="line">            monoWeight = <span class="number">1.3</span>, <span class="comment">//单调性权重系数</span></span><br><span class="line">            emptyWeight = <span class="number">2.7</span>, <span class="comment">//空格数权重系数</span></span><br><span class="line">            maxWeight = <span class="number">1.0</span>; <span class="comment">//最大数权重系数</span></span><br><span class="line">    <span class="keyword">return</span> grid.smoothness() * smoothWeight</span><br><span class="line">            + grid.monotonicity() * monoWeight</span><br><span class="line">            + Math.log(getEmptyNum(grid.getCellMatrix())) * emptyWeight</span><br><span class="line">            + grid.maxValue() * maxWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用线性函数，并添加权重系数，前 3 项指标能衡量一个局面的好坏，而最大数该项，则让游戏 AI 多了一点积极和"冒险"。</p>
<h2 id="minimax-search-和-alpha-beta-pruning-的实现">Minimax Search 和 Alpha Beta Pruning 的实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SearchResult <span class="title function_">search</span><span class="params">(<span class="type">int</span> depth, <span class="type">double</span> alpha, <span class="type">double</span> beta, <span class="type">int</span> positions, <span class="type">int</span> cutoffs)</span> &#123;</span><br><span class="line">    <span class="type">double</span> bestScore;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bestMove</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">SearchResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchResult</span>();</span><br><span class="line">    <span class="type">int</span>[] directions = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.grid.playerTurn) &#123;  <span class="comment">// Max 层</span></span><br><span class="line">        bestScore = alpha;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> direction : directions) &#123;  <span class="comment">// 玩家遍历四个滑动方向，找出一个最好的</span></span><br><span class="line">            <span class="type">GameState</span> <span class="variable">newGrid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameState</span>(<span class="built_in">this</span>.grid.getCellMatrix());</span><br><span class="line">            <span class="keyword">if</span> (newGrid.move(direction)) &#123;</span><br><span class="line">                positions++;</span><br><span class="line"><span class="comment">//                if (newGrid.isWin()) &#123;</span></span><br><span class="line"><span class="comment">//                    return new SearchResult(direction, 10000, positions, cutoffs);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="type">AI</span> <span class="variable">newAI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AI</span>(newGrid);</span><br><span class="line">                newAI.grid.playerTurn = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123; <span class="comment">//如果depth=0,搜索到该层后不再向下搜索</span></span><br><span class="line">                    result.move = direction;</span><br><span class="line">                    result.score = newAI.evaluate();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果depth&gt;0,则继续搜索下一层，下一层为电脑做出决策的层</span></span><br><span class="line">                    result = newAI.search(depth - <span class="number">1</span>, bestScore, beta, positions, cutoffs);</span><br><span class="line">                    <span class="keyword">if</span> (result.score &gt; <span class="number">9900</span>) &#123; <span class="comment">// 如果赢得游戏</span></span><br><span class="line">                        result.score--; <span class="comment">// 轻微地惩罚因为更大的搜索深度</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    positions = result.positions;</span><br><span class="line">                    cutoffs = result.cutoffs;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前搜索分支的格局分数要好于之前得到的分数，则更新决策，同时更新bestScore，也即alpha的值</span></span><br><span class="line">                <span class="keyword">if</span> (result.score &gt; bestScore) &#123;</span><br><span class="line">                    bestScore = result.score;</span><br><span class="line">                    bestMove = direction;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前bestScore也即alpha&gt;beta时，表明这个节点下不会再有更好解，于是剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (bestScore &gt; beta) &#123;</span><br><span class="line">                    cutoffs++;  <span class="comment">//剪枝</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchResult</span>(bestMove, beta, positions, cutoffs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Min 层，该层为电脑层(也即我们的对手)，这里我们假设对手(电脑)足够聪明，总是能做出使格局变到最坏的决策</span></span><br><span class="line">        bestScore = beta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试给每个空闲块填入2或4，然后计算格局的评估值</span></span><br><span class="line">        List&lt;Candidate&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; cells = <span class="built_in">this</span>.grid.getAvailableCells();</span><br><span class="line">        <span class="type">int</span>[] fill = &#123;<span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        List&lt;Double&gt; scores_2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Double&gt; scores_4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : fill) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cells.size(); i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.grid.insertTitle(cells.get(i)[<span class="number">0</span>], cells.get(i)[<span class="number">1</span>], value);</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">2</span>) scores_2.add(i, -<span class="built_in">this</span>.grid.smoothness() + <span class="built_in">this</span>.grid.islands());</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">4</span>) scores_4.add(i, -<span class="built_in">this</span>.grid.smoothness() + <span class="built_in">this</span>.grid.islands());</span><br><span class="line">                <span class="built_in">this</span>.grid.removeTile(cells.get(i)[<span class="number">0</span>], cells.get(i)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出使格局变得最坏的所有可能操作</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxScore</span> <span class="operator">=</span> Math.max(Collections.max(scores_2), Collections.max(scores_4));</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> value : fill) &#123;</span><br><span class="line">             <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (Double fitness : scores_2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fitness == maxScore) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scores_2.indexOf(fitness);</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> <span class="title class_">Candidate</span>(cells.get(index)[<span class="number">0</span>], cells.get(index)[<span class="number">1</span>], value));</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Double fitness : scores_4) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fitness == maxScore) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scores_4.indexOf(fitness);</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> <span class="title class_">Candidate</span>(cells.get(index)[<span class="number">0</span>], cells.get(index)[<span class="number">1</span>], value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后遍历这些操作，基于这些操作向下搜索，找到使得格局最坏的分支</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos_x</span> <span class="operator">=</span> candidates.get(i).x;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos_y</span> <span class="operator">=</span> candidates.get(i).y;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> candidates.get(i).value;</span><br><span class="line">            <span class="type">GameState</span> <span class="variable">newGrid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameState</span>(<span class="built_in">this</span>.grid.getCellMatrix());</span><br><span class="line">            <span class="comment">// 电脑即对手做出一个可能的对于电脑来说最好的（对于玩家来说最坏的）决策</span></span><br><span class="line">            newGrid.insertTitle(pos_x, pos_y, value);</span><br><span class="line">            positions++;</span><br><span class="line">            <span class="type">AI</span> <span class="variable">newAI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AI</span>(newGrid);</span><br><span class="line">            <span class="comment">// 向下搜索，下一层为Max层，轮到玩家进行决策</span></span><br><span class="line">            newAI.grid.playerTurn = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 这里depth没有减1是为了保证搜索到最深的层为Max层</span></span><br><span class="line">            result = newAI.search(depth, alpha, bestScore, positions, cutoffs);</span><br><span class="line">            positions = result.positions;</span><br><span class="line">            cutoffs = result.cutoffs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该层为Min层，哪个分支的局势最不好，就选哪个分支，这里的bestScore代表beta</span></span><br><span class="line">            <span class="keyword">if</span> (result.score &lt; bestScore) &#123;</span><br><span class="line">                bestScore = result.score;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前bestScore也即beta&lt;alpha时，表明这个节点下不会再有更好解，于是剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (bestScore &lt; alpha) &#123;</span><br><span class="line">                cutoffs++;  <span class="comment">//减枝</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchResult</span>(-<span class="number">1</span>, alpha, positions, cutoffs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchResult</span>(bestMove, bestScore, positions, cutoffs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="己方格局评价函数实现">己方格局评价函数实现</h2>
<h3 id="平滑性">平滑性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测量网格的平滑程度(这些块的值可以形象地解释为海拔)。</span></span><br><span class="line"><span class="comment"> * 相邻两个方块的值差异越小，格局就越平滑(在log空间中，所以它表示在合并之前需要进行的合并的数量)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">smoothness</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">smoothness</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cellMatrix[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> Math.log(<span class="built_in">this</span>.cellMatrix[x][y]) / Math.log(<span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 计算水平方向和垂直方向的平滑性评估值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">1</span>; direction &lt;= <span class="number">2</span>; direction++) &#123;</span><br><span class="line">                    <span class="type">int</span>[] vector = <span class="built_in">this</span>.vectors[direction];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cnt_x</span> <span class="operator">=</span> x, cnt_y = y;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        cnt_x += vector[<span class="number">0</span>];</span><br><span class="line">                        cnt_y += vector[<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">while</span> (isInBounds(cnt_x, cnt_y) &amp;&amp; isCellAvailable(cnt_x, cnt_y));</span><br><span class="line">                    <span class="keyword">if</span> (isInBounds(cnt_x, cnt_y)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cellMatrix[cnt_x][cnt_y] != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">double</span> <span class="variable">targetValue</span> <span class="operator">=</span> Math.log(cellMatrix[cnt_x][cnt_y]) / Math.log(<span class="number">2</span>);</span><br><span class="line">                            smoothness -= Math.abs(value - targetValue);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调性">单调性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测量网格的单调性。</span></span><br><span class="line"><span class="comment"> * 这意味着在向左/向右和向上/向下的方向，方块的值都是严格递增或递减的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">monotonicity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 保存四个方向格局单调性的评估值</span></span><br><span class="line">    <span class="type">int</span>[] totals = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左/右 方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.cellMatrix[x][next] == <span class="number">0</span>) next++;</span><br><span class="line">            <span class="keyword">if</span> (next &gt;= <span class="number">4</span>) next--;</span><br><span class="line">            <span class="type">double</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="built_in">this</span>.cellMatrix[x][current] != <span class="number">0</span>) ? Math.log(<span class="built_in">this</span>.cellMatrix[x][current]) / Math.log(<span class="number">2</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">nextValue</span> <span class="operator">=</span> (<span class="built_in">this</span>.cellMatrix[x][next] != <span class="number">0</span>) ? Math.log(<span class="built_in">this</span>.cellMatrix[x][next]) / Math.log(<span class="number">2</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentValue &gt; nextValue) &#123;</span><br><span class="line">                totals[<span class="number">0</span>] += nextValue - currentValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextValue &gt; currentValue) &#123;</span><br><span class="line">                totals[<span class="number">1</span>] += currentValue - nextValue;</span><br><span class="line">            &#125;</span><br><span class="line">            current = next;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上/下 方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.cellMatrix[next][y] == <span class="number">0</span>) next++;</span><br><span class="line">            <span class="keyword">if</span> (next &gt;= <span class="number">4</span>) next--;</span><br><span class="line">            <span class="type">double</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="built_in">this</span>.cellMatrix[current][y] != <span class="number">0</span>) ? Math.log(<span class="built_in">this</span>.cellMatrix[current][y]) / Math.log(<span class="number">2</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">nextValue</span> <span class="operator">=</span> (<span class="built_in">this</span>.cellMatrix[next][y] != <span class="number">0</span>) ? Math.log(<span class="built_in">this</span>.cellMatrix[next][y]) / Math.log(<span class="number">2</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentValue &gt; nextValue) &#123;</span><br><span class="line">                totals[<span class="number">2</span>] += nextValue - currentValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextValue &gt; currentValue) &#123;</span><br><span class="line">                totals[<span class="number">3</span>] += currentValue - nextValue;</span><br><span class="line">            &#125;</span><br><span class="line">            current = next;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取四个方向中最大的值为当前格局单调性的评估值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(totals[<span class="number">0</span>], totals[<span class="number">1</span>]) + Math.max(totals[<span class="number">2</span>], totals[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空格数">空格数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEmptyNum</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大数">最大数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取最大数，这里取对数是为与前面其它指标的计算保持一致，均在log空间进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.log(ArrayUtil.getMax(cellMatrix)) / Math.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对方格局评价函数实现">对方格局评价函数实现</h2>
<p>对方对于格局的目标就是使得连通个数变多并且使得平滑性降低，表现效果就是使得格局趋于散乱，让玩家难以合并相同的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归调用计算当前格局的连通块个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islands</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cellMatrix[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.marked[x][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cellMatrix[x][y] != <span class="number">0</span> &amp;&amp; !<span class="built_in">this</span>.marked[x][y]) &#123;</span><br><span class="line">                islands++;</span><br><span class="line">                mark(x, y, <span class="built_in">this</span>.cellMatrix[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> islands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">3</span> &amp;&amp; (<span class="built_in">this</span>.cellMatrix[x][y] != <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; (<span class="built_in">this</span>.cellMatrix[x][y] == value) &amp;&amp; (!<span class="built_in">this</span>.marked[x][y])) &#123;</span><br><span class="line">        <span class="built_in">this</span>.marked[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">0</span>; direction &lt; <span class="number">4</span>; direction++) &#123;</span><br><span class="line">            <span class="type">int</span>[] vector = <span class="built_in">this</span>.vectors[direction];</span><br><span class="line">            mark(x + vector[<span class="number">0</span>], y + vector[<span class="number">1</span>], value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代深搜">迭代深搜</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行搜索操作，返回最好的移动方向</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBestMove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.iterativeDeep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于alpha-beta的Minimax搜索，进行迭代深搜，搜索时间设定为0.1秒，即决策的思考时间为0.1秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">iterativeDeep</span><span class="params">(<span class="type">long</span> minSearchTime)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">SearchResult</span> <span class="variable">newBest</span> <span class="operator">=</span> <span class="built_in">this</span>.search(depth, -<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (newBest.move == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> best = newBest.move;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().getTime() - start &lt; minSearchTime);</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运行效果">运行效果</h1>
<p>自动运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/83b90ac77610eba4b89b82359860d24e.png" alt="run-case-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/81f7851c4ba9813e03eaeb8188bd6d15.png" alt="run-case-2" /></p>
<h1 id="结论">结论</h1>
<p>游戏 AI 的决策过程，是标准的 Minimax Search 结合 Alpha Beta Pruning 的实现。 所有的方向(上下左右)都会去尝试。然而在对手做决策时，不是每个空格都去尝试填 2 或 4 。而是选择了最坏的局面，做为搜索分支的剪枝条件，选择性地丢弃了很多搜索分支。对于选择性忽略搜索节点，在某些情况下，会失去获取最优解的机会。不过砍掉了很多分支后, 其搜索深度大大加强，生存能力更强大。另外，超时判断在每个深度探索结束后进行，这未必会精确，甚至误差很大，但不管如何游戏 AI 基本达到了每 100ms 决策一步的要求。最后，根据原作者 ovolve 创造性的思维和建模，把环境拟人化的对弈模型，使得传统的博弈树模型能应用于此，这是面对反馈类场景的一种很好的评估决策思路。</p>
<h1 id="源码和-apk">源码和 apk</h1>
<p><a href="https://github.com/wylu/md2048">https://github.com/wylu/md2048</a></p>
<h1 id="references">References</h1>
<p><a href="https://stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048">https://stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048</a></p>
<p><a href="http://ov3y.github.io/2048-AI/">http://ov3y.github.io/2048-AI/</a></p>
<p><a href="https://github.com/ov3y/2048-AI">https://github.com/ov3y/2048-AI</a></p>
<p><a href="https://en.wikipedia.org/wiki/Evaluation_function">https://en.wikipedia.org/wiki/Evaluation_function</a></p>
<p>《Artificial Intelligence : A Modern Approach》 (Third Edition) 第5章 对抗搜索</p>
<p><a href="http://www.flyingmachinestudios.com/programming/minimax/">http://www.flyingmachinestudios.com/programming/minimax/</a></p>
<p><a href="https://www.neverstopbuilding.com/blog/2013/12/13/tic-tac-toe-understanding-the-minimax-algorithm13/">https://www.neverstopbuilding.com/blog/2013/12/13/tic-tac-toe-understanding-the-minimax-algorithm13/</a></p>
<p><a href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html">http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html</a></p>
<p><a href="https://www.cnblogs.com/mumuxinfei/p/4415352.html">https://www.cnblogs.com/mumuxinfei/p/4415352.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html">http://blog.codinglabs.org/articles/2048-ai-analysis.html</a></p>
<p><a href="http://www.cnblogs.com/mumuxinfei/p/4305981.html">http://www.cnblogs.com/mumuxinfei/p/4305981.html</a></p>
<p><a href="http://www.cnblogs.com/mumuxinfei/p/4379595.html">http://www.cnblogs.com/mumuxinfei/p/4379595.html</a></p>
<p><a href="http://www.cnblogs.com/mumuxinfei/p/4396339.html">http://www.cnblogs.com/mumuxinfei/p/4396339.html</a></p>
<p><a href="http://www.cnblogs.com/mumuxinfei/p/4398680.html">http://www.cnblogs.com/mumuxinfei/p/4398680.html</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer总结</title>
    <url>/posts/338d1bcc/</url>
    <content><![CDATA[<p>剑指Offer系列刷题笔记总结</p>
<span id="more"></span>
<h1 id="数据结构">数据结构</h1>
<h2 id="数组">数组</h2>
<h3 id="数组中重复的数字">数组中重复的数字</h3>
<p><strong>思路：</strong></p>
<p>利用一个辅助数组来表示数字是否已出现过了，如果已出现过则返回当前数字。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuplicateNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">duplicate</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] duplication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[e])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = e;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[e] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;, duplication = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(duplicate(arr, duplication));</span><br><span class="line">        System.out.println(duplication[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">二维数组中的查找</h3>
<p><strong>思路：</strong></p>
<ul>
<li>首先选取数组中右上角的数字。</li>
<li>如果该数字等于要查找的数字，则查找过程结束；</li>
<li>如果该数字大于要查找的数字，则剔除这个数字所在的列；</li>
<li>如果该数字小于要查找的数字，则剔除这个数字所在的行；</li>
<li>直到找到要查找的数字，或者查找范围为空。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows+cols)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDArrayFind</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3 id="替换空格">替换空格</h3>
<p><strong>思路：</strong></p>
<p>先遍历一次字符串，统计出字符串中空格的总数，并由此计算出替换后的字符串的总长度；每替换一个空格，长度就增长 2。</p>
<ul>
<li>准备两个指针：<span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 指向原始字符串的末尾，而 <span class="math inline">\(P_2\)</span> 指向替换之后的字符串的末尾；</li>
<li>接着向前移动指针 <span class="math inline">\(P_1\)</span>，逐个把它指向的字符复制到 <span class="math inline">\(P_2\)</span> 指向的位置，直到碰到空格为止；</li>
<li>碰到空格后，把 <span class="math inline">\(P_1\)</span> 向前移动1格，在 <span class="math inline">\(P_2\)</span> 之前插入字符串 "%20"，由于 "%20" 的长度为 3，同时也要把 <span class="math inline">\(P_2\)</span> 向前移动 3 格；</li>
<li>重复以上步骤，直至 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向同一位置。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> originLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> numOfSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            ++originLen;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) ++numOfSpace;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> indexOfOrigin = originLen;</span><br><span class="line">        <span class="type">int</span> indexOfNew = originLen + numOfSpace * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(indexOfOrigin &lt; indexOfNew)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOfOrigin] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexOfNew--] = str[indexOfOrigin];</span><br><span class="line">            &#125;</span><br><span class="line">            indexOfOrigin--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="把字符串转换成整数">把字符串转换成整数</h3>
<p><strong>思路：</strong></p>
<p>把第一个字符分两种情况对待，第一种为符号位即 '+' 或 '-'，第二种为 '0'-'9' 的数字字符。</p>
<p>从第一个数字字符开始到最后一个字符做如下运算：</p>
<ul>
<li>每次循环将上一次的结果 <code>*</code> 10</li>
<li>然后加上本次循环的字符数字</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<p>未做溢出判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrToInt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">signBit</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (signBit != <span class="string">&#x27;+&#x27;</span> &amp;&amp; signBit != <span class="string">&#x27;-&#x27;</span> &amp;&amp; (signBit &lt; <span class="string">&#x27;0&#x27;</span> || signBit &gt; <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (signBit &gt;= <span class="string">&#x27;0&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            res += (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signBit == <span class="string">&#x27;-&#x27;</span> ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;+2147483647&quot;</span>));</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;4562&quot;</span>));</span><br><span class="line">        System.out.println(strToInt(<span class="string">&quot;-87904562&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<h3 id="从尾到头打印链表">从尾到头打印链表</h3>
<p><strong>思路：</strong></p>
<p>直接从头到尾遍历链表，将遍历的结点都加入列表中，最后对列表进行逆序操作。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintListFromTailToHead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printListFromTailToHead</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) <span class="keyword">return</span> nodes;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">null</span>)&#123;</span><br><span class="line">            nodes.add(pHead.val);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(nodes); <span class="comment">//线性运行时间</span></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="重建二叉树">重建二叉树</h3>
<p><strong>思路：</strong></p>
<ul>
<li>根据前序遍历的第一个数字创建根结点；</li>
<li>接着在中序遍历序列中找到根结点的位置，确定左、右子树的结点数量；</li>
<li>在前序遍历和中序遍历序列中划分了左、右子树结点的值后，递归地调用函数去分别构建它的左、右子树。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReconstructBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructCore</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> startPre, <span class="type">int</span> endPre,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> pre[startPre];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (startPre == endPre) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIn</span> <span class="operator">=</span> startIn;</span><br><span class="line">        <span class="keyword">while</span> (rootIn &lt;= endIn &amp;&amp; in[rootIn] != rootValue) rootIn++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> rootIn - startIn;</span><br><span class="line">        <span class="keyword">if</span> (leftLen &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.left = constructCore(pre, in,</span><br><span class="line">                    startPre+<span class="number">1</span>, startPre+leftLen,</span><br><span class="line">                    startIn, rootIn-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftLen &lt; endPre - startPre)&#123;</span><br><span class="line">            root.right = constructCore(pre, in,</span><br><span class="line">                    startPre+leftLen+<span class="number">1</span>, endPre,</span><br><span class="line">                    rootIn+<span class="number">1</span>, endIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length == <span class="number">0</span> || pre.length != in.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> constructCore(pre, in,</span><br><span class="line">                <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点">二叉树的下一个结点</h3>
<p><strong>思路：</strong></p>
<ul>
<li>如果一个结点有右子树，那么它的下一个结点就是它右子树中的最左结点。</li>
<li>如果一个结点没有右子树，则分两种情况：
<ul>
<li>如果结点是它父结点的左子结点，那么它的下一个结点即为它的父结点。</li>
<li>如果结点是它父结点的右子结点，则可以沿着父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点，如果这样的结点存在，那么这个结点的父结点就是要找的下一个结点。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeLinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">getNext</span><span class="params">(TreeLinkNode pNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeLinkNode pNext;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">pRight</span> <span class="operator">=</span> pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pRight.left != <span class="literal">null</span>) pRight = pRight.left;</span><br><span class="line">            pNext = pRight;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">pCurrent</span> <span class="operator">=</span> pNode, pParent = pNode.next;</span><br><span class="line">            <span class="keyword">while</span> (pParent != <span class="literal">null</span> &amp;&amp; pCurrent == pParent.right)&#123;</span><br><span class="line">                pCurrent = pParent;</span><br><span class="line">                pParent = pCurrent.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNext = pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈和队列">栈和队列</h2>
<h3 id="用两个栈实现队列">用两个栈实现队列</h3>
<p><strong>思路：</strong></p>
<ul>
<li>入队时，直接将元素压入 stack1</li>
<li>出队时分两种情况：
<ul>
<li>若 stack2 不空，则弹出 stack2 栈顶；</li>
<li>若 stack2 为空，则将 stack1 中的元素逐个弹出并压入 stack2，然后再弹出 stack2 栈顶。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> 入队 <span class="math inline">\(O(1)\)</span>，出队 <span class="math inline">\(O(1) \sim O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoStacksToQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法和数据操作">算法和数据操作</h1>
<h2 id="递归和循环">递归和循环</h2>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p><strong>思路：</strong></p>
<p>从下往上计算，首先根据 <span class="math inline">\(f(0)\)</span> 和 <span class="math inline">\(f(1)\)</span> 算出 <span class="math inline">\(f(2)\)</span>，再根据 <span class="math inline">\(f(1)\)</span> 和 <span class="math inline">\(f(2)\)</span> 算出 <span class="math inline">\(f(3)\)</span> ... 以此类推就可以算出第 n 项了。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>, f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="青蛙跳台阶">青蛙跳台阶</h3>
<p><strong>思路：</strong></p>
<p>把 <span class="math inline">\(n\)</span> 级台阶时的跳法看成 <span class="math inline">\(n\)</span> 的函数，记为 <span class="math inline">\(f(n)\)</span>：</p>
<ul>
<li>显然有 <span class="math inline">\(f(1)=1，f(2)=2\)</span></li>
<li>当 <span class="math inline">\(n \gt 2\)</span> 时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrogJumpSteps</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变态跳台阶">变态跳台阶</h3>
<p><strong>思路：</strong></p>
<p><span class="math inline">\(f(n)=2^{n-1}\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrogJumpStepsII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵覆盖">矩阵覆盖</h3>
<p><strong>思路：</strong></p>
<p><span class="math inline">\(f(1)=1，f(2)=2\)</span></p>
<p>当 <span class="math inline">\(n &gt; 2\)</span> 时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectCover</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> f[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = f[<span class="number">1</span>] + f[<span class="number">2</span>];</span><br><span class="line">            f[<span class="number">1</span>] = f[<span class="number">2</span>];</span><br><span class="line">            f[<span class="number">2</span>] = f[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找和排序">查找和排序</h2>
<h3 id="旋转数组的最小数字">旋转数组的最小数字</h3>
<p><strong>思路：</strong></p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 总是指向前面递增的数组的元素，而 <span class="math inline">\(P_2\)</span> 总是指向后面递增数组的元素。</li>
<li>初始时，<span class="math inline">\(P_1\)</span> 指向数组的第一个元素，<span class="math inline">\(P_2\)</span> 指向数组的最后一个元素。</li>
<li>如果 <span class="math inline">\(arr[P_1] \le arr[P_2]\)</span>，则直接进行顺序查找；</li>
<li>如果 <span class="math inline">\(arr[P_1] \gt arr[P_2]\)</span>，则进行如下步骤：
<ul>
<li>找到 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 的中间元素，如果该中间元素位于前面的递增子数组，则把 <span class="math inline">\(P_1\)</span> 指向该中间元素；</li>
<li>如果该中间元素位于后面的递增子数组，则把 <span class="math inline">\(P_2\)</span> 指向该中间元素；</li>
<li>重复以上步骤，直至两个指针相邻时，<span class="math inline">\(P_2\)</span> 指向的元素即为最小的元素。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinNumberInRotateArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2 || arr[p1] &lt; arr[p2]) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] == arr[p2])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[p1]) p1 = i;</span><br><span class="line">            <span class="keyword">return</span> arr[p1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 - p1 != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (p1 + p2) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt;= arr[p1]) p1 = mid;</span><br><span class="line">            <span class="keyword">else</span> p2 = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[p2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯法">回溯法</h2>
<h3 id="矩阵中的路径">矩阵中的路径</h3>
<p><strong>思路：</strong></p>
<p>利用回溯法：</p>
<ul>
<li>首先在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为 ch，并且这个格子将对应于路径上的第 <code>i</code> 个字符。</li>
<li>如果路径上的第 <code>i</code> 个字符不是 ch，那么这个格子不可能处在路径上的第 <code>i</code> 个位置。</li>
<li>如果路径上的第 <code>i</code> 个字符正好是 ch，那么就到相邻的格子寻找路径上的第 <code>i+1</code> 个字符。</li>
<li>除矩阵边界上的格子之外，其它格子都有 4 个相邻的格子。</li>
<li>重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows \ast cols \ast str.length)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixPath</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathCore</span><span class="params">(<span class="type">char</span>[] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] str,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span>[] pathLen, <span class="type">boolean</span>[] visited)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pathLen[<span class="number">0</span>] == str.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPath</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols</span><br><span class="line">                &amp;&amp; matrix[i*cols+j] == str[pathLen[<span class="number">0</span>]]</span><br><span class="line">                &amp;&amp; !visited[i*cols+j])&#123;</span><br><span class="line">            pathLen[<span class="number">0</span>]++;</span><br><span class="line">            visited[i*cols+j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            hasPath = hasPathCore(matrix, rows, cols, i, j-<span class="number">1</span>, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i-<span class="number">1</span>, j, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i, j+<span class="number">1</span>, str, pathLen, visited)</span><br><span class="line">                    || hasPathCore(matrix, rows, cols, i+<span class="number">1</span>, j, str, pathLen, visited);</span><br><span class="line">            <span class="keyword">if</span> (!hasPath)&#123;</span><br><span class="line">                pathLen[<span class="number">0</span>]--;</span><br><span class="line">                visited[i*cols+j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(<span class="type">char</span>[] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows * cols];</span><br><span class="line">        <span class="type">int</span>[] pathLen = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, i, j, str, pathLen, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">机器人的运动范围</h3>
<p><strong>思路：</strong></p>
<p>利用回溯法：</p>
<ul>
<li>机器人从坐标 <code>(0,0)</code> 开始移动。</li>
<li>当它准备进入坐标为 <code>(i,j)</code> 的格子时，通过检查坐标的数位和来判断机器人是否能够进入。</li>
<li>如果机器人能够进入坐标为 <code>(i,j)</code> 的格子，则计数加 1；然后再判断它能否进入右方和下方的格子 <code>(i,j+1)</code>，<code>(i+1,j)</code>。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(rows*cols)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotMoveArea</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDigitSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols</span><br><span class="line">                &amp;&amp; getDigitSum(i) + getDigitSum(j) &lt;= threshold</span><br><span class="line">                &amp;&amp; !visited[i * cols + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">movingCountCore</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(threshold, rows, cols, i, j, visited)) &#123;</span><br><span class="line">            visited[i*cols+j] = <span class="literal">true</span>;</span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, i, j+<span class="number">1</span>, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, cols, i+<span class="number">1</span>, j, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">return</span> movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划与贪心算法">动态规划与贪心算法</h2>
<h2 id="位运算">位运算</h2>
<h3 id="二进制中1的个数">二进制中1的个数</h3>
<p><strong>思路：</strong></p>
<p>把一个整数减去 1，再和原整数做与运算，会把该整数最右边的 1 变成 0。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOf1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOf1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高质量的代码">高质量的代码</h1>
<h2 id="代码的完整性">代码的完整性</h2>
<h3 id="数值的整数次方">数值的整数次方</h3>
<p><strong>思路：</strong></p>
<p>快速幂</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerWithIntExponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exp)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (exp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="literal">true</span>;</span><br><span class="line">            exp = -exp;</span><br><span class="line">            <span class="keyword">if</span> (base == <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            base *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1.0</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印1到最大的n位数">打印1到最大的n位数</h3>
<p><strong>思路：</strong></p>
<p>如果我们在数字前面补 0，就会发现 n 位所有十进制其实就是 n 个从 0 到 9 的全排列。即如果把数字的每一位都从 0 到 9 排列一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的 0 不打印出来罢了。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(10^n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintToMaxOfNDigits</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">char</span>[] num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isZero</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isZero &amp;&amp; num[i] != <span class="string">&#x27;0&#x27;</span>) isZero = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isZero) System.out.print(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isZero) System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printRecursively</span><span class="params">(<span class="type">char</span>[] num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == num.length - <span class="number">1</span>)&#123;</span><br><span class="line">            printNumber(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[index + <span class="number">1</span>] = (<span class="type">char</span>) (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            printRecursively(num, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintToMaxOfNDigits</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span>[] num = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[<span class="number">0</span>] = (<span class="type">char</span>) (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            printRecursively(num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrintToMaxOfNDigits</span>().PrintToMaxOfNDigits(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在o1时间删除链表结点">在O(1)时间删除链表结点</h3>
<p><strong>思路：</strong></p>
<p>对于 n-1 个非尾结点，可以在 <span class="math inline">\(O(1)\)</span> 时间内把下一个结点的内容复制覆盖要删除的结点，并删除下一个结点；对于尾结点，仍需要顺序查找，然后进行删除，时间复杂度是 <span class="math inline">\(O(n)\)</span>；总的平均时间复杂度为 <span class="math inline">\([(n-1)*O(1)+O(n)]/n\)</span>，结果为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Offer.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(ListNode[] pHead, ListNode[] pDel)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pDel == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pDel[<span class="number">0</span>].next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pDel[<span class="number">0</span>].next;</span><br><span class="line">            pDel[<span class="number">0</span>].val = pNode.val;</span><br><span class="line">            pDel[<span class="number">0</span>].next = pNode.next;</span><br><span class="line">            pNode.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pDel == pHead)&#123;</span><br><span class="line">            pDel[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">            pHead[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (pNode.next != pDel[<span class="number">0</span>]) pNode = pNode.next;</span><br><span class="line">            pNode.next = <span class="literal">null</span>;</span><br><span class="line">            pDel[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中重复的结点">删除链表中重复的结点</h3>
<p><strong>思路：</strong></p>
<p>遍历整个链表：</p>
<ul>
<li>如果当前结点的值与下一个结点的值相同，那么它们都要被删除。</li>
<li>为保证删除后的链表仍是相连的，要把当前结点的前一个结点和后面值比当前结点值大的结点相连。</li>
<li>确保前一个结点始终与下一个没有重复的结点连接在一起。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteDuplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplication</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        first.next = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span> &amp;&amp; pNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode.val == pNode.next.val)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> pNode.val;</span><br><span class="line">                <span class="keyword">while</span> (pNode != <span class="literal">null</span> &amp;&amp; pNode.val == val)</span><br><span class="line">                    pNode = pNode.next;</span><br><span class="line">                last.next = pNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last = pNode;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">            pNode.next = tmp;</span><br><span class="line">            pNode = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteDuplication</span>().deleteDuplication(pHead);</span><br><span class="line">        <span class="keyword">while</span> (res != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(res.val);</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">正则表达式匹配</h3>
<p><strong>思路：</strong></p>
<p>根据模式中第二个字符是否为 <code>*</code> 分两种情况考虑：</p>
<ul>
<li>模式中的第二个字符不是 <code>*</code> 时
<ul>
<li>如果字符串中的第一个字符和模式的第一个字符相匹配，则字符串和模式都向后移动一个字符，然后继续匹配剩余字符。</li>
<li>如果字符串中的第一个字符和模式的第一个字符不匹配，则直接返回 false</li>
</ul></li>
<li>模式中的第二个字符是 <code>*</code> 时，有多种匹配模式
<ul>
<li>如果字符串第一个字符和模式第一个字符 <strong>不匹配</strong>，则模式后移两个字符，然后继续匹配剩余字符</li>
<li>如果字符串第一个字符和模式第一个字符 <strong>匹配</strong>，可以有 3 种匹配方式：
<ul>
<li>字符串后移 1 个字符，模式不变</li>
<li>模式后移 2 个字符，相当于 <code>x*</code> 被忽略</li>
<li>字符串后移 1 个字符，模式后移 2 个字符</li>
</ul></li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span>[] str, <span class="type">char</span>[] pattern)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || pattern == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">matchCore</span><span class="params">(<span class="type">char</span>[] str,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> idxStr,</span></span><br><span class="line"><span class="params">                                     <span class="type">char</span>[] pattern,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> idxPat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idxStr == str.length &amp;&amp; idxPat == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (idxStr != str.length &amp;&amp; idxPat == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idxPat + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[idxPat + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (idxStr != str.length</span><br><span class="line">                &amp;&amp; (pattern[idxPat] == str[idxStr] || pattern[idxPat] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat + <span class="number">2</span>)</span><br><span class="line">                        || matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat)</span><br><span class="line">                        || matchCore(str, idxStr, pattern, idxPat + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> matchCore(str, idxStr, pattern, idxPat + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idxStr != str.length</span><br><span class="line">            &amp;&amp; (str[idxStr] == pattern[idxPat] || pattern[idxPat] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, idxStr + <span class="number">1</span>, pattern, idxPat + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(match(<span class="string">&quot;aaa&quot;</span>.toCharArray(), <span class="string">&quot;ab*ac*a&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(match(<span class="string">&quot;&quot;</span>.toCharArray(), <span class="string">&quot;.*&quot;</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表示数值的字符串">表示数值的字符串</h3>
<p><strong>思路：</strong></p>
<p>表示数值的字符串遵循模式 <code>A[.[B]][e|EC]</code> 或者 <code>.B[e|EC]</code>，其中：</p>
<ul>
<li>A 为数值的整数部分（可能以 '+' 或 '-' 开头的 0-9 的数位串）</li>
<li>B 紧跟着小数点为数值的小数部分（0-9 的数位串）</li>
<li>C 紧跟 'e' 或 'E' 为数值的指数部分（可能以 '+' 或 '-' 开头的 0-9 的数位串）</li>
</ul>
<p>在小数里可能没有整数部分，如小数 <code>.123</code> 等于 <code>0.123</code>，因此 A 部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsNumeric</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">scanUnsignedInteger</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span>[] idx)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> idx[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (idx[<span class="number">0</span>] &lt; str.length &amp;&amp; str[idx[<span class="number">0</span>]] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[idx[<span class="number">0</span>]] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> idx[<span class="number">0</span>] &gt; startIdx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">scanInteger</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span>[] idx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] &lt; str.length &amp;&amp; (str[idx[<span class="number">0</span>]] == <span class="string">&#x27;+&#x27;</span> || str[idx[<span class="number">0</span>]] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">char</span>[] str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] idx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numeric</span> <span class="operator">=</span> scanInteger(str, idx);</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] != str.length &amp;&amp; str[idx[<span class="number">0</span>]] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">            numeric = scanUnsignedInteger(str, idx) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>] != str.length &amp;&amp; (str[idx[<span class="number">0</span>]] == <span class="string">&#x27;e&#x27;</span> || str[idx[<span class="number">0</span>]] == <span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(str, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; idx[<span class="number">0</span>] == str.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;.123&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;123.&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;.e2&quot;</span>.toCharArray()));</span><br><span class="line">        System.out.println(isNumeric(<span class="string">&quot;12e&quot;</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</h3>
<p><strong>思路：</strong></p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span>，<span class="math inline">\(P_1\)</span> 指向数组的第一个数字，<span class="math inline">\(P_2\)</span> 指向最后一个数字；</li>
<li><span class="math inline">\(P_1\)</span> 向后移动直至它指向偶数；</li>
<li><span class="math inline">\(P_2\)</span> 向前移动直至它指向奇数；</li>
<li>交换 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向的元素；</li>
<li>直到 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 相遇。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderOddEven</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderOddEven</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; (arr[p1] &amp; <span class="number">1</span>) == <span class="number">1</span>) p1++;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; (arr[p2] &amp; <span class="number">1</span>) == <span class="number">0</span>) p2--;</span><br><span class="line">            <span class="keyword">if</span> (p1 &lt; p2) swap(arr, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面扩展">调整数组顺序使奇数位于偶数前面(扩展)</h3>
<p>调整后保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>思路：</strong></p>
<p>空间换时间</p>
<ul>
<li>遍历两次数组，第一次遍历时将全部的奇数按顺序保存到辅助数组；</li>
<li>第二次遍历时将全部的偶数按顺序追加到数组尾部。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderOddEvenII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reOrderArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) <span class="keyword">if</span> ((e &amp; <span class="number">1</span>) == <span class="number">1</span>) res[k++] = e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) <span class="keyword">if</span> ((e &amp; <span class="number">1</span>) == <span class="number">0</span>) res[k++] = e;</span><br><span class="line">        System.arraycopy(res, <span class="number">0</span>, arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码的鲁棒性">代码的鲁棒性</h2>
<h3 id="链表中倒数第-k-个结点">链表中倒数第 k 个结点</h3>
<p><strong>思路：</strong></p>
<blockquote>
<p>假设整个链表有 n 个结点，那么倒数第 k 个结点就是从头结点开始的第 n-k+1 个结点。</p>
<ul>
<li>遍历一次链表，得到链表长度 n；</li>
<li>第二次遍历时，从头结点开始指针前进 n-k+1 步，即为倒数第 k 个结点。</li>
</ul>
</blockquote>
<p>上面的方法需要遍历两次链表，但我们有只需要遍历一次链表的解法。</p>
<ul>
<li>定义两个指针，第一个指针从链表的头指针开始遍历向前走 k-1 步，第二个指针保持不动；</li>
<li>从第 k 步开始，第二个指针也开始从链表的的头指针开始遍历；</li>
<li>由于两个指针的距离保持在 k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个（走在后面的）指针正好指向倒数第 k 个结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindKthToTail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findKthToTail</span><span class="params">(ListNode pHead, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> pHead, p2 = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span> &amp;&amp; p1 != <span class="literal">null</span>; i++) p1 = p1.next;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中环的入口结点">链表中环的入口结点</h3>
<p><strong>思路：</strong></p>
<p>第一步确定一个链表中是否包含环</p>
<ul>
<li>定义两个指针，同时从链表头结点出发，一个指针一次走一步，另一个指针一次走两步；</li>
<li>如果走得快的指针追上了走得慢的指针，那么链表就包含环；</li>
<li>如果走得快的指针到了链表末尾也没有追上第一个指针，那么链表就不包含环。</li>
</ul>
<p>第二步统计环中的结点数</p>
<ul>
<li>两个指针相遇的结点一定是在环中的，可以从这个结点出发；</li>
<li>一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了。</li>
</ul>
<p>第三步找到环的入口</p>
<ul>
<li>定义两个指针 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向链表头结点，如果链表中的环有 n 个结点，则指针 <span class="math inline">\(P_1\)</span> 先在链表上向前移动 n 步；</li>
<li>然后两个指针以相同的速度向前移动；</li>
<li>当两个指针相遇时，指针指向的结点即为环的入口结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntryNodeOfLoop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">meetingNode</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pSlow</span> <span class="operator">=</span> pHead, pFast = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (pFast != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pFast == pSlow) <span class="keyword">return</span> pFast;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            <span class="keyword">if</span> (pFast != <span class="literal">null</span>) pFast = pFast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">entryNodeOfLoop</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">meetNode</span> <span class="operator">=</span> meetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span> (meetNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodesInLoop</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> meetNode;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != meetNode)&#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            nodesInLoop++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode1</span> <span class="operator">=</span> pHead, pNode2 = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodesInLoop; i++) pNode1 = pNode1.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pNode1 != pNode2)&#123;</span><br><span class="line">            pNode1 = pNode1.next;</span><br><span class="line">            pNode2 = pNode2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">EntryNodeOfLoop</span> <span class="variable">entryNodeOfLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntryNodeOfLoop</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node3;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">entryNode</span> <span class="operator">=</span> entryNodeOfLoop.entryNodeOfLoop(node1);</span><br><span class="line">        System.out.println(entryNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表">反转链表</h3>
<p><strong>思路：</strong></p>
<p>定义 3 个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pPrev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        ListNode pNext;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pNext = pNode.next;</span><br><span class="line">            pNode.next = pPrev;</span><br><span class="line">            pPrev = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pPrev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序的链表">合并两个排序的链表</h3>
<p><strong>思路：</strong></p>
<p>把两个链表中值较小的头结点链接到已合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeTwoOrderedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode pResHead;</span><br><span class="line">        <span class="keyword">if</span> (pHead1.val &lt; pHead2.val)&#123;</span><br><span class="line">            pResHead = pHead1;</span><br><span class="line">            pResHead.next = merge(pHead1.next, pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pResHead = pHead2;</span><br><span class="line">            pResHead.next = merge(pHead1, pHead2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pResHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeII</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">        ListNode pResHead, pResEnd, pNode1, pNode2;</span><br><span class="line">        <span class="keyword">if</span> (pHead1.val &lt; pHead2.val)&#123;</span><br><span class="line">            pResHead = pResEnd = pHead1;</span><br><span class="line">            pNode1 = pHead1.next;</span><br><span class="line">            pNode2 = pHead2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pResHead = pResEnd = pHead2;</span><br><span class="line">            pNode1 = pHead1;</span><br><span class="line">            pNode2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode1 != <span class="literal">null</span> &amp;&amp; pNode2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode minNode;</span><br><span class="line">            <span class="keyword">if</span> (pNode1.val &lt; pNode2.val)&#123;</span><br><span class="line">                minNode = pNode1;</span><br><span class="line">                pNode1 = pNode1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                minNode = pNode2;</span><br><span class="line">                pNode2 = pNode2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pResEnd = pResEnd.next = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pResEnd.next = (pNode1 != <span class="literal">null</span>) ? pNode1 : pNode2;</span><br><span class="line">        <span class="keyword">return</span> pResHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的子结构">树的子结构</h3>
<p><strong>思路：</strong></p>
<p>分两步：第一步，在树 A 中找到和树 B 的根结点的值一样的结点 R；第二步，判断树 A 中以 R 为根结点的子树是否包含和树 B 一样的结构。</p>
<p>对于第二步同样可以用递归的思路来考虑：如果结点 R 的值和树 B 的根结点不同，则以 R 为根结点的子树和树 B 肯定不具有相同的结点；如果它们的值相同，则递归地判断它们各自的左右结点的值是不是相同。递归终止的条件是我们达到了树 A 或者树 B 的叶子结点。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n*m)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasSubTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doesTree1HaveTree2</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1.val == pRoot2.val)</span><br><span class="line">            <span class="keyword">return</span> doesTree1HaveTree2(pRoot1.left, pRoot2.left)</span><br><span class="line">                    &amp;&amp; doesTree1HaveTree2(pRoot1.right, pRoot2.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasSubTree</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 != <span class="literal">null</span> &amp;&amp; pRoot2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pRoot1.val == pRoot2.val)</span><br><span class="line">                result = doesTree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">            <span class="keyword">if</span> (!result) result = hasSubTree(pRoot1.left, pRoot2);</span><br><span class="line">            <span class="keyword">if</span> (!result) result = hasSubTree(pRoot1.right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解决面试题的思路">解决面试题的思路</h1>
<h2 id="面试官谈面试思路">面试官谈面试思路</h2>
<h3 id="二叉树的镜像">二叉树的镜像</h3>
<p><strong>思路：</strong></p>
<p>前序遍历树的每一个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左、右子结点之后，就得到了树的镜像。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeMirror</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mirror</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> pRoot.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> pRoot.right;</span><br><span class="line">        pRoot.left = right;</span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) mirror(left);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) mirror(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称的二叉树">对称的二叉树</h3>
<p><strong>思路：</strong></p>
<p>定义一种对称的前序遍历算法，即先遍历父结点，再遍历它的右子结点，最后遍历它的左子结点。</p>
<p>针对一颗二叉树，分别使用前序遍历算法和对称的前序遍历算法进行遍历，如果两次遍历得到的序列一样，则该二叉树是对称的。</p>
<p>注：遍历的过程中需要把 null 结点也考虑在内。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsSymmetrical</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> &amp;&amp; pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> || pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1.val != pRoot2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot1.left, pRoot2.right)</span><br><span class="line">                &amp;&amp; isSymmetrical(pRoot1.right, pRoot2.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="画图让抽象问题形象化">画图让抽象问题形象化</h2>
<h3 id="顺时针打印矩阵">顺时针打印矩阵</h3>
<p><strong>思路：</strong></p>
<p>由于是以外圈到内圈的顺序依次打印的，所以我们可以把矩阵想象成若干个圈，如下图所示，可以用一个循环来打印矩阵，每次打印矩阵中的一个圈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/85361b2d31f9d61a9ac306659ca69f52.png" alt="print-matrix-in-circle" /></p>
<p>假设矩阵的行数为 rows，列数为 cols，则循环结束的条件为： <code>cols &gt; startX * 2 &amp;&amp; rows &gt; startY * 2</code>， <code>(startX, startY)</code> 为本次循环要打印的第一个位置的坐标。</p>
<p>接着我们考虑如何打印一圈的功能，即如何实现 printMatrixInCircle。我们可以把打印一圈分成四步：</p>
<ul>
<li>第一步，从左到右打印一行；</li>
<li>第二步，从上到下打印一列；</li>
<li>第三步，从右到左打印一行；</li>
<li>第四步，从下到上打印一列。</li>
</ul>
<p>几个退化的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/58cadd0fdd8be83d5702f3d50abd3e7f.png" alt="matrix-degradation-examples" /></p>
<ul>
<li>经分析发现，第一步总是需要的；</li>
<li>如果只有一行，那就不用第二步了，也即进行第二步的前提条件是终止行号大于起始行号；</li>
<li>需要第三步的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号，还有终止列号大于起始列号。</li>
<li>同理，第四步的前提条件是至少有三行两列，因此要求终止行号比起始行号至少大 2，同时终止列号大于起始列号。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n*m)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMatrixClockwisely</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMatrixInCircle</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> rows, <span class="type">int</span> cols,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> start, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endX</span> <span class="operator">=</span> cols - <span class="number">1</span> - start, endY = rows - <span class="number">1</span> - start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= endX; i++) res.add(matrix[start][i]);</span><br><span class="line">        <span class="keyword">if</span> (endY &gt; start)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt;= endY; i++) res.add(matrix[i][endX]);</span><br><span class="line">        <span class="keyword">if</span> (endY &gt; start &amp;&amp; endX &gt; start)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> endX - <span class="number">1</span>; i &gt;= start; i--) res.add(matrix[endY][i]);</span><br><span class="line">        <span class="keyword">if</span> (endX &gt; start &amp;&amp; endY - start &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> endY - <span class="number">1</span>; i &gt; start; i--) res.add(matrix[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printMatrixClockwisely</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cols &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>)</span><br><span class="line">            printMatrixInCircle(matrix, rows, cols, start++, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="举例让抽象问题具体化">举例让抽象问题具体化</h2>
<h3 id="包含-min-函数的栈">包含 min 函数的栈</h3>
<p><strong>思路：</strong></p>
<p>使用两个栈，数据栈和辅助栈；</p>
<ul>
<li>每当数据栈压入数据后，辅助栈压入当前数据栈的最小值；</li>
<li>每当数据栈弹出数据后，辅助栈也直接弹出栈顶元素。</li>
</ul>
<p><strong>时间复杂度：</strong> min 函数 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackWithMin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; dataStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        dataStack.push(num);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) minStack.push(num);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curMin</span> <span class="operator">=</span> minStack.peek();</span><br><span class="line">            minStack.push((num &lt; curMin) ? num : curMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的压入弹出序列">栈的压入、弹出序列</h3>
<p><strong>思路：</strong></p>
<p>建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>
<p>判断一个序列是不是栈的弹出序列的规律：</p>
<ul>
<li>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；</li>
<li>如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；</li>
<li>如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsPopOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPopOrder</span><span class="params">(<span class="type">int</span>[] pPush, <span class="type">int</span>[] pPop)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pPush == <span class="literal">null</span> || pPop == <span class="literal">null</span></span><br><span class="line">                || pPush.length != pPop.length || pPush.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curPush</span> <span class="operator">=</span> <span class="number">0</span>, curPop = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curPop &lt; pPop.length)&#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.isEmpty() || stack.peek() != pPop[curPop])&#123;</span><br><span class="line">                <span class="keyword">if</span> (curPush == pPush.length) <span class="keyword">break</span>;</span><br><span class="line">                stack.push(pPush[curPush++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.peek() != pPop[curPop]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            stack.pop();</span><br><span class="line">            curPop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curPop == pPop.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从上到下打印二叉树">从上到下打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用一个辅助队列，每次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放入队列的尾部。接着取出队列的下一个结点，重复前面的打印操作。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintFromTopToBottom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">printFromTopToBottom</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分行从上到下打印二叉树">分行从上到下打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用一个辅助队列来保存将要打印的结点；其次需要定义两个变量：一个变量 <code>last</code> 表示当前层的尾结点；另一个变量 <code>nextLast</code> 表示下一层的尾结点。</p>
<ul>
<li>在打印某一层结点时，把下一层的子结点保存到队列中。</li>
<li>在把下一层的结点加到队列时，同步更新 <code>nextLast</code>，使 <code>nextLast</code> 指向队列的尾结点。</li>
<li>在打印到本层的尾结点时，更新 <code>last</code>，使 <code>last = nextLast</code></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LayerPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> pRoot, nextLast = pRoot;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            layer.add(pNode.val);</span><br><span class="line">            <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(pNode.left);</span><br><span class="line">                nextLast = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(pNode.right);</span><br><span class="line">                nextLast = pNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pNode == last)&#123;</span><br><span class="line">                last = nextLast;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="之字形打印二叉树">之字形打印二叉树</h3>
<p><strong>思路：</strong></p>
<p>使用两个辅助栈：</p>
<ul>
<li>在打印某一层结点时，把下一层的子结点保存到相应的栈里。</li>
<li>如果当前打印的奇数层（第 1 层、第 3 层等），则先保存左子结点再保存右子结点到第一个栈里；</li>
<li>如果当前打印的是偶数层（第 2 层、第 4 层等），则先保存右子结点再保存左子结点到第二个栈里。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList[] levels = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">2</span>];</span><br><span class="line">        levels[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        levels[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>, next = <span class="number">1</span>;</span><br><span class="line">        levels[current].push(pRoot);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!levels[<span class="number">0</span>].isEmpty() || !levels[<span class="number">1</span>].isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> (TreeNode) levels[current].pop();</span><br><span class="line">            layer.add(pNode.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) levels[next].push(pNode.left);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) levels[next].push(pNode.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) levels[next].push(pNode.right);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) levels[next].push(pNode.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (levels[current].isEmpty())&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                current = <span class="number">1</span> - current;</span><br><span class="line">                next = <span class="number">1</span> - next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZPrintTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">print</span><span class="params">(TreeNode pRoot)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; layerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> layerList;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack1.size();</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">                layer.add(pNode.val);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) stack2.push(pNode.left);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) stack2.push(pNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack1.size() != size)&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            size = stack2.size();</span><br><span class="line">            <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">                layer.add(pNode.val);</span><br><span class="line">                <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) stack1.push(pNode.right);</span><br><span class="line">                <span class="keyword">if</span> (pNode.left != <span class="literal">null</span>) stack1.push(pNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack2.size() != size)&#123;</span><br><span class="line">                layerList.add(layer);</span><br><span class="line">                layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layerList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列</h3>
<p><strong>思路：</strong></p>
<p>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结点的值小；第二部分是右子树结点的值，它们都比根结点的值大。</p>
<p>以数组 {5,7,6,9,11,10,8} 为例，后序遍历结果的最后一个数字 8 就是根结点的值。在这个数组中，前 3 个数字 5、7 和 6 都比 8 小，是值为 8 的结点的左子树结点；后 3 个数字 9、11 和 10 都比 8 大，是值为 8 的结点的右子树结点。所以我们可以用同样的方法确定与数组每一部分对应的子树的结构。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifySequenceOfBST</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">verifyCore</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> sequence[right], sep = left;</span><br><span class="line">        <span class="keyword">while</span> (sep &lt; right &amp;&amp; sequence[sep] &lt; root) sep++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sep + <span class="number">1</span>; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verifyCore(sequence, left, sep - <span class="number">1</span>)</span><br><span class="line">                &amp;&amp; verifyCore(sequence, sep, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifySequenceOfBST</span><span class="params">(<span class="type">int</span>[] sequence)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="literal">null</span> || sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verifyCore(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径">二叉树中和为某一值的路径</h3>
<p><strong>思路：</strong></p>
<p>经分析，当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。</p>
<ul>
<li>如果该结点为叶子结点，并且路径中结点值的和刚好等于输入的整数，则当前路径符合要求，我们把它打印出来。</li>
<li>如果当前结点不是叶子结点，则继续访问它的子结点。</li>
<li>当前结点访问结束后，递归函数自动回到它的父结点。因此在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是从根结点到父结点。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindPath</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPathCore</span><span class="params">(TreeNode root, <span class="type">int</span> target, <span class="type">int</span>[] curSum,</span></span><br><span class="line"><span class="params">                              ArrayList&lt;Integer&gt; curPath,</span></span><br><span class="line"><span class="params">                              ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths)</span>&#123;</span><br><span class="line">        curSum[<span class="number">0</span>] += root.val;</span><br><span class="line">        curPath.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; curSum[<span class="number">0</span>] == target)</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curPath)); <span class="comment">//浅拷贝，线性时间</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">            findPathCore(root.left, target, curSum, curPath, paths);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">            findPathCore(root.right, target, curSum, curPath, paths);</span><br><span class="line">        curPath.remove(curPath.size()-<span class="number">1</span>);</span><br><span class="line">        curSum[<span class="number">0</span>] -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">findPath</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        <span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; curPath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findPathCore(root, target, curSum, curPath, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分解让复杂问题简单化">分解让复杂问题简单化</h2>
<h3 id="复杂链表的复制">复杂链表的复制</h3>
<p><strong>思路：</strong></p>
<ul>
<li><p>第一步根据原始链表的每个结点 <span class="math inline">\(N\)</span> 创建对应的 <span class="math inline">\(N&#39;\)</span>，直接把 <span class="math inline">\(N&#39;\)</span> 链接在 <span class="math inline">\(N\)</span> 的后面。经过这一步之后的结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cda1edfddae568a341e0c80d10953827.png" alt="complex-linked-list-copy-1" /></p></li>
<li><p>第二步设置复制出来的结点的 random。假设原始链表上的 <span class="math inline">\(N\)</span> 的 random 指向结点 <span class="math inline">\(S\)</span>，那么其对应复制出来的 <span class="math inline">\(N&#39;\)</span> 是 <span class="math inline">\(N\)</span> 的 next 的指向的结点，同理 <span class="math inline">\(S&#39;\)</span> 也是 <span class="math inline">\(S\)</span> 的 next 指向的结点。设置 random 之后的链表如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8e7ab743619ec1b0e2f6b61e4b57a6ef.png" alt="complex-linked-list-copy-2" /></p></li>
<li><p>第三步把这个长链表拆分成两个链表：把奇数位置的结点用 next 连接起来就是原始链表，把偶数位置的结点用 next 链接起来就是复制出来的链表。链表拆分之后的两个链表如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ee3d5a227becfec5b725c133ede3bd48.png" alt="complex-linked-list-copy-3" /></p></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> label;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">random</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="type">int</span> label) &#123;</span><br><span class="line">        <span class="built_in">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexLinkedListCopy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cloneNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">pClone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(pNode.label);</span><br><span class="line">            pClone.next = pNode.next;</span><br><span class="line">            pNode.next = pClone;</span><br><span class="line">            pNode = pClone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectRandomNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">RandomListNode</span> <span class="variable">pClone</span> <span class="operator">=</span> pNode.next;</span><br><span class="line">            <span class="keyword">if</span> (pNode.random != <span class="literal">null</span>) pClone.random = pNode.random.next;</span><br><span class="line">            pNode = pClone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RandomListNode <span class="title function_">reconnectNodes</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">pCloneHead</span> <span class="operator">=</span> <span class="literal">null</span>, pCloneNode = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pCloneHead = pCloneNode = pNode.next;</span><br><span class="line">            pNode.next = pCloneNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            pCloneNode.next = pNode.next;</span><br><span class="line">            pCloneNode = pCloneNode.next;</span><br><span class="line">            pNode.next = pCloneNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">clone</span><span class="params">(RandomListNode pHead)</span>&#123;</span><br><span class="line">        cloneNodes(pHead);</span><br><span class="line">        connectRandomNodes(pHead);</span><br><span class="line">        <span class="keyword">return</span> reconnectNodes(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表">二叉搜索树与双向链表</h3>
<p><strong>思路：</strong></p>
<p>在二叉搜索树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在将二叉搜索树转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点的指针。</p>
<p>按照中序遍历的顺序，当我们遍历转换到根结点时，它的左子树已经转换成一个排序的链表了，并且处在链表中的最后一个结点是当前值最大的结点。我们把这个结点和根结点链接起来，此时链表中的最后一个结点就是根结点了。接着我们去遍历转换右子树，并把根结点和右子树中最小的结点链接起来。子树的转换过程是一样的，所以我们可以用递归解决。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTreeConvertToDLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">convertNode</span><span class="params">(TreeNode pRoot, TreeNode[] pLast)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        convertNode(pRoot.left, pLast);</span><br><span class="line"></span><br><span class="line">        pRoot.left = pLast[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (pLast[<span class="number">0</span>] != <span class="literal">null</span>) pLast[<span class="number">0</span>].right = pRoot;</span><br><span class="line">        pLast[<span class="number">0</span>] = pRoot;</span><br><span class="line"></span><br><span class="line">        convertNode(pRoot.right, pLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convert</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode[] pLast = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[]&#123;<span class="literal">null</span>&#125;;</span><br><span class="line">        convertNode(pRoot, pLast);</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pHeadOfList</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        <span class="keyword">while</span> (pHeadOfList.left != <span class="literal">null</span>) pHeadOfList = pHeadOfList.left;</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树">序列化二叉树</h3>
<p><strong>思路：</strong></p>
<ul>
<li>序列化
<ul>
<li>根据前序遍历的顺序来序列化二叉树；</li>
<li>在遍历时，遇到 null 指针时，将这些 null 指针序列化为一个特殊的字符（如 <code>$</code> ）；</li>
<li>其次结点的数值之间要用一个特殊的字符（如 <code>,</code> ）隔开。</li>
</ul></li>
<li>反序列化
<ul>
<li>以 <code>"1,2,4,$,$,$,3,5,$,$,6,$,$"</code> 为例：</li>
<li>第一个读出的是 1，由于前序遍历是从根结点开始的，这是根结点的值。</li>
<li>接下来读出的是 2，根据前序遍历的规则，这是根结点的左子结点。</li>
<li>同样，接下来的 4 是 2 的左子结点。</li>
<li>接着从序列读出两个 <code>$</code>，这表明 4 的左、右子结点均为 null，因此它是一个叶子结点。</li>
<li>接下来回到 2 的结点，重建它的右子结点。</li>
<li>由于下一个是 <code>$</code>，这表明 2 的右子结点为 null，说明这个结点的左、右子树都已构建完毕。</li>
<li>接下来回到根结点，同样的方法反序列化根结点的右子树。</li>
</ul></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeAndDeserialize</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> String[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toSerial</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        toSerial(root.left);</span><br><span class="line">        toSerial(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        toSerial(root);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">toDeserial</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes[++index].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(nodes[index]));</span><br><span class="line">            root.left = toDeserial();</span><br><span class="line">            root.right = toDeserial();</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserailize</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">null</span>) nodes = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> toDeserial();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的排列">字符串的排列</h3>
<p><strong>思路：</strong></p>
<p>把一个字符串看成由两部分组成：第一部分是它的第一个字符；第二部分是后面的所有字符。求整个字符串的排列，可以看成两步：</p>
<ul>
<li>第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。</li>
<li>第二步固定第一个字符，求后面所有字符的排列，这时仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后进行同样的操作。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permutation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">permutationCore</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, ArrayList&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == arr.length) res.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; arr[i] == arr[start]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            permutationCore(arr, start + <span class="number">1</span>, res);</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permutationCore(str.toCharArray(), <span class="number">0</span>, res);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化时间和空间效率">优化时间和空间效率</h1>
<h2 id="时间效率">时间效率</h2>
<h3 id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</h3>
<p><strong>思路：</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其它所有数字出现次数的和还要多。因此我们可以考虑 <strong>在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。</strong></p>
<p>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加 1；如果下一个数字和我们之前保存的数字不同，则次数减 1。如果次数为 0，则保存下一个数字，并把次数设为 1。</p>
<p>由于要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次吧次数设为 1 时对应的数字。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoreThanHalfNum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkMoreThanHalf</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> result)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anArr : arr) <span class="keyword">if</span> (anArr == result) times++;</span><br><span class="line">        <span class="keyword">return</span> times &gt; arr.length / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">moreThanHalfNum</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == result) times++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((--times) == <span class="number">0</span>)&#123;</span><br><span class="line">                result = arr[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkMoreThanHalf(arr, result) ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(moreThanHalfNum(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的-k-个数">最小的 k 个数</h3>
<p><strong>思路：</strong></p>
<p>可以基于 partition 函数来解决这个问题。</p>
<p>如果基于数组的第 k 个数字来调整，使得比第 k 个数字小的所有数字都位于数组的左边，比第 k 个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的 k 个数字就是最小的 k 个数字（这 k 个数字不一定是排序的）。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetLeastNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, ++j, right);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right, base = arr[left], tmp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j] &gt;= base &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt;= base &amp;&amp; i &lt; j) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                tmp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[i];</span><br><span class="line">        arr[i] = base;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">getLeastNumbers</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="literal">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(input, left, right);</span><br><span class="line">        <span class="keyword">while</span>(index != k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; k -<span class="number">1</span>) right = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) result.add(input[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = getLeastNumbers(arr, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: res) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流中的中位数">数据流中的中位数</h3>
<p><strong>思路：</strong></p>
<p>如果数据在容器中已经排序，那么中位数可以由 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向的数得到。如果容器中的数据的数目是奇数，那么 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2\)</span> 指向同一个数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/508dae0cb6875456956be8d1d2e7434c.png" alt="median-in-data-stream" /></p>
<ul>
<li><span class="math inline">\(P_1\)</span> 指向的数据是左边部分的最大的数，<span class="math inline">\(P_2\)</span> 指向的数据是左边部分最小的数。</li>
<li>如果能够保证容器左边的数据小于右边的数据，那么即使左右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。</li>
</ul>
<p>可以用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 <span class="math inline">\(O(logn)\)</span>；得到中位数的时间复杂度是 <span class="math inline">\(O(1)\)</span>。</p>
<ul>
<li>插入时要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1。</li>
<li>可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最大堆。</li>
<li>在插入时同时要保证最大堆的所有数据都要小于最小堆的数据。</li>
</ul>
<p><strong>时间复杂度：</strong> 插入一个数据的时间效率是 <span class="math inline">\(O(logn)\)</span>；得到中位数的时间复杂度是 <span class="math inline">\(O(1)\)</span>。</p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianOfDataStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">16</span>, (o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getMedian</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (count % <span class="number">2</span> == <span class="number">0</span>) ? (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span> : <span class="number">1.0</span> * minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">连续子数组的最大和</h3>
<p><strong>思路：</strong></p>
<p>可以利用动态规划来解决这个问题。</p>
<p>如果用函数 <code>dp[i]</code> 表示以第 <code>i</code> 个数字结尾的子数组的最大和，那么我们要求出 <code>max(dp[i])</code>，其中 <code>0&lt;=i&lt;=n</code>。状态转移方程如下：</p>
<p><span class="math display">\[
dp[i] = \left\{\begin{aligned}
&amp; arr[i] &amp;  &amp; {i=0\ or\ dp[i-1] \le 0 }\\
&amp; dp[i-1]+arr[i] &amp; &amp; {i \neq 0\ and\ dp[i-1] \gt 0}
\end{aligned}\right.
\]</span></p>
<p>这个公式的意义：当以第 <code>i-1</code> 个数字结尾的子数组的最大和小于等于 0 时，如果把这个负数与第 <code>i</code> 个数累加，得到的结果比第 <code>i</code> 个数字本身还要小，所以这种情况下以第 <code>i</code> 个数字结尾的子数组的最大和就是第 <code>i</code> 个数字本身。</p>
<p>如果以第 <code>i-1</code> 个数字结尾的子数组的最大和大于 0，则与第 <code>i</code> 个数字累加就得到以第 <code>i</code> 个数字为结尾的子数组的最大和。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindGreatestSumOfSubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> curSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt;= <span class="number">0</span>) curSum = arr[i];</span><br><span class="line">            <span class="keyword">else</span> curSum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &gt; maxSum) maxSum = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(findGreatestSumOfSubArray(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="从-1-到-n-整数中-1-出现的次数">从 1 到 n 整数中 1 出现的次数</h3>
<p><strong>思路：</strong></p>
<p>https://blog.csdn.net/yi_Afly/article/details/52012593</p>
<p>对每一位来说，记每一位的权值为 base，位值为 weight，该位之前的数是 former，举例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/271fc1b413a66e12a97f96ab1640df19.png" alt="count-1-occurrences" /></p>
<p>则有：</p>
<ul>
<li>若 <code>weight = 0</code>，则 1 出现的次数为 <code>round * base</code></li>
<li>若 <code>weight = 1</code>，则 1 出现的次数为 <code>round * base + former + 1</code></li>
<li>若 <code>weight &gt; 1</code>，则 1 出现的次数为 <code>round * base + base</code></li>
</ul>
<p>注：<span class="math inline">\(base=10^i\)</span>，<code>i</code> 为当前位右边位的个数，如当前位为个位，则 <code>i=0</code></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOf1Between1AndN</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countNumberOfOne</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">1</span>, round = n;</span><br><span class="line">        <span class="keyword">while</span> (round &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> round % <span class="number">10</span>;</span><br><span class="line">            round /= <span class="number">10</span>;</span><br><span class="line">            counter += round * base;</span><br><span class="line">            <span class="keyword">if</span> (weight == <span class="number">1</span>) counter += (n % base + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (weight &gt; <span class="number">1</span>) counter += base;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(countNumberOfOne(<span class="number">534</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">把数组排成最小的数</h3>
<p><strong>思路：</strong></p>
<p>对数组进行排序，排序时需要判断 a 和 b 哪个应该排在前面，判断规则如下：</p>
<p>将 a 和 b 分别拼接成 ab 和 ba，比较 ab 和 ba 的字典序：</p>
<ul>
<li>若 ab &lt; ba，则 a 应该排在 b 前面</li>
<li>若 ab = ba，说明 a=b</li>
<li>若 ab &gt; ba，则 b 应该排在 a 前面</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMinNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> a + b, ba = b + a;</span><br><span class="line">        <span class="keyword">return</span> ab.compareTo(ba) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span>(compare(String.valueOf(arr[i]), String.valueOf(arr[right])))</span><br><span class="line">            	swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printMinNumber</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) sb.append(e);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">        System.out.println(printMinNumber(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMinNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printMinNumber</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anArr : arr) arrayList.add(anArr);</span><br><span class="line">        arrayList.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> o1.toString() + o2.toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ba</span> <span class="operator">=</span> o2.toString() + o1.toString();</span><br><span class="line">            <span class="keyword">return</span> ab.compareTo(ba);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arrayList) sb.append(e);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">        System.out.println(printMinNumber(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间效率与空间效率的平衡">时间效率与空间效率的平衡</h2>
<h3 id="丑数">丑数</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存排好序的丑数，利用已得到的丑数计算出下一个丑数，并将新的丑数加到数组尾部。</p>
<p>利用已得有序丑数计算下一个丑数的思路：</p>
<p>每一个丑数都是前面的丑数乘以 2、3 或者 5 得到的（除 1 以外）。</p>
<ul>
<li>假设已有最大的丑数记为 <span class="math inline">\(M\)</span></li>
<li><span class="math inline">\(T_2\)</span> 代表着数组的某个丑数的下标，这个丑数满足 <span class="math inline">\(arr[T_2] \ast 2 &gt; M\)</span>，同时若有任意小于 <span class="math inline">\(arr[T_2]\)</span> 的丑数 <span class="math inline">\(arr[T]\)</span>，则 <span class="math inline">\(T\)</span> 满足 <span class="math inline">\(arr[T] \ast 2 \le M\)</span>，<span class="math inline">\(T_3\)</span>、<span class="math inline">\(T_5\)</span> 的含义与 <span class="math inline">\(T_2\)</span> 类似</li>
<li><span class="math inline">\(M_2 = arr[T_2] \ast 2\)</span>，<span class="math inline">\(M_3 = arr[T_3] \ast 3\)</span>，<span class="math inline">\(M_5 = arr[T_5] \ast 5\)</span>，则下一个丑数为 <span class="math inline">\(M&#39; = min(M_2, M_3, M_5)\)</span></li>
<li>每次计算完下一个丑数 <span class="math inline">\(M&#39;\)</span>，及时更新 <span class="math inline">\(T_2\)</span>、<span class="math inline">\(T_3\)</span>、<span class="math inline">\(T_5\)</span></li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetUglyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getUglyNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> arr[t2] * <span class="number">2</span>, m3 = arr[t3] * <span class="number">3</span>, m5 = arr[t5] * <span class="number">5</span>;</span><br><span class="line">            arr[i] = Math.min(Math.min(m2, m3), m5);</span><br><span class="line">            <span class="keyword">while</span> (arr[t2] * <span class="number">2</span> &lt;= arr[i]) t2++;</span><br><span class="line">            <span class="keyword">while</span> (arr[t3] * <span class="number">3</span> &lt;= arr[i]) t3++;</span><br><span class="line">            <span class="keyword">while</span> (arr[t5] * <span class="number">5</span> &lt;= arr[i]) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(getUglyNumber(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第一个只出现一次的字符">第一个只出现一次的字符</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存每个字母出现的次数，该数组相当于一个哈希表。</p>
<p>为了解决这个问题，需要从头开始扫描字符串两次：</p>
<ul>
<li>第一次扫描时，每扫描到一个字符就在数组的对应项中把次数加1</li>
<li>第二次扫描时，每扫描到一个字符就从数组中取出对应出现的次数</li>
</ul>
<p>这样第一个只出现一次的字符就是符合要求的输出。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstNotRepeatingChar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstNotRepeatingChar</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] counters = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">123</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            counters[str.charAt(i)]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            <span class="keyword">if</span> (counters[str.charAt(i)] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(firstNotRepeatingChar(<span class="string">&quot;abaccdeff&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流中第一个只出现一次的字符">字符流中第一个只出现一次的字符</h3>
<p><strong>思路：</strong></p>
<p>用空间换时间，创建一个数组，保存 <strong>字符在字符流中的位置</strong>。</p>
<ul>
<li>当一个字符第一次从字符流中读出来时，把它在字符流中的位置保存到数据容器中。</li>
<li>当这个字符再次从字符流中读出来时，那么它就不是只出现一次的字符，也就可以被忽略了。这时把它在数据容器中保存的值更新成一个特殊的值。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStatistics</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] occurrence = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) occurrence[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (occurrence[ch] == -<span class="number">1</span>) occurrence[ch] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (occurrence[ch] &gt;= <span class="number">0</span>) occurrence[ch] = -<span class="number">2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstAppearingOnce</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; minIdx)&#123;</span><br><span class="line">                ch = (<span class="type">char</span>) i;</span><br><span class="line">                minIdx = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">CharStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharStatistics</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="string">&quot;google&quot;</span>.toCharArray()) &#123;</span><br><span class="line">            statistics.insert(ch);</span><br><span class="line">            System.out.println(statistics.firstAppearingOnce());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">数组中的逆序对</h3>
<p><strong>思路：</strong></p>
<p>利用归并排序统计逆序对数。</p>
<ul>
<li>把数组分隔成子数组</li>
<li>先统计出子数组内部的逆序对的数目</li>
<li>然后再统计出两个相邻子数组之间的逆序对的数目</li>
</ul>
<p>在统计逆序对的过程中，还需要对数组进行排序。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p>额外空间复杂度 <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<p>可能会溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InversePairsCore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid, j = right, k = right, counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= left &amp;&amp; j &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j])&#123;</span><br><span class="line">                counter += (j - mid);</span><br><span class="line">                tmp[k--] = arr[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k--] = arr[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= left) tmp[k--] = arr[i--];</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= mid + <span class="number">1</span>) tmp[k--] = arr[j--];</span><br><span class="line">        k = left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) arr[left++] = tmp[k++];</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> mergeSort(arr, left, mid, tmp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> mergeSort(arr, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> merge(arr, left, mid, right, tmp);</span><br><span class="line">            <span class="keyword">return</span> part1 + part2 + part3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inversePairs</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = new int[]&#123;7,5,6,4&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(inversePairs(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个链表的第一个公共结点">两个链表的第一个公共结点</h3>
<p><strong>思路：</strong></p>
<p>从结点的定义看，两个链表为单链表，如果两个链表有公共结点，那么从第一公共结点开始，之后它们的所有结点都是重合的，不可能在出现分叉。所以两个有公共结点而部分重合的链表，其拓扑形状看起来像一个 Y，而不可能像 X。</p>
<p>这道题的关键是当两个链表的长度不相同时，如何同时遍历到两个链表的第一个公共结点，利用两个辅助栈可以实现从链表尾部开始同时遍历到第一个公共结点，但是我们有更简单的方法：</p>
<ul>
<li>首先遍历两个链表得到它们的长度</li>
<li>在第二次遍历的时候，在较长的链表上先走若干步，使得剩余步数与另一链表一致</li>
<li>接着同时在两个链表遍历，找到的第一个相同的结点即为它们的第一个公共结点</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(m+n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindFirstCommonNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getListLength</span><span class="params">(ListNode pHead)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">null</span> || pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getListLength(pHead1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> getListLength(pHead2);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pNode1</span> <span class="operator">=</span> pHead1, pNode2 = pHead2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.abs(len1 - len2);</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (t-- != <span class="number">0</span>) pNode2 = pNode2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (t-- != <span class="number">0</span>) pNode1 = pNode1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode1 != pNode2)&#123;</span><br><span class="line">            pNode1 = pNode1.next;</span><br><span class="line">            pNode2 = pNode2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">        node6.next = node7;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">        node3.next = node6;</span><br><span class="line">        node5.next = node6;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        node4.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        System.out.println(findFirstCommonNode(node1, node4).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试中的各项能力">面试中的各项能力</h1>
<h2 id="知识迁移能力">知识迁移能力</h2>
<h3 id="数字在排序数组中出现的次数">数字在排序数组中出现的次数</h3>
<p><strong>思路：</strong></p>
<p>因为数组是有序的，要快速统计数字 k 出现的次数的关键是如何找到第一个 k 和最后一个 k，<code>最后一个k的索引 - 第一个k的索引 + 1</code> 即为 k 出现的次数。而第一个 k 和最后一个 k 的查找可以使用二分查找得到。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNumberOfK</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFirstK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == left || arr[mid-<span class="number">1</span>] != k) <span class="keyword">return</span> mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLastK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] != k) <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> getFirstK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastK</span> <span class="operator">=</span> getLastK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">if</span> (firstK == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(getNumberOfK(arr, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的第-k-大结点">二叉搜索树的第 k 大结点</h3>
<p><strong>思路：</strong></p>
<p>如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KthNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kthNode</span><span class="params">(TreeNode pRoot, ArrayList&lt;TreeNode&gt; nodes)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot.left != <span class="literal">null</span>) kthNode(pRoot.left, nodes);</span><br><span class="line">        nodes.add(pRoot);</span><br><span class="line">        <span class="keyword">if</span> (pRoot.right != <span class="literal">null</span>) kthNode(pRoot.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">kthNode</span><span class="params">(TreeNode pRoot, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        kthNode(pRoot, nodes);</span><br><span class="line">        <span class="keyword">return</span> k &gt; nodes.size() ? <span class="literal">null</span> : nodes.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的深度">二叉树的深度</h3>
<p><strong>思路：</strong></p>
<p>可以从另一个角度来理解树的深度。如果一棵树只有一个结点，它的深度为 1。如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加 1；同样如果根结点只有右子树而没有左子树，那么树的深度就是其左、右子树深度的较大值再加 1。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn) \sim O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDepth</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(treeDepth(root.left) + <span class="number">1</span>, treeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        node5.left = node7;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        node2.left = node4;</span><br><span class="line">        node2.right = node5;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        node3.right = node6;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line"></span><br><span class="line">        System.out.println(treeDepth(node1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断平衡二叉树">判断平衡二叉树</h3>
<p><strong>思路：</strong></p>
<p>如果某二叉树中任意结点的左右子树的深度相差不超过 1，那么它就是一颗平衡二叉树。</p>
<p>利用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的深度，我们就可以一边遍历一边判断每个结点是不是平衡的。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(logn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsAVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        System.out.println(isBalanced(node1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字">数组中只出现一次的数字</h3>
<p>要求时间复杂度是 <span class="math inline">\(O(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>思路：</strong></p>
<p>异或运算的一个性质：<strong>任何一个数字异或它自己都等于 0</strong></p>
<p>如果数组里只有一个数字出现 1 次，其它都出现偶数次，那么从头到尾异或数组中的每一个数字，最后将得到那个只出现一次的数字。所以解决问题的关键变成了如何把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其它数字都出现偶数次。</p>
<blockquote>
<p>并不需要额外的辅助空间保存两个子数组，这里只是在逻辑上进行划分而已。</p>
</blockquote>
<ul>
<li>首先，从头到尾依次异或数组中的每一个数字，最终得到的结果就是那两个只出现一次的数字异或的结果。</li>
<li>因为这两个数字肯定不一样，那么异或的结果肯定不为 0，也就是说在这个结果数字的二进制表示中至少有一位为 1。</li>
<li>在结果数字中找到第一个为 1 的位置，记为第 n 位。</li>
<li>接着，以第 n 位是不是 1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 n 位都是 1，第二个子数组中每一个数字的第 n 位都是 0。</li>
</ul>
<blockquote>
<p>由于分组的标准是数字中的某一位是 1 还是 0，那么出现了偶数次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的。</p>
</blockquote>
<p>例如：</p>
<p>假设输入数组 {2,4,3,6,3,2,5,5}，对数组中的每个数字异或运算后得到结果的二进制表示为 0010。</p>
<p>异或得到结果中的倒数第二位是 1，于是我们根据数字的倒数第二位是不是 1 分为两个子数组。</p>
<p>第一个子数组 {2,3,6,3,2} 中所有数字的倒数第二位都是 1；而第二个子数组 {4,5,5} 中所有数字的倒数第二位都是 0。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindNumsAppearOnce</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findFirstBitIsOne</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>) counter++;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBitOne</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> indexBit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt;&gt;&gt; indexBit &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findNumsAppearOnce</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] num1, <span class="type">int</span>[] num2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resExclusiveOr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) resExclusiveOr ^= e;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexBit</span> <span class="operator">=</span> findFirstBitIsOne(resExclusiveOr);</span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBitOne(e, indexBit)) num1[<span class="number">0</span>] ^= e;</span><br><span class="line">            <span class="keyword">else</span> num2[<span class="number">0</span>] ^= e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>], num2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        findNumsAppearOnce(arr, num1, num2);</span><br><span class="line">        System.out.println(<span class="string">&quot;num1=&quot;</span> + num1[<span class="number">0</span>] + <span class="string">&quot; num2=&quot;</span> + num2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的两个数字">和为S的两个数字</h3>
<p><strong>思路：</strong></p>
<p>因为数组有序，所以如果找到的两个数字小于 S，则考虑选择较小数字后面的数字，因为排在后面的数字更大一些，那么两个数字的和也更大一些，就有可能等于 S 了；同样，当两个数字的和大于 S，可以选择较大数字前面的数字，因为排在数组前面的数字要小一些。</p>
<p>以数组 {1,2,4,7,11,15} 及 S=15 为例：</p>
<ul>
<li>首先定义两个指针，第一个指向数组的第一个（也是最小的）数字 1；第二个指向数组的最后一个（也是最大的）数字 15。</li>
<li>这两个数字的和 16 大于 15，因此把第二个指针向前移动一个数字，让它指向 11。</li>
<li>这时两个数字 1 与 11 的和是 12，小于 15，所以把第一个指针向后移动一个数字指向 2。</li>
<li>此时两个数字 2 与 11 的和是 13，还是小于 15，所以再次把第一个指针向后移动一个数字指向 4。</li>
<li>此时数字 4 与 11 的和是 15，正是我们期待的结果。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindNumbersWithSum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findNumbers</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] num1, <span class="type">int</span>[] num2, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">1</span> || num1 == <span class="literal">null</span> || num2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">curSum</span> <span class="operator">=</span> arr[left] + arr[right];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                num1[<span class="number">0</span>] = arr[left];</span><br><span class="line">                num2[<span class="number">0</span>] = arr[right];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; sum) right--;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">findNumbersWithSum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>], num2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (findNumbers(arr, num1, num2, sum)) &#123;</span><br><span class="line">            numsList.add(num1[<span class="number">0</span>]);</span><br><span class="line">            numsList.add(num2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(findNumbersWithSum(arr, <span class="number">15</span>).toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">和为S的连续正数序列</h3>
<p><strong>思路：</strong></p>
<p>考虑用两个数 small 和 big 分别表示序列的最小值和最大值。</p>
<ul>
<li>首先把 small 初始化为 1，big 初始化为 2</li>
<li>如果从 small 到 big 的序列的和大于 S，我们可以从序列中去掉较小的值，也就是增大 small 的值</li>
<li>如果从 small 到 big 的序列的和小于 S，我们可以增大 big，让这个序列包含更多的数字</li>
<li>因为这个序列至少要有两个数字，所以 small 需要一直增加到 S/2 为止</li>
</ul>
<p>以 S=9 为例，求取和为 9 的连续序列的过程：</p>
<table>
<thead>
<tr class="header">
<th>步骤</th>
<th>small</th>
<th>big</th>
<th>序列</th>
<th>序列和</th>
<th>与 S 相比</th>
<th>下一步</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>1,2</td>
<td>3</td>
<td>小于</td>
<td>增加 big</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>3</td>
<td>1,2,3</td>
<td>6</td>
<td>小于</td>
<td>增加 big</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>4</td>
<td>1,2,3,4</td>
<td>10</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>4</td>
<td>2,3,4</td>
<td>9</td>
<td>等于</td>
<td>保存序列，增加 big</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>5</td>
<td>2,3,4,5</td>
<td>14</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="even">
<td>6</td>
<td>3</td>
<td>5</td>
<td>3,4,5</td>
<td>12</td>
<td>大于</td>
<td>增加 small</td>
</tr>
<tr class="odd">
<td>7</td>
<td>4</td>
<td>5</td>
<td>4,5</td>
<td>9</td>
<td>等于</td>
<td>保存序列</td>
</tr>
</tbody>
</table>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindContinuousSequence</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">getSequence</span><span class="params">(<span class="type">int</span> small, <span class="type">int</span> big)</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; sequence = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> small; i &lt;= big; i++) sequence.add(i);</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">findContinuousSequence</span><span class="params">(<span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; sequencesList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">3</span>) <span class="keyword">return</span> sequencesList;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">1</span>, big = <span class="number">2</span>, mid = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> small + big;</span><br><span class="line">        <span class="keyword">while</span> (small &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum)&#123;</span><br><span class="line">                sequencesList.add(getSequence(small, big));</span><br><span class="line">                curSum += (++big);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; sum) curSum -= (small++);</span><br><span class="line">            <span class="keyword">else</span> curSum += (++big);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sequencesList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; sequencesList = findContinuousSequence(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;Integer&gt; e: sequencesList) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(e.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转单词顺序">翻转单词顺序</h3>
<p><strong>思路：</strong></p>
<p>第一步翻转句子中所有的字符。比如翻转 "I am a student." 中所有的字符得到 ".tneduts a ma I"，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。</p>
<p>第二步再翻转每个单词中字符的顺序，就得到了 "student. a am I"。</p>
<p>这种思路的关键在于实现一个函数以翻转字符串中的一段。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseSentence</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left++] = arr[right];</span><br><span class="line">            arr[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseSentence</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                reverse(arr, left, i - <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(arr, left, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(reverseSentence(<span class="string">&quot;I am a student.&quot;</span>));</span><br><span class="line">        System.out.println(reverseSentence(<span class="string">&quot;Wonderful&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋转字符串">左旋转字符串</h3>
<p><strong>思路：</strong></p>
<p>利用三次逆序操作可以实现循环左移：</p>
<ul>
<li>将字符串分成两部分，一部分是需要循环左移（也即移到字符串尾部）的序列，另一部分是剩余的序列</li>
<li>对这两部分序列分别进行逆序操作</li>
<li>对整个字符串进行逆序操作，即得到循环左移的结果</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftRotateString</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left++] = arr[right];</span><br><span class="line">            arr[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">leftRotateString</span><span class="params">(String str, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || n &lt; <span class="number">0</span> || n &gt; str.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">        reverse(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, n, arr.length - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(leftRotateString(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的最大值">6.1.10 队列的最大值</h3>
<p>滑动窗口的最大值</p>
<p><strong>思路：</strong></p>
<p>使用一个双端队列，用来保存有可能是滑动窗口最大值的数字的下标。</p>
<ul>
<li>在存入一个数字的下标之前，首先判断队列里已有数字是否小于待存入的数字。</li>
<li>如果已有的数字小于待存入的数字，那么这些数字已经不可能是滑动窗口的最大值，因此它们将会被依次从队列尾部删除。</li>
<li>同时，如果队列头部的数字已经从窗口里滑出，那么滑出的数字也需要从队列的头部删除。</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxInWindows</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="literal">null</span> || size &lt; <span class="number">1</span> || size &gt; num.length) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; num[i] &gt;= num[deque.peekLast()])</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; num.length; i++)&#123;</span><br><span class="line">            res.add(num[deque.peek()]);</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; num[i] &gt;= num[deque.peekLast()])</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peek() &lt;= (i - size))</span><br><span class="line">                deque.poll();</span><br><span class="line">            deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(num[deque.peek()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象建模能力">抽象建模能力</h2>
<h3 id="n-个骰子的点数">n 个骰子的点数</h3>
<p><strong>思路：</strong></p>
<p>考虑用两个数组来存储骰子点数的每一个总数出现的次数。</p>
<ul>
<li>在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。</li>
<li>在下一循环中，我们加上一个新的骰子，此时和为n的骰子出现的次数等于上一次循环中骰子点数和为 n-1、n-2、n-3、n-4、n-5 与 n-6 的次数的总和</li>
<li>所以我们把另一个数组的第 n 个数字设为前一个数组对应的第 n-1、n-2、n-3、n-4、n-5 与 n-6 个数之和</li>
</ul>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PointsOfNDice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printProbability</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//骰子最大面值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diceMaxVal</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//count[][n]: 点数和为n出现的次数</span></span><br><span class="line">        <span class="type">int</span>[][] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][diceMaxVal * num + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= diceMaxVal; i++) count[flag][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= num; k++) &#123;</span><br><span class="line">            <span class="comment">//有k个骰子时，最小点数和为k，不存在出现点数和小于k的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) count[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt;= diceMaxVal * k; i++) &#123;</span><br><span class="line">                count[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i &amp;&amp; j &lt;= diceMaxVal; j++) &#123;</span><br><span class="line">                    count[<span class="number">1</span> - flag][i] += count[flag][i - j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在下一轮中，交换两个数组，通过改变flag实现</span></span><br><span class="line">            flag = <span class="number">1</span> - flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> Math.pow(diceMaxVal, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i &lt;= diceMaxVal * num; i++) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%d : %.6f&quot;</span>, i, count[flag][i] / total));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PointsOfNDice</span>().printProbability(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扑克牌的顺子">扑克牌的顺子</h3>
<p><strong>思路：</strong></p>
<p>建模：把 5 张牌看成由 5 个数字组成的数组。大、小王定义为 0；A 为 1，J 为 11，Q 为 12，K 为 13。</p>
<ul>
<li>首先把数组排序</li>
<li>然后统计数组中 0 的个数</li>
<li>最后统计排序后的数组中相邻数字之间的空缺总数</li>
</ul>
<p>如果空缺总数小于或者等于 0 的个数，那么这个数组就是连续的；反之则不连续。</p>
<blockquote>
<p>注意：如果数组中的非 0 数字重复出现，则该数组不是连续的。也即如果一副牌里含有对子，则不可能是顺子。</p>
</blockquote>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(nlogn)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsContinuous</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isContinuous</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numOfZero</span> <span class="operator">=</span> <span class="number">0</span>, numOfGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length &amp;&amp; arr[i] == <span class="number">0</span>; i++) numOfZero++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> numOfZero, big = numOfZero + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (big &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[small] == arr[big]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            numOfGap += arr[big] - arr[small] - <span class="number">1</span>;</span><br><span class="line">            small = big++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numOfZero &gt;= numOfGap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(isContinuous(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆圈中最后剩下的数字">圆圈中最后剩下的数字</h3>
<p><strong>思路：</strong></p>
<p>利用递推公式（推导过程详见《剑指Offer》）</p>
<p><span class="math display">\[
f(n,m) = \left\{\begin{aligned}
&amp; 0 &amp;  &amp; {n=1}\\
&amp; (f(n-1,m)+m)\%n &amp; &amp; {n \gt 1}
\end{aligned}\right.
\]</span></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastRemaining</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            last = (last + m) % i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(lastRemaining(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发散思维能力">发散思维能力</h2>
<h3 id="求-12...n">求 1+2+...+n</h3>
<p><strong>思路：</strong></p>
<p>利用短路与的特性实现递归终止</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneToNSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumSolution</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += sumSolution(n-<span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(sumSolution(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不用加减乘除做加法">不用加减乘除做加法</h3>
<p><strong>思路：</strong></p>
<p>分析 5+17=22，实际上可以分成三步进行：</p>
<ul>
<li>第一步只做各位相加不进位，此时相加结果是 12（个位 5 和 7 相加不进位是 2，十位 0 和 1 相加不进位是 1 ）</li>
<li>第二步做进位，5+7 中有进位，进位值是 10</li>
<li>第三步把前面两个结果加起来，12+10=22，刚好为 5+17 的结果</li>
</ul>
<p>这样的策略同样适用于二进制，所以可以了利用二进制的移位实现加法，具体的做法就是对二进制数进行以上三步操作，直至不产生进位（也即进位值等于 0 ），此时第一步的结果就是最终的结果。</p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum, carry;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span> (num2 != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">构建乘积数组</h3>
<p><strong>思路：</strong></p>
<p>B[i] 的值可以看作如下矩阵中每行的乘积。先算下三角乘积，再算上三角乘积。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/79529c6a002030ccb5807c770f1b330d.png" alt="create-product-array" /></p>
<p><strong>时间复杂度：</strong> <span class="math inline">\(O(n)\)</span></p>
<p>额外空间复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p><strong>参考实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateProductArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] multiply(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            tmp *= arr[i+<span class="number">1</span>];</span><br><span class="line">            res[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(multiply(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04 安装shadowsocks</title>
    <url>/posts/eed37a90/</url>
    <content><![CDATA[<p>本文将简要介绍 shadowsocks 的基本原理，并详细说明如何在 Ubuntu 18.04 下安装使用 shadowsocks 客户端，同时提供了让系统使用 PAC 模式或全局模式的配置方法。</p>
<span id="more"></span>
<h1 id="ubuntu-18.04-安装-shadowsocks">Ubuntu 18.04 安装 shadowsocks</h1>
<p><strong>本文使用的是 shadowsocks 的 python 实现版本，没有 GUI，此外只涉及客户端配置，服务端可参考 <a href="https://github.com/shadowsocks/shadowsocks/blob/master/README.md">官方文档</a></strong></p>
<p><strong>Github 主页：<a href="https://github.com/shadowsocks/shadowsocks">shadowsocks</a></strong></p>
<p><strong>官网：<a href="https://shadowsocks.org/en/index.html">https://shadowsocks.org/en/index.html</a></strong></p>
<h1 id="使用-shadowsocks-的前提">使用 shadowsocks 的前提</h1>
<ul>
<li>一台在防火墙之外的服务器</li>
<li>墙内主机需要安装 shadowsocks 本地端</li>
<li>墙外服务器需要安装 shadowsocks 服务端</li>
</ul>
<h1 id="shadowsocks-基本原理">shadowsocks 基本原理</h1>
<p>Shadowsocks 是一个基于 <a href="https://tools.ietf.org/html/rfc1928">SOCKS5</a> 的安全拆分代理，由两部分组成，客户端和服务端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client &lt;---&gt; ss-local &lt;--[encrypted]--&gt; ss-remote &lt;---&gt; target</span><br></pre></td></tr></table></figure>
<p>Shadowsocks 本地组件（ss-local）就像传统的 SOCKS5 服务器，为客户端提供代理服务。它将数据流和数据包从客户端加密并转发到 Shadowsocks 远程组件（ss-remote），后者解密并转发到目标。来自目标的回复同样被加密并由 ss-remote 中继回 ss-local，后者解密并最终返回到原始客户端。</p>
<h1 id="安装-shadowsocks">安装 shadowsocks</h1>
<p>使用的是阿里的镜像源，执行安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br></pre></td></tr></table></figure>
<h1 id="查看版本号">查看版本号</h1>
<p>执行以下命令查看 shadowsocks 的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sslocal --version</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/625e5581421c3b9c67e88f3eb2f99b3a.png" alt="sslocal-version" /></p>
<h1 id="配置-shadowsocks-客户端">配置 shadowsocks 客户端</h1>
<p><a href="https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File">Configuration via Config File</a> 通过配置文件进行配置</p>
<p>修改 <code>/etc/shadowsocks/config.json</code> 配置（客户端配置），例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;my_server_ip&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;mypassword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>server</td>
<td>the address your server listens 服务端IP</td>
</tr>
<tr class="even">
<td>server_port</td>
<td>server port 服务端端口</td>
</tr>
<tr class="odd">
<td>local_address</td>
<td>the address your local listens 本地代理监听地址</td>
</tr>
<tr class="even">
<td>local_port</td>
<td>local port 本地代理监听端口</td>
</tr>
<tr class="odd">
<td>password</td>
<td>password used for encryption 服务端设置的密码</td>
</tr>
<tr class="even">
<td>timeout</td>
<td>in seconds 超时设置 与服务端保持一致</td>
</tr>
<tr class="odd">
<td>method</td>
<td>default: "aes-256-cfb", see <a href="https://github.com/shadowsocks/shadowsocks/wiki/Encryption">Encryption</a> 加密算法， 与服务端保持一致</td>
</tr>
<tr class="even">
<td>fast_open</td>
<td>use <a href="https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open">TCP_FASTOPEN</a>, true / false</td>
</tr>
<tr class="odd">
<td>workers</td>
<td>number of workers, available on Unix/Linux</td>
</tr>
</tbody>
</table>
<h1 id="运行">运行</h1>
<h2 id="前台运行">前台运行</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<h2 id="后台运行">后台运行</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json -d start</span><br><span class="line">sslocal -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>
<p>是否使用 sudo 权限根据具体情况而定</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2b6d687c30da2cde582e2581e6163dc7.png" alt="run-ss" /></p>
<h1 id="shadowsocks-代理模式">shadowsocks 代理模式</h1>
<p>启动后还不能直接翻墙，因为上面只是启动了代理服务器，但是网络请求并没有经过代理服务器，所以还需要配置代理服务，代理服务可分为部分代理和全局代理。</p>
<p><strong>特别说明：这里所说的是 shadowsocks 的 PAC 模式和全局模式，另外 shadowsocks 的全局模式并不是整个系统所有软件都进行代理，而只是针对所有浏览器进行的全局代理。</strong></p>
<ul>
<li><p>PAC 模式</p>
<p>PAC 也即代理自动配置 Proxy auto-config，是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/994002fab11c19f4ce43aac8faf9231a.png" alt="PAC-mode" /></p>
<p>PAC 模式会在连接网站的时候读取 PAC 文件的规则，来确定所访问的网站有没有被墙，如果被墙了或者符合规则，那就会使用代理服务器连接网站，而 PAC 列表一般都是从 GFWList 更新的。GFWList 定期会更新被墙的网站，不过一般比较慢。</p></li>
<li><p>全局模式</p>
<p>Shadowsocks 的全局模式，是设置系统的代理服务器，使所有的 Http Proxy/Socks5 请求都由代理服务器转发。</p></li>
<li><p>区别</p>
<p>简单地说，在全局模式下，所有网站默认走代理。而 PAC 模式是只有被墙的才会走代理，推荐使用 PAC 模式，如果 PAC 模式无法访问一些网站，就换全局模式试试，一般是因为 PAC 更新不及时（也就是 GFWList 更新不及时）导致的。</p></li>
</ul>
<h1 id="配置-ubuntu-使用-pac-模式">配置 Ubuntu 使用 PAC 模式</h1>
<p>配置 PAC 模式需要 pac 文件，这个 pac 文件可以自己编写也可以用工具生成，这里直接使用工具 GenPAC 来生成。</p>
<p><strong>Github 主页: <a href="https://github.com/JinnLynn/GenPAC">GenPAC</a></strong></p>
<p>GenPAC：基于 gfwlist 的多种代理软件配置文件生成工具，支持自定义规则，目前可生成的格式有 pac, dnsmasq, wingy</p>
<ol type="1">
<li>安装 GenPAC</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install genpac</span><br><span class="line">sudo pip install --upgrade genpac</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>生成 autoproxy.pac</li>
</ol>
<p>进入终端，cd 到你希望存放配置文件的目录，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/wylu/.config/GenPAC</span><br></pre></td></tr></table></figure>
<p>执行以下命令生成 pac 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo genpac --pac-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</span><br></pre></td></tr></table></figure>
<p>关于命令参数说明，详见官方文档 <a href="https://github.com/JinnLynn/GenPAC">GenPAC</a></p>
<ol start="3" type="1">
<li>设置系统网络代理</li>
</ol>
<p>进入设置：Settings –&gt; Network –&gt; Network Proxy</p>
<p>方法选择 <code>Automatic</code></p>
<p>Configuration URL 填写刚刚生成的 pac 文件路径 <code>/home/wylu/.config/GenPAC/autoproxy.pac</code></p>
<ol start="4" type="1">
<li>测试</li>
</ol>
<p>浏览器访问 Google 验证代理是否配置成功</p>
<blockquote>
<p>一般的浏览器都是默认使用系统代理，所以这里只配置了系统代理，如果浏览器没有走 Socks5 代理服务器，需要自行设置浏览器的代理</p>
</blockquote>
<ol start="5" type="1">
<li>关于 privoxy</li>
</ol>
<p>以上只是针对浏览器的代理，而使用 privoxy 代理能把电脑上所有 http 请求都转发给 ss，这意味着在终端下也能使用 wget、curl 等命令访问墙外资源。</p>
<p>关于 privoxy 的安装和使用可以参考：</p>
<p><a href="https://www.jianshu.com/p/41378f4e14bc">https://www.jianshu.com/p/41378f4e14bc</a></p>
<p>https://www.jianshu.com/p/e0b05cb7cd50</p>
<p>配置手动代理可以参考：</p>
<p><a href="https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-configure-proxy-on-ubuntu-18-04/">https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-configure-proxy-on-ubuntu-18-04/</a></p>
<blockquote>
<p>shell 终端里执行的命令，发起的网络请求现在还不支持 socks5 代理，只支持 http/https 代理。使用 privoxy 代理，可以将 shell 发起的网络请求转发给 shadowsocks</p>
</blockquote>
<h1 id="autoproxy.pac-文件分析">autoproxy.pac 文件分析</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="string">&#x27;SOCKS5 127.0.0.1:1080&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> rules = [</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于添加自定义规则</span></span><br><span class="line"><span class="comment">    分析以下的js代码，可以知道rules元素，越靠前的优先级越高；</span></span><br><span class="line"><span class="comment">    即如果在rules[0]中匹配成功，则不再匹配，直接返回选择&quot;直连&quot;或者&quot;走代理&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    [</span><br><span class="line">        [],</span><br><span class="line">        []</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以rules[1]为例进行分析，其它类似；</span></span><br><span class="line"><span class="comment">        同样，在rules[1]中的元素也是越靠前的优先级越高；</span></span><br><span class="line"><span class="comment">        如果在rules[1][0]中匹配成功，则不再匹配，直接返回；</span></span><br><span class="line"><span class="comment">        分析代码可知，当匹配成功时：</span></span><br><span class="line"><span class="comment">            --如果该元素的索引为偶数，则返回字面值&#x27;DIRECT&#x27;，即选择直连</span></span><br><span class="line"><span class="comment">            --如果该元素的索引为奇数，则返回proxy变量的值，即选择使用代理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        [],</span><br><span class="line">        []</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以上规则如果没有一个匹配成功，根据代码分析，最终将返回字面值&#x27;DIRECT&#x27;，</span></span><br><span class="line"><span class="comment">    也就是选择直连；这也意味着如果某些URL被墙，而又没有加入到pac规则中，</span></span><br><span class="line"><span class="comment">    最终会以直连的方式访问，因为被墙所以肯定是访问不到的, 这时应该使用全局模式，</span></span><br><span class="line"><span class="comment">    或者在pac中添加规则。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastRule = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FindProxyForURL</span>(<span class="params">url, host</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    个人认为，如果这里直接返回proxy，应该就等同于全局模式了，</span></span><br><span class="line"><span class="comment">    此时，不管是什么URL，都会走代理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rules.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        ret = <span class="title function_">testHost</span>(host, i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">undefined</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;DIRECT&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testHost</span>(<span class="params">host, index</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rules[index].<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; rules[index][i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            lastRule = rules[index][i][j];</span><br><span class="line">            <span class="keyword">if</span> (host == lastRule || host.<span class="title function_">endsWith</span>(<span class="string">&#x27;.&#x27;</span> + lastRule))</span><br><span class="line">                <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&#x27;DIRECT&#x27;</span> : proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastRule = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// REF: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">endsWith</span>) &#123;</span><br><span class="line">    <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">endsWith</span> = <span class="keyword">function</span>(<span class="params">searchString, position</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> subjectString = <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> position !== <span class="string">&#x27;number&#x27;</span> || !<span class="built_in">isFinite</span>(position) || <span class="title class_">Math</span>.<span class="title function_">floor</span>(position) !== position || position &gt; subjectString.<span class="property">length</span>) &#123;</span><br><span class="line">            position = subjectString.<span class="property">length</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        position -= searchString.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">var</span> lastIndex = subjectString.<span class="title function_">indexOf</span>(searchString, position);</span><br><span class="line">        <span class="keyword">return</span> lastIndex !== -<span class="number">1</span> &amp;&amp; lastIndex === position;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解 pac 文件 rules 的含义后，就可以自行添加一些规则了。比如 PAC 模式下访问不了 Jetbrains 的插件网址 <a href="https://plugins.jetbrains.com">https://plugins.jetbrains.com</a>，因为在该 pac 文件中并没有与此 URL 匹配的规则，所以最后会以直连的方式访问，但是该网址已被墙，最终是无法访问的，我们可以把该域名添加到 pac 文件的规则列表中，该规则列表应是一个使用代理的列表，在添加规则后会以走代理的方式访问 Jetbrains 的插件网址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6cda56daa540d379099a4c6b28bda0dc.png" alt="pac-file-rules" /></p>
<h1 id="配置-ubuntu-使用-global-模式">配置 Ubuntu 使用 Global 模式</h1>
<p>要实现 Global 模式，需要使用 privoxy，并且配置系统网络代理使用手动模式。</p>
<p>privoxy 能够实现不同代理之间的切换，使用它可以作为 SOCKS 代理和 HTTP、HTTPS 代理连接的桥梁，它能把所有的 http 请求（包括终端执行的命令，浏览器）转发给 shadowsocks，它就像是一个适配器，将 SOCKS 代理转为 HTTP 代理。</p>
<h2 id="安装配置-privoxy">安装配置 privoxy</h2>
<ol type="1">
<li>安装 privoxy</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install privoxy</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>配置 privoxy</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/privoxy/config</span><br></pre></td></tr></table></figure>
<p>找到 <code>#listen-address 127.0.0.1:8118</code>，取消注释，表示 privoxy 监听本机 8118 端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/408146fc6608e6dce9c6ab0e0f93cc3d.png" alt="privoxy-listen-address" /></p>
<p>找到 <code>#forward-socks5t / 127.0.0.1:9050 .</code>，在下方添加一行 <code>forward-socks5t / 127.0.0.1:1080 .</code>，表示转发请求到本地 1080 端口，而 1080 端口是 shadowsocks 监听的端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d36888e22f52557eaf8ec7755dd791f3.png" alt="privoxy-forward-socks5t" /></p>
<ol start="3" type="1">
<li>修改完后，重启 privoxy</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart privoxy</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>配置请求转发</li>
</ol>
<p>在 <code>~/.bashrc</code> 中添加如下内容，如果使用的是 zsh，则在 <code>~/.zshrc</code> 中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> proxy</span></span><br><span class="line">export http_proxy=&quot;127.0.0.1:8118&quot;</span><br><span class="line">export https_proxy=&quot;127.0.0.1:8118&quot;</span><br><span class="line">export ftp_proxy=&quot;127.0.0.1:8118&quot;</span><br></pre></td></tr></table></figure>
<p>不建议在 shell 的配置文件下设置代理，这种方式下所有的 shell 命令都会走代理，如果你突然不想终端命令走代理，那么又需要修改配置文件，注释掉代理相关配置，反复修改配置文件是一件挺麻烦的事。推荐使用下面"配置系统网络代理"的方式，该配置手动模式下就能使终端命令走代理，不需要配置 <code>.bashrc</code> 或 <code>.zshrc</code>，当禁用系统网络代理时，终端命令就不会走代理了。</p>
<ol start="5" type="1">
<li>测试</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1f1835b407e30a88de5ee111ac3dc678.png" alt="Global-mode-shell-test" /></p>
<h2 id="配置系统网络代理">配置系统网络代理</h2>
<p>配置完 privoxy 后，终端发起的网络请求也能走 SOCKS5 代理了，但浏览器要使用全局模式还需要配置系统网络代理。</p>
<p>默认浏览器默认使用系统代理，所以只需配置系统网络代理即可，具体配置过程如下：</p>
<ol type="1">
<li><p>进入设置：Settings –&gt; Network –&gt; Network Proxy</p></li>
<li><p>方法选择 <code>Manual</code></p></li>
<li><p>设置 HTTP、HTTPS 请求由 privoxy 来代理</p></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f72a6e75403d80030e402e44c9f5e05d.png" alt="manual-mode-setting" /></p>
<ol start="4" type="1">
<li>Pac 和 Global 模式切换</li>
</ol>
<p>系统网络代理的自动 (Automatic) 模式和手动 (Manual) 模式都配置完成后，当选用 Automatic 则使用 Pac 模式，当选用 Manual 则使用 Global 模式。</p>
<h1 id="references">References</h1>
<p><a href="https://shadowsocks.org/en/spec/Protocol.html">https://shadowsocks.org/en/spec/Protocol.html</a></p>
<p><a href="https://github.com/shadowsocks/shadowsocks">https://github.com/shadowsocks/shadowsocks</a></p>
<p><a href="https://github.com/JinnLynn/GenPAC">https://github.com/JinnLynn/GenPAC</a></p>
<p><a href="https://segmentfault.com/a/1190000011862912">https://segmentfault.com/a/1190000011862912</a></p>
<p><a href="https://www.jianshu.com/p/e0b05cb7cd50">https://www.jianshu.com/p/e0b05cb7cd50</a></p>
<p><a href="https://www.cnblogs.com/edward2013/p/5560836.html">https://www.cnblogs.com/edward2013/p/5560836.html</a></p>
<p><a href="https://lollogit.gitbooks.io/help/">https://lollogit.gitbooks.io/help/</a></p>
<p><a href="https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-configure-proxy-on-ubuntu-18-04/">https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-configure-proxy-on-ubuntu-18-04/</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04 字体显示异常</title>
    <url>/posts/202f8f32/</url>
    <content><![CDATA[<p>解决 Ubuntu 18.04 下字体显示异常的问题。</p>
<span id="more"></span>
<h1 id="异常现象">异常现象</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/290ce13e68e1294dfc0f49a89eefe329.png" alt="abnormal-font-display-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/005a86fab18b859ea931659c2ea13008.png" alt="abnormal-font-display-2" /></p>
<h1 id="原因分析">原因分析</h1>
<p>当系统使用的是英文环境时，Ubuntu 默认采用的字体 Noto Sans CJK 优先显示日文汉字，这一问题可以通过修改配置文件 <code>/etc/fonts/conf.avail/64-language-selector-prefer.conf</code> 来修复。</p>
<h1 id="解决方法">解决方法</h1>
<p><code>64-language-selector-prefer.conf</code> 原文件内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>JP &lt;---&gt;日文</code></li>
<li><code>KR &lt;---&gt; 韩文</code></li>
<li><code>SC &lt;---&gt; 简体中文</code></li>
<li><code>TC &lt;---&gt; 繁体中文</code></li>
</ul>
<p>修改上面的文件，将顺序改成 <code>SC TC JP KR</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK KR<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<h1 id="references">References</h1>
<p><a href="http://forum.ubuntu.org.cn/viewtopic.php?p=3160613#p3160613">http://forum.ubuntu.org.cn/viewtopic.php?p=3160613#p3160613</a></p>
<p><a href="https://blog.csdn.net/szsteel1/article/details/55540740">https://blog.csdn.net/szsteel1/article/details/55540740</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ubuntu蓝牙搜索不到附近设备的问题</title>
    <url>/posts/28215e24/</url>
    <content><![CDATA[<p>针对 Ubuntu 蓝牙搜索不到附近设备的问题，本文通过分析发现是因为缺失 BCM.hcd 文件导致的，然后给出了相应的解决方案。</p>
<span id="more"></span>
<h1 id="出现的问题">出现的问题</h1>
<p>打开蓝牙搜索设备无果</p>
<h1 id="原因分析">原因分析</h1>
<p>终端下输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep -i blue</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e8164dd366a2c2ad1ad79fe632fd41d0.png" alt="BCM-not-found" /></p>
<p><code>BCM: Patch brcm/BCM.hcd not found</code> 提示缺少 BCM.hcd文件</p>
<h1 id="解决步骤">解决步骤</h1>
<p><strong>实测该解决方法适用于 Ubuntu 16.04 和 18.04，其它版本未测试。</strong></p>
<ul>
<li><p>安装相关软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bluez*</span><br></pre></td></tr></table></figure></li>
<li><p>输入 <code>lsusb</code> 查看蓝牙设备信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c4ae780183a0bf07d8272348725a1a0.png" alt="lsusb-bluetooth-device-info" /></p></li>
<li><p>搜索并下载相应 cab 包</p>
<p><a href="https://github.com/winterheart/broadcom-bt-firmware">https://github.com/winterheart/broadcom-bt-firmware</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6696e105d9dc2b284a70632e424177d4.png" alt="download-cab-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c6c7c382ea21e2a0d5eb4d56b62cc55b.png" alt="download-cab-2" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5760525c3d24c459dea947e604e89316.png" alt="download-cab-3" /></p>
<p>也可以用命令进行下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.windowsupdate.com/d/msdownload/update/driver/drvs/2015/10/200006644_5f769d5f45e68840195d3bb24ef9d1ae2c791272.cab</span><br></pre></td></tr></table></figure></li>
<li><p>安装 cab 解压工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install cabextract</span><br></pre></td></tr></table></figure></li>
<li><p>解压下载好的 cab 包</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/09d9808401f7560f575e429cb652bfb8.png" alt="cabextract" /></p>
<p>解压后文件有很多，需要根据具体情况选择，我的固件是 <code>BCM43142A0</code>，这里我选了 <code>BCM43142A0_001.001.011.0311.0327.hex</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b3539795e3b7eceeb7964030f918b9b1.png" alt="select-hex-file" /></p>
<p>这里我用了 <code>0311.0327.hex</code> 这个文件，是因为这个文件名和我的电脑在 windows 下用到的一致，实际上直接拿 ｗindwos 下的也可以。</p>
<blockquote>
<p>可以在自己电脑 windows 里面的 <code>C:Windows/System32/drivers</code> 文件夹下搜索 <code>.hex</code> 文件，然后放到 Ubuntu 下面编译成 <code>.hcd</code> 文件。</p>
</blockquote></li>
<li><p>选择正确的 hex 文件</p>
<p>上面通过 Windows 查看以确定需要的 hex 文件的方法比较麻烦，这里介绍另一种选择 hex 文件的方法。</p>
<p><a href="https://askubuntu.com/questions/632336/bluetooth-broadcom-43142-isnt-working/632348#632348">https://askubuntu.com/questions/632336/bluetooth-broadcom-43142-isnt-working/632348#632348</a></p>
<p>在解压 cab 包之后，会有一堆的 hex 文件和其它的一些文件，其中有一个文件 <code>bcbtums.inf</code> 是我们要用到的。在 <code>bcbtums.inf</code> 文件中搜索 <code>RAMUSB21D7.CopyList</code>，你将会看到你所需要的 hex 文件，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0c6a7df5440f8093d05989d132fbe81a.png" alt="another-way-to-select-hex-file" /></p>
<blockquote>
<p>INF 是 Device INFormation File 的英文缩写，是 Microsoft 公司为硬件设备制造商发布其驱动程序推出的一种文件格式，INF 文件中包含硬件设备的信息或脚本以控制硬件操作。在 INF 文件中指明了硬件驱动该如何安装到系统中，源文件在哪里、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息等等。 安装监视器、调制解调器和打印机等设备所需的驱动程序，都是通过 INF 文件，正是 INF 的功劳才使得 Windows 可以找到这些硬件设备的驱动并正确安装。</p>
</blockquote></li>
<li><p>下载hex2hcd</p>
<p>有了对应固件的 hex 文件后，需要将该 hex 文件转成 hcd 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jessesung/hex2hcd.git</span><br></pre></td></tr></table></figure>
<p>编译生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hex2hcd</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li><p>将 hex 文件转成 xxx.hcd</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0bbe56b5fff0a09eb7a9f053749f7c95.png" alt="hex2hcd" /></p>
<p>放到 firmware 文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv BCM43142A0_001.001.011.0311.0327.hcd /lib/firmware/brcm/BCM.hcd</span><br></pre></td></tr></table></figure>
<p>这里因为缺少BCM.hcd，所以命名为BCM.hcd</p></li>
<li><p>重新加载模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe -r btusb</span><br><span class="line">sudo modprobe btusb</span><br></pre></td></tr></table></figure>
<p>然后就可以在蓝牙的设置里搜索到其他设备了。</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2f1cac103fb0462993f484257b39540e.png" alt="bluetooth-solved-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/22cbdd13ca5a2fc590bedc3791763898.png" alt="bluetooth-solved-2" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/480c06ed7c2b199c8d3f42105d292283.png" alt="bluetooth-solved-3" /></p>
<h1 id="references">References</h1>
<p><a href="https://github.com/winterheart/broadcom-bt-firmware">https://github.com/winterheart/broadcom-bt-firmware</a></p>
<p><a href="https://reasonw.github.io/blog/2017/02/13/Ubuntu-Bluetooth/">https://reasonw.github.io/blog/2017/02/13/Ubuntu-Bluetooth/</a></p>
<p><a href="https://askubuntu.com/questions/632336/bluetooth-broadcom-43142-isnt-working/632348#632348">https://askubuntu.com/questions/632336/bluetooth-broadcom-43142-isnt-working/632348#632348</a></p>
]]></content>
      <categories>
        <category>os</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation安装Arch Linux和Deepin桌面</title>
    <url>/posts/c94241eb/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/48e3e7b5c9c0a0dce7d94db6754789e7.png" alt="Arch Linux" /></p>
<p><a href="https://wiki.archlinux.org/index.php/Arch_Linux">Arch Linux</a> 是通用 x86-64 GNU/Linux 发行版。Arch采用滚动升级模式，尽全力提供最新的稳定版软件。初始安装的 Arch 只是一个基本系统，随后用户可以根据自己的喜好安装需要的软件并配置成符合自己理想的系统。</p>
<span id="more"></span>
<h1 id="安装条件">安装条件</h1>
<p>安装 Arch Linux，需要拥有一台 x64_86 兼容的 PC，其中至少有 512MB 的 RAM 和 800 MB 的可用磁盘空间。由于安装过程中需要从远程存储库获取软件包，所以还需要一个良好的网络连接。</p>
<h1 id="安装-vmware-workstation-pro">安装 VMware Workstation Pro</h1>
<p>到官网下载并安装 <a href="https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0">VMware Workstation Pro</a> 。</p>
<h1 id="下载-arch-linux-镜像">下载 Arch Linux 镜像</h1>
<p>进入 <a href="https://www.archlinux.org/download/">Arch Linux</a> 下载页面，然后选择一个镜像源，例如我选择了 China 的 163.com , 点击下载后缀为 <code>.iso</code> 的镜像文件。</p>
<h1 id="创建虚拟机">创建虚拟机</h1>
<p>创建新的虚拟机 -&gt; 典型 -&gt; 下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e2af09a02205187e0aa08e85c608ccb7.png" alt="create-vm-1" /></p>
<p>选择刚刚下载的 Arch Linux iso 文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/82235424fa8acd26bf7468ec36daf6e5.png" alt="create-vm-2" /></p>
<p>选择 Linux 操作系统，选择 "其他 Linux 4.x 或更高版本内核 64 位" 内核版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9b0ee22f41f6ca6a984951c1995e8e18.png" alt="create-vm-3" /></p>
<p>设置虚拟机名称，并选择虚拟机系统文件保存路径，根据实际情况设定</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2bd6dc2161181aaa1a4888fd16d1fafd.png" alt="create-vm-4" /></p>
<p>设置磁盘空间大小，这里以 20G 为例，同时选择将磁盘存储为单个文件（为了提高性能）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/44969065973fd37f59305f18224ae6c3.png" alt="create-vm-5" /></p>
<p>点击自定义硬件</p>
<p>内存、处理器视具体情况自行设置，移除打印机，<strong>设置网络适配器为 NAT</strong> （网络连接使用 NAT 模式，开机后就能联网），设置完成后点击关闭</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0cb365645cd91e3083e28bcb4610db4e.png" alt="create-vm-6" /></p>
<blockquote>
<p>Host-only: 虚拟机的网卡会连接到物理机的 VMnet1 上，但物理机并不会为虚拟机提供任何路由服务，因此虚拟机只能和物理机进行通信，不能连接到实际的网络上，即无法上网。</p>
<p>NAT: 网络地址转换（Network Address Translation）模式下，虚拟机的网卡连接到物理机的 VMnet8 上，此时物理机系统的 VMWare NAT Server 服务就充当了路由器，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。这种模式最简单，虚拟机系统不用做任何网络设置就可以访问外部网络。</p>
<p>Bridged: 桥接模式下，虚拟机拥有与物理主机相同网段的独立 IP，就像是局域网中的一台独立的主机，与物理机平等的存在于网络中。</p>
</blockquote>
<p>取消勾选创建完成后自动启动虚拟机</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/19f85b0247f8baa6d011894e43a67d80.png" alt="create-vm-7" /></p>
<p><strong>本文以 UEFI 启动模式 + GPT 分区方案 为例</strong>，因为 VMware Workstation Pro 默认是使用 BISO 启动模式的，所以我们要设置成 UEFI，选择 编辑虚拟机设置 -&gt; 选项 -&gt; 高级 -&gt; UEFI -&gt; 保存</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/14d14c230966607271e6d2d58558dd36.png" alt="create-vm-8" /></p>
<p>创建完成，启动虚拟机。</p>
<h1 id="安装前的准备">安装前的准备</h1>
<p><a href="https://wiki.archlinux.org/index.php/Installation_guide">官方安装指南</a></p>
<p>启动虚拟机，如果出现需要选择启动的界面，则选择 "Boot Arch Linux (x86_64)" 并回车，进入命令行界面。</p>
<h2 id="验证启动模式">验证启动模式</h2>
<p>验证是否使用 UEFI 启动，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure>
<p>如果目录不存在，系统可能以 BIOS 或 CSM 模式启动，需要设置虚拟机使用 UEFI （参考上面），本文以 <strong>UEFI + GPT</strong> 为例，所以需要确保虚拟机使用 UEFI 启动。</p>
<p>如果能看到命令输出了该目录下的文件信息，说明是使用 UEFI 启动的。</p>
<h2 id="检查网络连接">检查网络连接</h2>
<p>用 ping 命令检查网络连接，确保系统能够正常访问网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com -c 4</span><br></pre></td></tr></table></figure>
<h2 id="更新系统时间">更新系统时间</h2>
<p>使用 <a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/timedatectl.1">timedatectl</a> 启用 ntp，确保系统时间是准确的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>timedatectl status</code> 检查服务状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure>
<h2 id="创建分区表">创建分区表</h2>
<p>首先使用 <code>lsblk</code> 或者 <code>fdisk -l</code> 查看硬盘的名称，磁盘若被系统识别到，就会被分配为一个 <a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F#.E5.91.BD.E5.90.8D.E7.BA.A6.E5.AE.9A">块设备</a>，如 /dev/sda</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<p>结果中以 <code>rom</code>，<code>loop</code> 或者 <code>airoot</code> 结束的可以忽略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7dac861f4e0108bf32f005a777ea3f9a.png" alt="lsblk-fdisk" /></p>
<p>可以看到我的硬盘设备文件名称为 <code>sda</code>，它存放在 /dev 目录下，现在使用 <a href="https://wiki.archlinux.org/index.php/Parted">parted</a> 命令为这块硬盘创建分区表，指定分区格式为 GPT :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">parted /dev/sda mklabel gpt</span><br></pre></td></tr></table></figure>
<p><strong>注意： parted 命令后的设备路径名称，根据实际情况而定。</strong></p>
<h2 id="建立硬盘分区">建立硬盘分区</h2>
<p>本文使用的分区方案如下：</p>
<ul>
<li>EFI 系统分区: 256MB，UEFI 引导必需</li>
<li>Root 分区: 8GB，根分区</li>
<li>Home 分区: 10GB，家目录分区</li>
<li>Swap 分区: 剩余空间，交换空间</li>
</ul>
<p>使用具有伪图形界面的 cfdisk 工具建立硬盘分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/762f351d534b44178e894cc99b08a460.png" alt="cfdisk" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device        Start       End   Sectors  Size Type</span><br><span class="line">/dev/sda1      2048    526335    524288  256M EFI System</span><br><span class="line">/dev/sda2    526336  17303551  16777216    8G Linux filesystem</span><br><span class="line">/dev/sda3  17303552  38275071  20971520  256M Linux filesystem</span><br><span class="line">/dev/sda4  38275072  41943006   3667935  256M Linux swap</span><br></pre></td></tr></table></figure>
<p>创建分区后，需要将 <code>/dev/sda1</code> 的 <code>Type</code> 设置为 <code>EFI System</code>；将 <code>/dev/sda4</code> 的 <code>Type</code> 设置为 <code>Linux swap</code>；根据实际情况设置。然后将光标移动到 <code>Write</code> 回车，输入 "yes" 并回车以保存修改，将光标移动到 <code>Quit</code> 退出。</p>
<p>此时可以使用 <code>lsblk</code> 命令查看一下分区情况。</p>
<h2 id="格式化分区">格式化分区</h2>
<p>当分区建立好了，这些分区都需要使用适当的文件系统进行格式化。<a href="https://wiki.archlinux.org/index.php/EFI_system_partition">EFI 系统分区</a> 需要格式化成 FAT32 格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda2</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">mkswap /dev/sda3</span><br><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5da233fafad9c3bf4ba10610c5119efb.png" alt="mkfs-partition" /></p>
<h2 id="挂载分区">挂载分区</h2>
<p>格式化完成之后，将分区挂载到 <code>/mnt</code>，先挂载根分区，然后再挂载 EFI 分区、Home 分区（挂载前建议使用 <code>lsblk</code> 命令查看一下设备分区名称，以确认分区路径）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br><span class="line">mkdir /mnt/home</span><br><span class="line">mount /dev/sda3 /mnt/home</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cd7d091ac1713254ecb60c6320a921eb.png" alt="mount-partiton" /></p>
<h1 id="安装-arch-linux">安装 Arch Linux</h1>
<h2 id="选择镜像">选择镜像</h2>
<p>文件 <code>/etc/pacman.d/mirrorlist</code> 定义了软件包会从哪个 镜像源 下载。在列表中越靠前的镜像在下载软件包时有越高的优先权。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<p>使用 vim 修改文件 <code>/etc/pacman.d/mirrorlist</code>，查找到 ustc 的镜像源（使用国内源，速度快），将其剪切并粘贴到文件首部，保存退出。这个文件接下来还会被 pacstrap 拷贝到新系统里，所以请确保设置正确。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/002301b73fb73403a8561a5961d3fb25.png" alt="repo-mirrorlist" /></p>
<h2 id="安装基本系统">安装基本系统</h2>
<p>此处必须联网，安装速度视具体网速和硬件情况定。</p>
<p>使用 <a href="https://git.archlinux.org/arch-install-scripts.git/tree/pacstrap.in">pacstrap</a> 脚本，安装 <a href="https://www.archlinux.org/groups/x86_64/base/">base</a> 组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base</span><br></pre></td></tr></table></figure>
<p>安装 <a href="https://www.archlinux.org/groups/x86_64/base-devel/">base-devel</a> 包中的常用工具和 vim：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base-devel vim</span><br></pre></td></tr></table></figure>
<h2 id="配置系统">配置系统</h2>
<h3 id="fstab">Fstab</h3>
<p>执行下列命令生成 <a href="https://wiki.archlinux.org/index.php/Fstab">fstab</a> 文件 (用 <code>-U</code> 或 <code>-L</code> 选项设置 UUID 或卷标)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<p>在执行完命令后后检查一下生成的 /mnt/etc/fstab 文件是否正确：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4767eed9bddeb945829929c25bb9e15e.png" alt="genfstab-and-check" /></p>
<h3 id="chroot">Chroot</h3>
<p>切换到新安装的系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure>
<h3 id="时区">时区</h3>
<p>设置时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>
<p>使用 hwclock 设置硬件时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>
<h3 id="本地化">本地化</h3>
<p>本地化的程序与库若要本地化文本，都依赖 Locale，后者明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准等等。在下面两个文件设置：locale.gen 与 locale.conf。</p>
<p>编辑 <code>/etc/locale.gen</code> 文件，移除 <code>en_US.UTF-8 UTF-8</code> 对应行前面的注释符号 <code>＃</code>，保存退出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
<p>接着执行 locale-gen 以生成指定的本地化文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<p>创建 locale.conf 并编辑 LANG 变量:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;LANG=en_US.UTF-8&quot; &gt;&gt; /etc/locale.conf</span><br></pre></td></tr></table></figure>
<h3 id="网络">网络</h3>
<p>创建 hostname 文件，并设置主机名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;Arch&quot; &gt;&gt; /etc/hostname</span><br></pre></td></tr></table></figure>
<p>编辑 hosts 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>在 hosts 文件中添加如下内容，保存退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">::1 localhost</span><br><span class="line">127.0.1.1 Arch.localdomain Arch</span><br></pre></td></tr></table></figure>
<h3 id="root-密码">Root 密码</h3>
<p>设置 Root 密码，执行以下命令，输入两次密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h3 id="创建新用户">创建新用户</h3>
<p>Linux 中不建议使用 root 用户登录，因此有必要创建一个其他用户，以用户名 wylu 为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m -g users -G wheel -s /bin/bash wylu</span><br></pre></td></tr></table></figure>
<p><code>-G</code> 选项同时将该用户添加到 wheel 组中，<code>-s</code> 指定该用户默认使用的 shell 为 bash 。</p>
<p>修改新创建用户的密码，同样输入两次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd wylu</span><br></pre></td></tr></table></figure>
<p>使用 visudo 命令修改 /etc/sudoers 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>取消 wheel 组的所在行的注释，授予 wheel 组用户执行 sudo 命令的权限，保存退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Uncomment to allow members of group wheel to execute any command</span><br><span class="line">%wheel ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>
<h3 id="安装引导程序">安装引导程序</h3>
<p>如果在一个移动介质上安装 Arch Linux，需要安装 <a href="https://wiki.archlinux.org/index.php/Microcode">Microcode</a> 软件包。</p>
<ul>
<li>对于 AMD 处理器，安装 amd-ucode。</li>
<li>对于 Intel 处理器，安装 intel-ucode。</li>
</ul>
<p>这里使用的是 Intel 的处理器，安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure>
<p>引导的方式有很多，这里使用 <a href="https://wiki.archlinux.org/index.php/GRUB">grub</a>，顺序执行下面 3 条命令生成引导文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub --recheck</span><br></pre></td></tr></table></figure>
<p><code>--efi-directory</code> 指定 EFI 系统分区的挂载点，应根据实际挂载路径填写，<code>--bootloader-id</code> 是启动项中用来识别 GRUB EFI 的标记。</p>
<p>上述命令执行完成后 GRUB 的主目录将位于 /boot/grub/，接着需要生成配置文件 grub.cfg。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<h3 id="设置-dhcpcd-开机自启">设置 dhcpcd 开机自启</h3>
<p>设置 dhcpcd.service 开机自启，不然装完重启后无法上网：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable dhcpcd.service</span><br></pre></td></tr></table></figure>
<h2 id="重启">重启</h2>
<ol type="1">
<li>执行 <code>exit</code> 退出 chroot 环境：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>执行下列命令，卸载被挂载的分区：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount -R /mnt</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>关闭虚拟机：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>移除 CD/DVD</li>
</ol>
<p>编辑虚拟机设置 -&gt; CD/DVD(IDE) -&gt; Remove -&gt; Save</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6c250bf061c37f657d1906830710248e.png" alt="rm-cd-dvd" /></p>
<ol start="5" type="1">
<li>启动虚拟机</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dc4fe07da44ffc55df2f8dbc50be3916.png" alt="grub" /></p>
<p>选择第一个选项启动系统，使用新创建的用户登录。</p>
<h1 id="安装-deepin-桌面环境">安装 Deepin 桌面环境</h1>
<p>参考 Acris Liu 博客 <a href="https://acris.me/2017/03/24/How-to-install-Arch-Linux-with-Deepin-desktop-on-VMware-Workstation/">VMware Workstation安装Arch Linux和Deepin桌面教程</a></p>
<h2 id="安装-git">安装 Git</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure>
<h2 id="安装-aur-助手-yay">安装 AUR 助手 yay</h2>
<p>如果不想使用 <code>yay</code>，可跳过该步，对于下面命令中的 <code>yay</code> 可以替换为 <code>sudo pacman</code> 。</p>
<p>使用 git 克隆并编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>
<h2 id="安装-bash-自动补全工具">安装 bash 自动补全工具</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S bash-completion</span><br></pre></td></tr></table></figure>
<h2 id="安装-xdg-user-dirs">安装 xdg-user-dirs</h2>
<p>安装 xdg-user-dirs，用于生成用户 home 目录下的 Documents、Downloads、Music、Pictures 等文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S xdg-user-dirs</span><br><span class="line">xdg-user-dirs-update</span><br></pre></td></tr></table></figure>
<h2 id="安装-dde">安装 dde</h2>
<p>安装基础组件，直接回车两次，默认安装 <a href="https://www.archlinux.org/groups/x86_64/deepin/">deepin</a> 组的所有包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S deepin</span><br></pre></td></tr></table></figure>
<p>安装扩展包，<a href="https://www.archlinux.org/groups/x86_64/deepin-extra/">deepin-extra</a> 组包含了一些额外的应用程序来提供一个更完整的桌面环境。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S deepin-extra</span><br></pre></td></tr></table></figure>
<h2 id="安装-networkmanager">安装 networkmanager</h2>
<p>为了能够使用内置的网络管理，需要安装 networkmanager 包，并且 NetworkManager.service 需要被激活并设为开机自启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S networkmanager</span><br></pre></td></tr></table></figure>
<p>设置开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable NetworkManager.service</span><br></pre></td></tr></table></figure>
<p>现在开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start NetworkManager.service</span><br></pre></td></tr></table></figure>
<h2 id="修改-lightdm-配置文件">修改 lightdm 配置文件</h2>
<p>要使用 DDE 默认的 lightdm greeter，必须修改 /etc/lightdm/lightdm.conf 的配置，将greeter-session设为lightdm-deepin-greeter：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/lightdm/lightdm.conf</span><br></pre></td></tr></table></figure>
<p>取消注释并修改 greeter-session 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Seat:*]</span><br><span class="line">...</span><br><span class="line">greeter-session=lightdm-deepin-greeter</span><br></pre></td></tr></table></figure>
<p>设置开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable lightdm.service</span><br></pre></td></tr></table></figure>
<p>重启或者直接启动 lightdm 服务，就能进入桌面环境了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start lightdm.service</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3037c46716e9a2b10e3cfe85422473ec.png" alt="dde" /></p>
<h2 id="安装-open-vm-tools">安装 <a href="https://wiki.archlinux.org/index.php/VMware/Installing_Arch_as_a_guest#Open-VM-Tools">open-vm-tools</a></h2>
<p>安装 open-vm-tools 和 gtkmm3：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S open-vm-tools gtkmm3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果该功能无法正常工作，请尝试手动安装 gtkmm3 。如要启用客户机的拖拽与复制粘贴功能，则需要安装 gtkmm3 。</p>
</blockquote>
<p>设置 open-vm-tools 开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable vmtoolsd.service</span><br><span class="line">sudo systemctl enable vmware-vmblock-fuse.service</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>os</category>
        <category>arch</category>
      </categories>
      <tags>
        <tag>arch-linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数与最小公倍数</title>
    <url>/posts/9a52256e/</url>
    <content><![CDATA[<p>如果数 a 能被数 b 整除，a 就叫做 b 的倍数，b 就叫做 a 的约数。</p>
<p>几个整数中公有的约数，叫做这几个数的公约数；其中最大的一个，叫做这几个数的最大公约数。</p>
<p>几个自然数公有的倍数，叫做这几个数的公倍数，其中最小的一个自然数，叫做这几个数的最小公倍数。</p>
<p>本文将使用欧几里德算法实现求两个数的最大公约数。</p>
<span id="more"></span>
<h1 id="最大公约数">最大公约数</h1>
<p>欧几里德算法，也称辗转相除法</p>
<p>定理： gcd(a, b) = gcd(b, a mod b) ( a &gt; b 且 a mod b 不为 0 ) 即 a 和 b 的最大公约数等于 b 和 a % b 的最大公约数</p>
<blockquote>
<p>证明：a 可以表示成 a = kb + r，则 r = a mod b</p>
<p>假设 x 是 a, b 的一个公约数，则有 x|a , x|b , 而 r = a - kb，因此 x|r 因此 x 也是（ b, a mod b ）的公约数 因此（ a, b ）和（ b, a mod b ）的公约数是一样的，其最大公约数也必然相等 得证：当 a % b 为 0 的时候, 则另一个数为最大公约数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">//如果a&lt;b, 交换a b</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="type">int</span> tmp = a, a = b, b = tmp;</span><br><span class="line">    <span class="comment">//如果b为0则结束循环, 返回0, 否则计算b与a%b的gcd</span></span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小公倍数">最小公倍数</h1>
<p>假设求 x, y 的最小公倍数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公式： x * y = 最小公倍数 * 最大公约数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>筛法求素数</title>
    <url>/posts/89cdb724/</url>
    <content><![CDATA[<p>本文将介绍 <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">埃拉托斯特尼筛法</a> 和 <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler&#39;s_sieve">欧拉线性筛法</a> 的基本原理，并以此思路实现这两种求素数的算法。</p>
<span id="more"></span>
<h1 id="埃拉托斯特尼筛法">埃拉托斯特尼筛法</h1>
<h2 id="基本思路">基本思路</h2>
<p>当一个数是素数的时候，它的倍数肯定不是素数，对于这些数可以直接标记筛除。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p><span class="math inline">\(O(nloglogn)\)</span></p>
<h2 id="算法实现">算法实现</h2>
<h3 id="java">java</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSieve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sieve(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="type">int</span>[] mark = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]; <span class="comment">//元素值为0代表是素数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                counter++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i; j &lt;= n; j += i)&#123;</span><br><span class="line">                    mark[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] primes = <span class="keyword">new</span> <span class="title class_">int</span>[counter];</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span>) primes[counter++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] ans = SimpleSieve.sieve(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: ans) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python">python</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eratosthenes_sieve</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = []</span><br><span class="line">    marks = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> marks[i]:</span><br><span class="line">            ans.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + i, n, i):</span><br><span class="line">                marks[j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(eratosthenes_sieve(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h1 id="欧拉线性筛法">欧拉线性筛法</h1>
<h2 id="基本思路-1">基本思路</h2>
<p>任意一个合数（2 不是合数），都可以表示成素数的乘积。</p>
<p>每个合数必有一个最小素因子，如果每个合数都用最小素因子筛去，那个这个合数就不会被重复标记筛去，所以算法为线性时间复杂度。</p>
<p>例如合数 <code>30 = 2 * 3 * 5</code> ，这个合数一定是被最小素因子 2 筛去的。</p>
<h2 id="时间复杂度-1">时间复杂度</h2>
<p><span class="math inline">\(O(n)\)</span></p>
<h2 id="算法实现-1">算法实现</h2>
<h3 id="java-1">java</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EulerSieve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sieve(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="type">int</span>[] mark = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]; <span class="comment">//元素值为0表示该元素下标值为素数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span>) primes.add(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;primes.size() &amp;&amp; i*primes.get(j)&lt;=n; j++)&#123;</span><br><span class="line">                mark[i*primes.get(j)] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[primes.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;primes.size(); i++)</span><br><span class="line">            ans[i] = primes.get(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] ans = EulerSieve.sieve(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: ans) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python-1">python</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euler_sieve</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="comment"># True 表示该下标值为素数</span></span><br><span class="line">    marks = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> marks[i]:</span><br><span class="line">            ans.append(i)</span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(ans) <span class="keyword">and</span> i * ans[j] &lt; n:</span><br><span class="line">            marks[i * ans[j]] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i % ans[j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(euler_sieve(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a></p>
<p><a href="https://www.jianshu.com/p/f16d318efe9b">https://www.jianshu.com/p/f16d318efe9b</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算符优先分析求中缀表达式</title>
    <url>/posts/48265aa9/</url>
    <content><![CDATA[<p>算符优先分析法：它只考虑算符（终结符）之间的优先关系，分析扫描每个规约式的算符间优先关系。本文将使用算符优先分析法实现求中缀表达式的值。</p>
<span id="more"></span>
<h1 id="定义一个表达式的二义性文法">定义一个表达式的二义性文法</h1>
<p><span class="math display">\[
E\rightarrow E+E \, | \, E-E \, | \, E*E \, | \, E/E \, | \, (E) \, | \, i
\]</span></p>
<h1 id="定义运算规则">定义运算规则</h1>
<p>对以上表达式的文法按公认的计算顺序规定优先级和结合性如下：</p>
<ul>
<li><p>对于运算对象的终结符 <span class="math inline">\(i\)</span> ，其优先级最高</p></li>
<li><span class="math inline">\(*，/\)</span> 优先级其次，服从左结合。相当于 <span class="math inline">\(*&gt;*、*&gt;/、/&gt;/、/&gt;*\)</span></li>
<li><span class="math inline">\(+，-\)</span> 优先级最低，服从左结合。相当于 <span class="math inline">\(+&gt;+、+&gt;-、-&gt;-、-&gt;+\)</span></li>
<li>对于 <span class="math inline">\(“(”，“)”\)</span> 规定括号的优先性大于括号外的运算符，小于括号内的运算符，内括号的优先性大于外括号。</li>
<li><p>对于句子括号 "#" 规定与它相邻的任何运算符的优先性都比它大。</p></li>
</ul>
<h1 id="算符优先关系表">算符优先关系表</h1>
<p>根据定义的优先规则可以构造出如下优先关系表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">+</th>
<th style="text-align: center;">-</th>
<th style="text-align: center;">*</th>
<th style="text-align: center;">/</th>
<th style="text-align: center;">(</th>
<th style="text-align: center;">)</th>
<th style="text-align: center;">i</th>
<th style="text-align: center;">#</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>+</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>-</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>*</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>/</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>(</strong></td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">=</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>)</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>i</strong></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&gt;</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>#</strong></td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">=</td>
</tr>
</tbody>
</table>
<p>所给表达式文法虽然是二义性的，但我们人为直观地给出运算符之间的优先关系且这种优先关系是唯一的，有了这个优先关系表我们对与符合文法的表达式的归约过程就是唯一确定的了。</p>
<h1 id="算符优先归约过程">算符优先归约过程</h1>
<p>以分析输入串 <span class="math inline">\(i_1+i_2*i_3\)</span> 为例：</p>
<table>
<thead>
<tr class="header">
<th>步骤</th>
<th>栈</th>
<th>优先关系</th>
<th>当前符号</th>
<th style="text-align: right;">剩余输入串</th>
<th>移进或归约</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(1)</td>
<td>#</td>
<td>&lt;</td>
<td><span class="math inline">\(i_1\)</span></td>
<td style="text-align: right;">+<span class="math inline">\(i_2\)</span>*<span class="math inline">\(i_3\)</span>#</td>
<td>移进</td>
</tr>
<tr class="even">
<td>(2)</td>
<td>#<span class="math inline">\(i_1\)</span></td>
<td>&gt;</td>
<td>+</td>
<td style="text-align: right;"><span class="math inline">\(i_2\)</span>*<span class="math inline">\(i_3\)</span>#</td>
<td>归约<span class="math inline">\(E \rightarrow i\)</span></td>
</tr>
<tr class="odd">
<td>(3)</td>
<td>#E</td>
<td>&lt;</td>
<td>+</td>
<td style="text-align: right;"><span class="math inline">\(i_2\)</span>*<span class="math inline">\(i_3\)</span>#</td>
<td>移进</td>
</tr>
<tr class="even">
<td>(4)</td>
<td>#E+</td>
<td>&lt;</td>
<td><span class="math inline">\(i_2\)</span></td>
<td style="text-align: right;">*<span class="math inline">\(i_3\)</span>#</td>
<td>移进</td>
</tr>
<tr class="odd">
<td>(5)</td>
<td>#E+<span class="math inline">\(i_2\)</span></td>
<td>&gt;</td>
<td>*</td>
<td style="text-align: right;"><span class="math inline">\(i_3\)</span>#</td>
<td>归约<span class="math inline">\(E \rightarrow i\)</span></td>
</tr>
<tr class="even">
<td>(6)</td>
<td>#E+E</td>
<td>&lt;</td>
<td>*</td>
<td style="text-align: right;"><span class="math inline">\(i_3\)</span>#</td>
<td>移进</td>
</tr>
<tr class="odd">
<td>(7)</td>
<td>#E+E*</td>
<td>&lt;</td>
<td><span class="math inline">\(i_3\)</span></td>
<td style="text-align: right;">#</td>
<td>移进</td>
</tr>
<tr class="even">
<td>(8)</td>
<td>#E+E*<span class="math inline">\(i_3\)</span></td>
<td>&gt;</td>
<td>#</td>
<td style="text-align: right;"></td>
<td>归约<span class="math inline">\(E \rightarrow i\)</span></td>
</tr>
<tr class="odd">
<td>(9)</td>
<td>#E+E*E</td>
<td>&gt;</td>
<td>#</td>
<td style="text-align: right;"></td>
<td>归约<span class="math inline">\(E \rightarrow E*E\)</span></td>
</tr>
<tr class="even">
<td>(10)</td>
<td>#E+E</td>
<td>&gt;</td>
<td>#</td>
<td style="text-align: right;"></td>
<td>归约<span class="math inline">\(E \rightarrow E+E\)</span></td>
</tr>
<tr class="odd">
<td>(11)</td>
<td>#E</td>
<td>=</td>
<td>#</td>
<td style="text-align: right;"></td>
<td>接受</td>
</tr>
</tbody>
</table>
<h1 id="计算中缀表达式的值">计算中缀表达式的值</h1>
<p>创建两个辅助栈 stackOper 和 stackData ，扫描中缀表达式时，用 stackOper 存储表达式中的运算符，用 stackData 存储操作数。</p>
<p>stackOper 栈顶运算符对应着算符优先关系表第一纵列的运算符，每次从表达式中扫描到的运算符对应着算符优先关系表第一横行的运算符。</p>
<p>基本思想：</p>
<ol type="1">
<li><p>首先置 stackOper 和 stackData 为空栈</p></li>
<li><p>向 stackOper 压入运算符 # ，在表达式后面加上 # (作为结束标志)</p></li>
<li><p>依次扫描表达式中的每一个字符，若是操作数，则将操作数压入 stackData 中；</p></li>
</ol>
<ul>
<li>若是运算符，则将运算符和 stackOper 栈顶的运算符比较优先级后做相应操作 (若栈顶运算符优先级高，则 stackData 连续弹出两个数， stackOper 弹出运算符，按弹出的运算符计算出结果后，将结果压入 stackData ；否则，直接将新扫描的运算符压入 stackOper )；</li>
<li>否则，表达式文法错误，抛异常</li>
</ul>
<ol start="4" type="1">
<li>直至整个表达式扫描完毕， stackData 栈顶的数值就是运算结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 利用算符优先文法求中缀表达式的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXPRESSION_END_FLAG</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WRONG_EXPRESSION</span> <span class="operator">=</span> <span class="string">&quot;文法错误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">ZERO</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">NINE</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶运算符比前扫描到的运算符优先级高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIORITY_HIGH</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶运算符与前扫描到的运算符优先级相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIORITY_EQUAL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶运算符比前扫描到的运算符优先级低</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIORITY_LOW</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非法运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OPERATOR_DEDY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1）先乘除，后加减</span></span><br><span class="line"><span class="comment">     * 2）同级运算，从左到右依次计算</span></span><br><span class="line"><span class="comment">     * 3）有括号的，先算括号里面的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 根据以上三条规则定义如下算符优先关系表：</span></span><br><span class="line"><span class="comment">     *     &gt; : 行位置的运算比列位置的运算的优先级高</span></span><br><span class="line"><span class="comment">     *     &lt; : 行位置的运算比列位置的运算的优先级低</span></span><br><span class="line"><span class="comment">     *     = : 行位置的运算与列位置的运算的优先级相等</span></span><br><span class="line"><span class="comment">     *     $ : 表示这两种运算之间没有可比性，说明输入的式子有文法错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[][] PRIORITY_TABLE = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;$&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;#&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;$&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;)&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;#&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;=&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建两个辅助栈stackOper和stackData，</span></span><br><span class="line"><span class="comment">     * 扫描中缀表达式时，用stackOper存储表达式中的运算符，用stackData存储操作数。</span></span><br><span class="line"><span class="comment">     * stackOper栈顶运算符对应着算符优先关系表第一纵列的运算符，</span></span><br><span class="line"><span class="comment">     * 每次从表达式中扫描到的运算符对应着算符优先关系表第一横行的运算符。</span></span><br><span class="line"><span class="comment">     * 求中缀表达式的基本思想如下：</span></span><br><span class="line"><span class="comment">     * 1) 首先置stackOper和stackData为空栈</span></span><br><span class="line"><span class="comment">     * 2) 向stackOper压入运算符#，在表达式后面加上#(作为结束标志)</span></span><br><span class="line"><span class="comment">     * 3) 依次扫描表达式中的每一个字符，若是操作数，则将操作数压入stackData中；</span></span><br><span class="line"><span class="comment">     *    若是运算符，则将运算符和stackOper栈顶的运算符比较优先级后做相应操作</span></span><br><span class="line"><span class="comment">     *    (若栈顶运算符优先级高，则stackData连续弹出两个数，stackOper弹出运算符，</span></span><br><span class="line"><span class="comment">     *    按弹出的运算符计算出结果后，将结果压入stackData;</span></span><br><span class="line"><span class="comment">     *    否则，直接将新扫描的运算符压入stackOper)；</span></span><br><span class="line"><span class="comment">     *    否则，表达式文法错误，抛异常</span></span><br><span class="line"><span class="comment">     * 4) 直至整个表达式扫描完毕，stackData栈顶的数值就是运算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果的字符串形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">cal</span><span class="params">(String expression)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">express</span> <span class="operator">=</span> expression.replaceAll(<span class="string">&quot;\\s*&quot;</span>, <span class="string">&quot;&quot;</span>) + EXPRESSION_END_FLAG;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; stackOper = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Double&gt; stackData = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stackOper.push(EXPRESSION_END_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; express.length();) &#123;</span><br><span class="line">            ch = express.charAt(i);</span><br><span class="line">            <span class="comment">//操作数</span></span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= ZERO &amp;&amp; ch &lt;= NINE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == express.length() - <span class="number">2</span>) &#123;</span><br><span class="line">                    stackData.push((<span class="type">double</span>) (ch - ZERO));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (express.charAt(j) &gt;= ZERO</span><br><span class="line">                           &amp;&amp; express.charAt(j) &lt;= NINE) j++;</span><br><span class="line">                    stackData.push(Double.valueOf(express.substring(i, j)));</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//运算符</span></span><br><span class="line">                <span class="keyword">switch</span> (judgePriority(stackOper.peek(), ch)) &#123;</span><br><span class="line">                    <span class="keyword">case</span> PRIORITY_HIGH:</span><br><span class="line">                        stackData.push(operate(stackData.pop(), stackData.pop(), stackOper.pop()));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PRIORITY_EQUAL:</span><br><span class="line">                        stackOper.pop();</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PRIORITY_LOW:</span><br><span class="line">                        stackOper.push(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">Exception</span>(WRONG_EXPRESSION));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stackOper.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">Exception</span>(WRONG_EXPRESSION));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(stackData.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Double <span class="title function_">operate</span><span class="params">(Double num1, Double num2, String operator)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num2 + num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num2 - num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num2 * num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num2 / num1;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judgePriority</span><span class="params">(String stackTopOper, <span class="type">char</span> currentOper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> judgePriority(stackTopOper, currentOper + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较栈顶运算符和当前扫描的运算符的优先级高级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stackTopOper 栈顶运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentOper 当前扫描到的运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 魔数 PRIORITY_HIGH=1 PRIORITY_EQUAL=0 PRIORITY_LOW=-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judgePriority</span><span class="params">(String stackTopOper, String currentOper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackTopOper == <span class="literal">null</span> || currentOper == <span class="literal">null</span>) <span class="keyword">return</span> OPERATOR_DEDY;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; PRIORITY_TABLE.length</span><br><span class="line">                &amp;&amp; !PRIORITY_TABLE[row][<span class="number">0</span>].equals(stackTopOper)) row++;</span><br><span class="line">        <span class="keyword">while</span> (col &lt; PRIORITY_TABLE[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; !PRIORITY_TABLE[<span class="number">0</span>][col].equals(currentOper)) col++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row == PRIORITY_TABLE.length || col == PRIORITY_TABLE[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> OPERATOR_DEDY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (PRIORITY_TABLE[row][col]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> PRIORITY_HIGH;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> PRIORITY_LOW;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;=&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> PRIORITY_EQUAL;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> OPERATOR_DEDY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        String expression = &quot;2*(3-1)+(5+4)/9&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;(5+4)/9+11&quot;</span>;</span><br><span class="line">        System.out.println(Calculator.cal(expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>算符优先分析</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/2da0528d/</url>
    <content><![CDATA[<p>在计算机科学中，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a> 字符串查找算法（简称 KMP 算法）可在一个主文本字符串 S 内查找一个词 W 的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。</p>
<p>该算法由唐纳德·克努斯（Donald Knuth）和沃恩·普拉特（Vaughan Pratt）于 1970 年提出，由詹姆斯·h·莫里斯（James H. Morris）独立完成，最终由三人于 1977 年联合发表。这是第一个字符串匹配的线性时间算法。</p>
<span id="more"></span>
<h1 id="kmp算法的来源">KMP算法的来源</h1>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。</p>
<h1 id="前缀和后缀的定义">前缀和后缀的定义</h1>
<ul>
<li>“前缀”指除最后一个字符外，一个字符串的全部头部组合；</li>
<li>“后缀”指除第一个字符外，一个字符串的全部尾部组合。</li>
</ul>
<p>例如：</p>
<table>
<thead>
<tr class="header">
<th>字符串</th>
<th>“blue”</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>前缀</td>
<td>“b” “bl” “blu”</td>
</tr>
<tr class="even">
<td>后缀</td>
<td>“lue” “ue” “e”</td>
</tr>
</tbody>
</table>
<h1 id="kmp-算法的关键">KMP 算法的关键</h1>
<p>KMP 利用之前已经部分匹配这个有效信息，保持 i 不回溯，通过修改 j 的位置，让模式串尽量地移动到有效的位置，而模式串移动的信息存在 next 数组中。</p>
<p>KMP 算法的关键是 next 数组的计算，next 数组的计算只与模式串有关，next 中存储的值为当前下标之前的子串的 <strong>最长相同前缀和后缀的长度</strong>。如模式串 "ABCDABD" 的 next 数组：</p>
<table>
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>模式串</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>A</td>
<td>B</td>
<td>D</td>
</tr>
<tr class="even">
<td>next[i]</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>注：<code>next[0]</code> 设为 -1</p>
<h1 id="bf-算法-brute-force-暴力匹配">BF 算法（ Brute-Force 暴力匹配）</h1>
<p>假设现在我们面临这样一个问题：有一个文本串 S，和一个模式串 P，现在要查找 P 在 S 中的位置，怎么查找呢？</p>
<p>如果用暴力匹配的思路，并假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置，则有：</p>
<ul>
<li><p>如果当前字符匹配成功（即 <code>S[i] == P[j]</code> ），则 i++， j++，继续匹配下一个字符；</p></li>
<li><p>如果失配（即 <code>S[i] != P[j]</code> ），令 i = i - j + 1， j = 0。相当于每次匹配失败时， i 回溯， j 被置为 0。</p></li>
</ul>
<p>用 Java 实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BruteForceMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (j == p.length) ? i - j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = <span class="string">&quot;ABCDABD&quot;</span>.toCharArray();</span><br><span class="line">        System.out.println(search(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="next数组计算">next数组计算</h1>
<ul>
<li><code>next[0] = -1</code></li>
<li>如果已知 <code>next[j] = k</code>，如何求出 <code>next[j+1]</code>
<ul>
<li>如果 <code>p[j] == p[k]</code> , 则 <code>next[j+1] = next[j] + 1 = k + 1</code>;</li>
<li>如果 <code>p[j] != p[k]</code>, 则令 <code>k = next[k]</code>, 如果此时 <code>p[j] == p[k]</code>,则 <code>next[j+1] = k+1</code>, 如果不相等, 则继续递归前缀索引,令 <code>k = next[k]</code>, 继续判断, 直至 <code>k = -1</code> (即 <code>k = next[0]</code> )或者 <code>p[j] == p[k]</code> 为止</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] p)&#123;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[p.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[k] == p[j])&#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kmp算法">KMP算法</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] p)&#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[p.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || p[k] == p[j])&#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextArray(String p)&#123;</span><br><span class="line">        <span class="keyword">return</span> KMP.getNextArray(p.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] next = KMP.getNextArray(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (j == p.length) ? i - j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KMP.search(s.toCharArray(), p.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        System.out.println(KMP.search(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="时间复杂度">时间复杂度</h1>
<p><strong>BF：</strong> <span class="math inline">\(O(n*m)\)</span>，BF 在失配时，主串需要回溯，然后从下一个字符开始重新与模式串进行匹配。</p>
<p><strong>KMP：</strong> <span class="math inline">\(O(n+m)\)</span>，求 next 数组的时间复杂度是 <span class="math inline">\(O(m)\)</span>， KMP 失配时，主串不需要回溯，时间复杂度为 <span class="math inline">\(O(n)\)</span>，整体时间复杂度为 <span class="math inline">\(O(n+m)\)</span></p>
<p>最好情况：每趟匹配不成功都是在第一个字符，即每趟都只需匹配一次就知道该趟是否匹配，<code>O(n+m)</code></p>
<p>最坏情况：每趟匹配不成功都是在最后一个字符，<code>O(n*m)</code></p>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm</a></p>
<p><a href="https://www.jianshu.com/p/e2bd1ee482c3">https://www.jianshu.com/p/e2bd1ee482c3</a></p>
<p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>BFPRT算法</title>
    <url>/posts/c2effb3e/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Median_of_medians">BFPRT</a> 算法是目前解决 TOP-K 问题最有效的算法，又称为中位数的中位数算法，该算法由 Blum、Floyd、Pratt、Rivest、Tarjan 提出，最坏时间复杂度为 <span class="math inline">\(O(n)\)</span>。</p>
<p>在一堆数中求其前 k 大或前 k 小的问题，简称 TOP-K 问题。</p>
<span id="more"></span>
<h1 id="应用场景">应用场景</h1>
<p>线性时间内，从无序列表找到第 k 小的元素。</p>
<h1 id="基本思想">基本思想</h1>
<ul>
<li>首先把数组按 5 个数为一组进行分组，最后不足 5 个的忽略。对每组数进行排序（如插入排序）求取其中位数。</li>
<li>把上一步的所有中位数移到数组的前面，对这些中位数递归调用 BFPRT 算法求得他们的中位数。</li>
<li>将上一步得到的中位数作为划分的主元进行整个数组的划分。</li>
<li>判断第 k 个数在划分结果的左边、右边还是恰好是划分结果本身，前两者递归处理，后者直接返回答案。</li>
</ul>
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;right; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=right; j&gt;i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) tmp = a[j], a[j] = a[j<span class="number">-1</span>], a[j<span class="number">-1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> baseIdx)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;</span><br><span class="line">    <span class="comment">//将基准放于数组尾部</span></span><br><span class="line">    tmp = a[right], a[right] = a[baseIdx], a[baseIdx] = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfprt</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left +<span class="number">1</span> &lt;= <span class="number">5</span>)&#123; <span class="comment">//小于等于5个数，直接排序得到结果</span></span><br><span class="line">        <span class="built_in">bubble_sort</span>(a, left, right);</span><br><span class="line">        <span class="keyword">return</span> a[left + k <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = left - <span class="number">1</span>, tmp;  <span class="comment">//t:当前替换到前面的中位数的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st = left, ed; (ed=st+<span class="number">4</span>) &lt;= right; st += <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">bubble_sort</span>(a, st, ed);</span><br><span class="line">        <span class="comment">//将中位数替换到数组前面，便于递归求取中位数的中位数</span></span><br><span class="line">        tmp = a[++t], a[t] = a[st+<span class="number">2</span>], a[st+<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> baseIdx = (left + t) &gt;&gt; <span class="number">1</span>; <span class="comment">//left到t的中位数的下标，作为主元的下标</span></span><br><span class="line">    <span class="built_in">bfprt</span>(a, left, t, baseIdx-left + <span class="number">1</span>); <span class="comment">//不关心中位数的值，保证中位数在正确的位置</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">partition</span>(a, left, right, baseIdx), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> <span class="built_in">bfprt</span>(a, left, idx<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">bfprt</span>(a, idx+<span class="number">1</span>, right, k-cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<p>划分时以 5 个元素为一组求取中位数，共得到 <code>n/5</code> 个中位数，再递归求取中位数，复杂度为 <code>T(n/5)</code>。</p>
<p>得到的中位数 <code>x</code> 作为主元进行划分，在 <code>n/5</code> 个中位数中，主元 <code>x</code> 大于其中 <code>1/2*n/5 = n/10</code> 的中位数，而每个中位数在其本来的 5 个数的小组中又大于或等于其中的 3 个数，所以主元 <code>x</code> 至少大于所有数中的 <code>n/10*3 = 3/10*n</code> 个。同理，主元 <code>x</code> 至少小于所有数中的 <code>3/10*n</code> 个。即划分之后，任意一边的长度至少为 <code>3/10</code>，在最坏情况下，每次选择都选到了 <code>7/10</code> 的那一部分，则递归的复杂度为 <code>T(7/10*n)</code>。</p>
<p>在每 5 个数求中位数和划分的函数中，进行若干个次线性的扫描，其时间复杂度为 <code>c*n</code>，其中 <code>c</code> 为常数。其总的时间复杂度满足 <code>T(n) &lt;= T(n/5)+T(7/10*n)+c*n</code>。</p>
<p>我们假设 <code>T(n) = x*n</code> ，其中 <code>x</code> 不一定是常数（比如 <code>x</code> 可以为 <code>n</code> 的倍数，则对应的 <code>T(n) = O(n^2))</code>。则有 <code>x*n &lt;= x*n/5+x*7/10*n+c*n</code>，得到 <code>x &lt;= 10*c</code>。于是可以知道 <code>x</code> 与 <code>n</code> 无关， <code>T(n) &lt;= 10*c*n</code>，为线性时间复杂度算法。而这又是最坏情况下的分析，故 BFPRT 可以在最坏情况下以线性时间求得 <code>n</code> 个数中的第 <code>k</code> 个数。</p>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Median_of_medians">https://en.wikipedia.org/wiki/Median_of_medians</a></p>
<p><a href="https://www.cnblogs.com/informatics/p/5092741.html">https://www.cnblogs.com/informatics/p/5092741.html</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>search</category>
      </categories>
      <tags>
        <tag>BFPRT</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481/</url>
    <content><![CDATA[<p>二分查找也称 <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">折半查找（Binary Search）</a>，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<span id="more"></span>
<h1 id="前提条件">前提条件</h1>
<p>数组有序</p>
<h1 id="时间复杂度">时间复杂度</h1>
<p>二分搜索方法充分利用了元素间的次序关系，采用分治策略，可在最坏情况下用 <span class="math inline">\(O(logn)\)</span> 时间完成搜索任务</p>
<h1 id="基本思想">基本思想</h1>
<p>将 n 个元素分成个数大致相同的两半，取 <code>a[n/2]</code> 与 x 进行比较。</p>
<p>如果<code>x=a[n/2]</code>，则找到 x，算法终止。</p>
<p>如果 <code>x&lt;a[n/2]</code>, 则只要在数组 a 的左半部继续搜索 x。</p>
<p>如果 <code>x&gt;a[n/2]</code>，则只要在数组 a 的右半部继续搜索 x。</p>
<h1 id="java-实现">Java 实现</h1>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) <span class="keyword">return</span> binarySearch2(arr, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearch2(arr, target, left, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-实现">C 实现</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">https://en.wikipedia.org/wiki/Binary_search_algorithm</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>search</category>
      </categories>
      <tags>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>快速选择算法</title>
    <url>/posts/7fa149d7/</url>
    <content><![CDATA[<p>在计算机科学中，<a href="https://en.wikipedia.org/wiki/Quickselect">快速选择（Quickselect）</a>是一种从无序列表找到第 k 小元素的选择算法。它从原理上来说与快速排序有关。与快速排序一样都由托尼·霍尔提出的，因而也被称为霍尔选择算法。同样地，它在实际应用是一种高效的算法，具有很好的平均时间复杂度，然而最坏时间复杂度则不理想。快速选择及其变种是实际应用中最常使用的高效选择算法。</p>
<span id="more"></span>
<h1 id="应用场景">应用场景</h1>
<p><strong>快速选择</strong> 是一种从无序列表找到第 k 小元素的选择算法。</p>
<h1 id="基本思想">基本思想</h1>
<p>快速选择的总体思路与 <a href="https://wylu.github.io/posts/c96e6ef1/">快速排序</a> 一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(nlogn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p>
<h1 id="c-实现">C 实现</h1>
<h2 id="实现一">实现一</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对给定的数组区间进行划分</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param left 区间下限，包含arr[left]</span></span><br><span class="line"><span class="comment"> * @param right 区间上限，包含arr[right]</span></span><br><span class="line"><span class="comment"> * @return 返回划分后，划分基准的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="comment">//以arr[right]作为划分基准</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++j, right);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找第k小元素</span></span><br><span class="line"><span class="comment"> * @param arr 无序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 目标第k小</span></span><br><span class="line"><span class="comment"> * @return 成功：返回第k小元素的索引</span></span><br><span class="line"><span class="comment"> *         失败：返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> idx = partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) == idx) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) &gt; idx) left = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现二">实现二</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> base = arr[left]; <span class="comment">//以arr[left]作为划分基准</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= base) right--;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= base) left++;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> idx = partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) == idx) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) &gt; idx) left = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归写法">递归写法</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++j, right);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> idx = partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) == idx) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) &gt; idx) <span class="keyword">return</span> quickSelect(arr, idx + <span class="number">1</span>, right, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(arr, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java-实现">Java 实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找第k小元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 目标第k小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功：返回第k小元素的索引</span></span><br><span class="line"><span class="comment"> *         失败：返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>, idx;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        idx = partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> ((k - <span class="number">1</span>) == idx) <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((k - <span class="number">1</span>) &gt; idx) left = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对给定的数组区间进行划分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 区间下限，包含arr[left]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 区间上限，包含arr[right]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回划分后，划分基准的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++j, right);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Quickselect">https://en.wikipedia.org/wiki/Quickselect</a></p>
<p><a href="https://www.jianshu.com/p/1dbdeb07f1aa">https://www.jianshu.com/p/1dbdeb07f1aa</a></p>
<p><a href="https://www.cnblogs.com/informatics/p/5092741.html">https://www.cnblogs.com/informatics/p/5092741.html</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>search</category>
      </categories>
      <tags>
        <tag>快速选择</tag>
      </tags>
  </entry>
  <entry>
    <title>RadixSort</title>
    <url>/posts/ef1ec211/</url>
    <content><![CDATA[<p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到 1887 年 Herman Hollerith 在打孔卡片制表机（Tabulation Machine）上的贡献。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为 10 的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。</p>
<h1 id="算法步骤">算法步骤</h1>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li>
</ul>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/fec18411fbc2bfd4617b820b73e64a96.gif" alt="RadixSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RADIX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数字的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigitLength</span><span class="params">(<span class="type">int</span> digit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (digit == <span class="number">0</span>) ? <span class="number">1</span> : (<span class="type">int</span>) Math.log10(digit) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组中数字的最大位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxLength</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getDigitLength(e);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) maxLength = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数x第d位上的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x / (<span class="type">int</span>) (Math.pow(<span class="number">10</span>, d - <span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据元素的第d位数字，对数组arr进行计数排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[RADIX];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            counts[getDigit(e, d)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; RADIX; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[RADIX];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//根据当前位数字，把每个元素arr[i]放到临时数组tmp中的正确位置上</span></span><br><span class="line">            <span class="comment">//当再遇到当前位数字x相同的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">            tmp[--counts[getDigit(arr[i], d)]] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(tmp, <span class="number">0</span>, arr, <span class="number">0</span>, tmp.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最低位优先 LSD (Least sgnificant digital)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lsdRadixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> getMaxLength(arr);</span><br><span class="line">        <span class="comment">//从低位到高位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= maxLength; d++) &#123;</span><br><span class="line">            <span class="comment">//根据第d位数字对arr进行计数排序</span></span><br><span class="line">            countingSort(arr, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;3, 1, 4, 9, 6, 0, 7, 2, 5, 8&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">20</span>, <span class="number">90</span>, <span class="number">64</span>, <span class="number">289</span>, <span class="number">998</span>, <span class="number">365</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">789</span>, <span class="number">456</span>&#125;;</span><br><span class="line">        RadixSort.lsdRadixSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>基数排序</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(n+m)\)</span></td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>m 为数组中数字的最大位数</p>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562543&amp;idx=1&amp;sn=c82892b85e1de790766896c6d80d7b3c&amp;chksm=f1fee96cc689607a11ccc109098d070d38ef0bad61c0390fe01348b631bbd492945b6f2b0601&amp;scene=0#rd">https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562543&amp;idx=1&amp;sn=c82892b85e1de790766896c6d80d7b3c&amp;chksm=f1fee96cc689607a11ccc109098d070d38ef0bad61c0390fe01348b631bbd492945b6f2b0601&amp;scene=0#rd</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>BucketSort</title>
    <url>/posts/901ddcd0/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Bucket_sort">桶排序（Bucket sort）</a>或箱排序（Bin sort），是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是 <a href="https://en.wikipedia.org/wiki/Pigeonhole_sort">鸽巢排序</a> 的一种归纳结果。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>桶排序也叫箱排序。工作原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。</p>
<h1 id="算法步骤">算法步骤</h1>
<ul>
<li>设置固定数量的空桶</li>
<li>把数据放到对应的桶中</li>
<li>对每个不为空的桶中数据进行排序</li>
<li>拼接不为空的桶中数据，得到结果</li>
</ul>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/58b4d4b9e802104727677d7b0b60157a.gif" alt="BucketSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Sort.internal.Comparison.InsertSort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] buildBucket(<span class="type">int</span>[] arr, <span class="type">int</span> min, <span class="type">int</span> gap) &#123;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[m][];</span><br><span class="line">        <span class="comment">//每个桶的元素个数</span></span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) counts[(e - min) / gap]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">int</span>[counts[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buckets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e &lt; min) min = e;</span><br><span class="line">            <span class="keyword">if</span> (e &gt; max) max = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//桶的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> (max - min) / m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = buildBucket(arr, min, gap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每个元素映射到相应的桶中</span></span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">//桶编号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (e - min) / gap;</span><br><span class="line">            buckets[id][cur[id]++] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行桶内排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            InsertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> e : bucket) &#123;</span><br><span class="line">                arr[idx++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        BucketSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>桶排序</td>
<td><span class="math inline">\(O(n+m)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n+m)\)</span></td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Bucket_sort">https://en.wikipedia.org/wiki/Bucket_sort</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>CountingSort</title>
    <url>/posts/844f0450/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Counting_sort">计数排序（Counting sort）</a>是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。计数排序使用一个额外的数组 C ，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>使用一个新的数组记录每个元素出现的次数，然后直接遍历输出这个数组里面的每一个大于 0 的元素的下标值，下标值输出的次数为对应的计数。</p>
<h1 id="算法步骤">算法步骤</h1>
<ul>
<li>花 O(n) 的时间扫描一下整个序列 arr，获取最小值 min 和最大值 max</li>
<li>开辟一块新的空间创建新的数组 counts，长度为 ( max - min + 1)</li>
<li>数组 counts 中 下标为 index 的元素记录的值是 arr 中元素值为 index 出现的次数</li>
<li>最后输出目标整数序列，具体的逻辑是遍历数组 counts，输出相应计数次的元素下标值</li>
</ul>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e03e1b43409b29aa7a38ff904fe81181.gif" alt="CountingSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unstableSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr)&#123;</span><br><span class="line">            counts[e - min]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((counts[i]--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[j++] = i + min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stableSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e &lt; min) min = e;</span><br><span class="line">            <span class="keyword">if</span> (e &gt; max) max = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//counts[i]保存着arr中等于 i+min 的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : arr) &#123;</span><br><span class="line">            counts[e - min]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//counts[i]保存着小于等于 i+min 的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配临时空间，暂存中间数据</span></span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">            <span class="comment">//把每个元素arr[i]放到它在临时数组tmp中的正确位置上</span></span><br><span class="line">            <span class="comment">//当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">            tmp[--counts[arr[i] - min]] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(tmp, <span class="number">0</span>, arr, <span class="number">0</span>, tmp.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        CountingSort.stableSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>计数排序</td>
<td><span class="math inline">\(O(n+k)\)</span></td>
<td><span class="math inline">\(O(n+k)\)</span></td>
<td><span class="math inline">\(O(n+k)\)</span></td>
<td><span class="math inline">\(O(k)\)</span></td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>扫描了两次数组 arr ，一次数组 counts ，所以时间复杂度为 <span class="math inline">\(2*n+n+k\)</span> （扫描数组 counts 的时间复杂度是 <span class="math inline">\(n+k\)</span> ）。</p>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562543&amp;idx=1&amp;sn=c82892b85e1de790766896c6d80d7b3c&amp;chksm=f1fee96cc689607a11ccc109098d070d38ef0bad61c0390fe01348b631bbd492945b6f2b0601&amp;scene=0#rd">https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562543&amp;idx=1&amp;sn=c82892b85e1de790766896c6d80d7b3c&amp;chksm=f1fee96cc689607a11ccc109098d070d38ef0bad61c0390fe01348b631bbd492945b6f2b0601&amp;scene=0#rd</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>HeapSort</title>
    <url>/posts/acfcdb43/</url>
    <content><![CDATA[<p>在计算机科学中，<a href="https://en.wikipedia.org/wiki/Heapsort">堆排序（Heapsort）</a>是一种基于比较的排序算法。Heapsort 可以被认为是一种改进的选择排序：像该算法一样，它将输入分为排序区域和未排序区域，并通过提取最大元素并将其移动到排序区域来迭代缩小未排序区域。改进包括使用堆数据结构而不是线性时间搜索来找到最大值。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>传送门 <a href="https://wylu.github.io/posts/b098ffb0/">堆、堆排序、优先队列</a></p>
<h1 id="算法步骤">算法步骤</h1>
<ol type="1">
<li>由输入的无序数组构造一个最大堆，作为初始的无序区</li>
<li>把堆顶元素（最大值）和堆尾元素互换</li>
<li>把堆（无序区）的尺寸缩小 1 ，并调用 sinking 函数，目的是把新的数组顶端数据调整到相应位置</li>
<li>重复步骤 2 ，直到堆的尺寸为 1</li>
</ol>
<h1 id="算法图解">算法图解</h1>
<h2 id="构建二叉堆">构建二叉堆</h2>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让 <strong>所有非叶子节点依次下沉</strong>。</p>
<p>我们举一个无序完全二叉树的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1724bd872f56ec8038908ca3168449a7.png" alt="build-heap-1" /></p>
<p>首先，我们从最后一个 <strong>非叶子</strong> 节点开始，也就是从节点 10 开始。如果节点 10 大于它左右孩子中最小的一个，则节点 10 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0791e80a0f737a67cf51173957febfec.png" alt="build-heap-2" /></p>
<p>接下来轮到节点 3 ，如果节点 3 大于它左右孩子中最小的一个，则节点 3 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cb8de4abce5412cbc75bc968861097a3.png" alt="build-heap-3" /></p>
<p>接下来轮到节点 1 ，如果节点 1 大于它左右孩子中最小的一个，则节点 1 下沉。事实上节点 1 小于它的左右孩子，所以不用改变。</p>
<p>接下来轮到节点 7 ，如果节点 7 大于它左右孩子中最小的一个，则节点 7 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/73b585bfe5399235b51e231b9b05864f.png" alt="build-heap-4" /></p>
<p>节点 7 继续比较，继续下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b333df2de3d1b5beb758cbfe1fcb0100.png" alt="build-heap-5" /></p>
<p>至此，一颗无序的完全二叉树就构建成了一个最小堆。</p>
<h2 id="堆排序过程">堆排序过程</h2>
<p>堆排序是利用堆的自我调整实现的。</p>
<p>例如给定一个数组，对数组进行排序，使数组元素从小到大排列。</p>
<p>首先，我们要根据给定的数组构建一个最大堆。当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/46d1a244ee44e12fcc925979b6e855c9.png" alt="heap-sort-1" /></p>
<p>如上图所示，当删除值为 10 的堆顶节点，经过调节，值为 9 的新节点就会顶替上来；当删除值为 9 的堆顶节点，经过调节，值为 8 的新节点就会顶替上来.......</p>
<p>由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，过程如下：</p>
<p>删除节点 9 ，节点 8 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b36da4f918e0833d829aea49650e62be.png" alt="heap-sort-2" /></p>
<p>删除节点 8 ，节点 7 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e9d954428cf748b8f746b2ece6aaa9e0.png" alt="heap-sort-3" /></p>
<p>删除节点 7 ，节点 6 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ca393f170db61a79db470eb0202e26b1.png" alt="heap-sort-4" /></p>
<p>删除节点 6 ，节点 5 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/51642fd710a61b7c2f9a616d4075e737.png" alt="heap-sort-5" /></p>
<p>删除节点 5 ，节点 4 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f1f34f05a135c9b93bcad812e289229c.png" alt="heap-sort-6" /></p>
<p>删除节点 4 ，节点 3 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/48d21c88b2ba28591463cea703180e2a.png" alt="heap-sort-7" /></p>
<p>删除节点 3 ，节点 2 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/38e83142432bd28b58b1f07ed427e2ab.png" alt="heap-sort-8" /></p>
<p>至此，原本的最大堆已经变成了一个从小到大的有序集合。之前说过二叉堆实际存储在数组当中，数组中的元素排列如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/951b00a357a41f3f575d34d0f3785f61.png" alt="heap-sort-9" /></p>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f5f61a52a62f6f465444dd9bbdab8896.gif" alt="HeapSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap 需要调整的堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 需要下沉元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 需要下沉元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 当前堆的有效范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sinking</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> i, <span class="type">int</span> x, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>, b = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//定位到最大的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (b &lt; size &amp;&amp; heap[b] &gt; heap[a]) a = b;</span><br><span class="line">            <span class="comment">//如果当前节点大于等于最大孩子节点，说明调整完毕</span></span><br><span class="line">            <span class="keyword">if</span> (heap[a] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">            heap[i] = heap[a];</span><br><span class="line">            i = a;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 建堆数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sinking(arr, i, arr[i], arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//根据无序数组构建二叉堆</span></span><br><span class="line">        buildMaxHeap(arr);</span><br><span class="line">        <span class="comment">//循环删除堆顶元素，移到数组尾部，调节堆产生新的堆顶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//最后一个元素和堆顶元素交换</span></span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//下沉调整最大堆</span></span><br><span class="line">            sinking(arr, <span class="number">0</span>, arr[<span class="number">0</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>堆排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>In-place</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p>
<p><a href="https://blog.csdn.net/qq_32767041/article/details/83352265">https://blog.csdn.net/qq_32767041/article/details/83352265</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>堆 堆排序 优先队列</title>
    <url>/posts/b098ffb0/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆（Heap）</a>是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。</p>
<p>堆始于 <code>J._W._J._Williams</code> 在 1964 年发表的堆排序（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在 Dijkstra 等几种有效的图形算法中也非常重要。</p>
<p>堆是一种称为优先级队列的抽象数据类型的最有效实现，实际上优先级队列通常被称为“堆”，而不管它们如何实现。</p>
<span id="more"></span>
<h1 id="堆">堆</h1>
<p><strong>严格来说，堆也有不同的种类。本文所说的堆指的是二叉堆。</strong></p>
<p>二叉堆本质上是完全二叉树，可以分为两种类型：</p>
<ul>
<li>最大堆（大顶堆）</li>
<li>最小堆（小顶堆）</li>
</ul>
<p>二叉堆的根节点叫做 <strong>堆顶</strong>。最大堆和最小堆的特点，决定了在最大堆的堆顶是整个堆中的 <strong>最大元素</strong>；最小堆的堆顶是整个堆中的 <strong>最小元素</strong>。</p>
<h2 id="最大堆">最大堆</h2>
<p>最大堆任何一个父节点的值，都 <strong>大于等于</strong> 它左右孩子节点的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/521717bddecaf36adf5ea98e853134df.png" alt="maximum-heap" /></p>
<h2 id="最小堆">最小堆</h2>
<p>最小堆任何一个父节点的值，都 <strong>小于等于</strong> 它左右孩子节点的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8f6500b2418f7cd5f0be6361f9b284f0.png" alt="minimum-heap" /></p>
<h1 id="堆的逻辑结构与物理存储">堆的逻辑结构与物理存储</h1>
<p>二叉堆在逻辑上虽然是一颗完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组当中。</p>
<p><strong>树的节点是按从上到下、从左到右的顺序紧凑排列的。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c6da0344f179b625a33c1c5d32560203.png" alt="heap-struct" /></p>
<p>利用数组下标作为节点编号，假设父节点的下标是 parent，则有</p>
<ul>
<li>左儿子的下标 = 2 * parent + 1</li>
<li>右儿子的下标 = 2 * parent + 2</li>
</ul>
<h1 id="堆的操作">堆的操作</h1>
<p>对于堆，有两种主要操作：</p>
<ul>
<li><p><strong>插入节点 push</strong></p></li>
<li><p><strong>删除节点 pop</strong></p></li>
</ul>
<p>这两种操作都是基于堆的自我调整完成的。</p>
<h1 id="堆的操作的复杂度">堆的操作的复杂度</h1>
<p>堆的插入和删除两种操作所花的时间和树的深度正比。</p>
<p>因此，如果一共有 <span class="math inline">\(n\)</span> 个元素，那么堆的深度为 <span class="math inline">\(logn\)</span>，则每个操作可以在 <span class="math inline">\(O(logn)\)</span> 的时间完成。</p>
<h1 id="堆的自我调整">堆的自我调整</h1>
<p>以最小堆为例，看看堆是如何进行自我调整的：</p>
<h2 id="插入节点">插入节点</h2>
<p>二叉堆的节点插入，插入位置是完全二叉树的最后一个位置。比如我们插入一个新节点，值是 0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5a7af43b7d18cb1ba247d78cd4b61f1c.png" alt="insert-node-1" /></p>
<p>这时候，我们让节点 0 的它的父节点 5 做比较，如果 0 小于 5，则让新节点“上浮”，和父节点交换位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a6a256d2fca9a7a005c1891cb1e0b156.png" alt="insert-node-2" /></p>
<p>继续用节点 0 和父节点 3 做比较，如果 0 小于 3，则让新节点继续“上浮”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/217b18cb8505ed01c527a4e2e448d804.png" alt="insert-node-3" /></p>
<p>继续比较，最终让新节点 0 上浮到了堆顶位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/eff84b21a8c17bde7377fcf7a0cb152a.png" alt="insert-node-4" /></p>
<h2 id="删除节点">删除节点</h2>
<p>二叉堆的节点删除过程和插入过程相反，所删除的是处于堆顶的节点。比如我们删除最小堆的堆顶节点 1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b24655b6b55936c03e2e246e80f925d3.png" alt="delete-node-1" /></p>
<p>这时候，为了维持完全二叉树的结构，我们把堆的最后一个节点 10 补到原本堆顶的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b98863c4949209f60930f016c037784a.png" alt="delete-node-2" /></p>
<p>接下来我们让移动到堆顶的节点 10 和它的左右孩子进行比较，如果左右孩子中最小的一个（显然是节点 2 ）比节点 10 小，那么让节点 10 “下沉”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/859145dedd356dff5e22b89dcb107d54.png" alt="delete-node-3" /></p>
<p>继续让节点 10 和它的左右孩子做比较，左右孩子中最小的是节点 7 ，由于 10 大于 7 ，让节点 10 继续“下沉”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/950bd2e5adb40edeb84bba0470a70400.png" alt="delete-node-4" /></p>
<p>这样一来，堆重新得到了调整。</p>
<p>从上面的分析可知，显然不管是插入还是删除操作，堆的自我调整都与深度成正比，故时间复杂度为 <span class="math inline">\(O(logn)\)</span>。</p>
<h2 id="参考实现">参考实现</h2>
<p>最小堆参考实现，最大堆类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumHeap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a heap of specified capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapMaxSize The maximum capacity of the initialization heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinimumHeap</span><span class="params">(<span class="type">int</span> heapMaxSize)</span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">int</span>[heapMaxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * floating</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i Index of its own node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The value to insert</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">floating</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//父节点的索引下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果已经没有大小颠倒则退出</span></span><br><span class="line">            <span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//把父亲节点的数值放下来，而把自己提上去</span></span><br><span class="line">            heap[i] = heap[p];</span><br><span class="line">            i = p;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sinking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The value to move to the root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sinking</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">            <span class="comment">//比较子节点的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; size &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line">            <span class="comment">//如果已经没有大小颠倒则退出</span></span><br><span class="line">            <span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//把子节点的数值提上来</span></span><br><span class="line">            heap[i] = heap[a];</span><br><span class="line">            i = a;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        floating(size++, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        sinking(heap[--size]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">MinimumHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinimumHeap</span>(arr.length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) heap.push(e);</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            System.out.print(heap.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Output: -5 -4 -2 1 2 3 7 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序">堆排序</h1>
<h2 id="构建二叉堆">构建二叉堆</h2>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让 <strong>所有非叶子节点依次下沉</strong>。</p>
<p>我们举一个无序完全二叉树的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1724bd872f56ec8038908ca3168449a7.png" alt="build-heap-1" /></p>
<p>首先，我们从最后一个 <strong>非叶子</strong> 节点开始，也就是从节点 10 开始。如果节点 10 大于它左右孩子中最小的一个，则节点 10 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0791e80a0f737a67cf51173957febfec.png" alt="build-heap-2" /></p>
<p>接下来轮到节点 3 ，如果节点 3 大于它左右孩子中最小的一个，则节点 3 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cb8de4abce5412cbc75bc968861097a3.png" alt="build-heap-3" /></p>
<p>接下来轮到节点 1 ，如果节点 1 大于它左右孩子中最小的一个，则节点 1 下沉。事实上节点 1 小于它的左右孩子，所以不用改变。</p>
<p>接下来轮到节点 7 ，如果节点 7 大于它左右孩子中最小的一个，则节点 7 下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/73b585bfe5399235b51e231b9b05864f.png" alt="build-heap-4" /></p>
<p>节点 7 继续比较，继续下沉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b333df2de3d1b5beb758cbfe1fcb0100.png" alt="build-heap-5" /></p>
<p>至此，一颗无序的完全二叉树就构建成了一个最小堆。</p>
<h2 id="堆排序过程">堆排序过程</h2>
<p>堆排序是利用堆的自我调整实现的。</p>
<p>例如给定一个数组，对数组进行排序，使数组元素从小到大排列。</p>
<p>首先，我们要根据给定的数组构建一个最大堆。当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/46d1a244ee44e12fcc925979b6e855c9.png" alt="heap-sort-1" /></p>
<p>如上图所示，当删除值为 10 的堆顶节点，经过调节，值为 9 的新节点就会顶替上来；当删除值为 9 的堆顶节点，经过调节，值为 8 的新节点就会顶替上来.......</p>
<p>由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，过程如下：</p>
<p>删除节点 9 ，节点 8 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b36da4f918e0833d829aea49650e62be.png" alt="heap-sort-2" /></p>
<p>删除节点 8 ，节点 7 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e9d954428cf748b8f746b2ece6aaa9e0.png" alt="heap-sort-3" /></p>
<p>删除节点 7 ，节点 6 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ca393f170db61a79db470eb0202e26b1.png" alt="heap-sort-4" /></p>
<p>删除节点 6 ，节点 5 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/51642fd710a61b7c2f9a616d4075e737.png" alt="heap-sort-5" /></p>
<p>删除节点 5 ，节点 4 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f1f34f05a135c9b93bcad812e289229c.png" alt="heap-sort-6" /></p>
<p>删除节点 4 ，节点 3 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/48d21c88b2ba28591463cea703180e2a.png" alt="heap-sort-7" /></p>
<p>删除节点 3 ，节点 2 成为新堆顶：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/38e83142432bd28b58b1f07ed427e2ab.png" alt="heap-sort-8" /></p>
<p>至此，原本的最大堆已经变成了一个从小到大的有序集合。之前说过二叉堆实际存储在数组当中，数组中的元素排列如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/951b00a357a41f3f575d34d0f3785f61.png" alt="heap-sort-9" /></p>
<h2 id="算法步骤">算法步骤</h2>
<ul>
<li>根据无序数组构建二叉堆</li>
<li>循环删除堆顶元素，移到数组尾部，调节堆产生新的堆顶</li>
</ul>
<h2 id="参考实现-1">参考实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumHeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sinking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap The Heap to be adjusted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i The index of value which need to be sunk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The value to be sunk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size The current valid size of heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sinking</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> i, <span class="type">int</span> x, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//定位到最大的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span>(b &lt; size &amp;&amp; heap[b] &gt; heap[a]) a = b;</span><br><span class="line">            <span class="comment">//如果当前节点大于等于最大孩子节点，说明调整完毕</span></span><br><span class="line">            <span class="keyword">if</span>(heap[a] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">            heap[i] = heap[a];</span><br><span class="line">            i = a;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build a heap according to an array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr An array to form a heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            sinking(arr, i, arr[i], arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Heap sort</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr Unsorted array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//根据无序数组构建二叉堆</span></span><br><span class="line">        buildHeap(arr);</span><br><span class="line">        <span class="comment">//循环删除堆顶元素，移到数组尾部，调节堆产生新的堆顶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//最后一个元素和堆顶元素交换</span></span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//下沉调整最大堆</span></span><br><span class="line">            sinking(arr, <span class="number">0</span>, arr[<span class="number">0</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        MaximumHeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序的复杂度">堆排序的复杂度</h2>
<ul>
<li><p>空间复杂度</p>
<p>因为没有开辟额外的集合空间，所以空间复杂度为 <span class="math inline">\(O(1)\)</span></p></li>
<li><p>时间复杂度</p>
<p>堆排序所需要的时间主要有两部分组成，一是构建二叉堆的时间，二是循环删除并进行堆维护的时间。</p>
<ul>
<li><p>第一步，把无序数组构建成二叉堆，需要进行 <span class="math inline">\(n/2\)</span> 次循环。每次循环调用一次 sinking 方法，所以第一步的计算规模是 <span class="math inline">\((n/2) * logn\)</span>，时间复杂度 <span class="math inline">\(O(nlogn)\)</span>。</p>
<blockquote>
<p>这里只是初略地把每个非叶子节点下沉的时间复杂度都当成 <span class="math inline">\(O(logn)\)</span> ，事实上经过严格的证明构建堆的时间复杂是 <span class="math inline">\(O(n)\)</span> ，但这里我们初略算出的复杂度为 <span class="math inline">\(O(nlogn)\)</span> ，当然我们算出的复杂度也是正确的，只不过是不够精确而已。</p>
<p><span class="math inline">\(O(n)\)</span> 的证明也比较简单，可以参考：</p>
<p><a href="https://blog.csdn.net/LinuxTiger/article/details/7172258">https://blog.csdn.net/LinuxTiger/article/details/7172258</a></p>
</blockquote></li>
<li><p>第二步，需要进行 <span class="math inline">\(n-1\)</span> 次循环。每次循环调用一次 sinking 方法，所以第二步的计算规模是 <span class="math inline">\((n-1)*logn\)</span> ，时间复杂度 <span class="math inline">\(O(nlogn)\)</span> 。</p></li>
</ul>
<p>总的时间复杂度为： <span class="math display">\[
O(n) + O(nlogn) = O(nlogn)
\]</span></p></li>
</ul>
<h2 id="堆排序和快排对比">堆排序和快排对比</h2>
<table>
<thead>
<tr class="header">
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>堆排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="even">
<td>快速排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(logn) \sim O(n)\)</span></td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<ul>
<li>相同点
<ul>
<li>堆排序和快速排序的平均时间复杂度都是 <span class="math inline">\(O(nlogn)\)</span></li>
<li>两者都是不稳定的排序</li>
<li>快速排序因为递归所以需要额外的空间开销 <span class="math inline">\(O(logn) \sim O(n)\)</span> ；堆排序是就地排序，空间复杂度 <span class="math inline">\(O(1)\)</span></li>
</ul></li>
<li>不同点
<ul>
<li>堆排序在最好、最坏、平均情况下时间复杂度都是 <span class="math inline">\(O(nlogn)\)</span> ；快排在最坏情况下是 <span class="math inline">\(O(n^2)\)</span> ，最好情况下是 <span class="math inline">\(O(nlogn)\)</span></li>
</ul></li>
</ul>
<h1 id="优先队列">优先队列</h1>
<h2 id="优先队列种类">优先队列种类</h2>
<p>优先队列不再遵循队列先入先出 (FIFO) 的原则，而是分为两种情况：</p>
<ul>
<li><strong>最大优先队列，无论入队顺序，当前最大的元素优先出队。</strong></li>
<li><strong>最小优先队列，无论入队顺序，当前最小的元素优先出队。</strong></li>
</ul>
<p>比如有一个最大优先队列，它的最大元素是 8 ，那么虽然元素 8 并不是队首元素，但出队的时候仍然让元素 8 首先出队：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/aca2b3103b4a7d216b4f9d8842fc8741.png" alt="max-priority" /></p>
<p>要满足以上需求，利用线性数据结构并非不能实现，但是时间复杂度较高，最坏时间复杂度 <span class="math inline">\(O(n)\)</span>，并不是最理想的方式。</p>
<h2 id="利用堆的特性实现优先队列">利用堆的特性实现优先队列</h2>
<p>堆的特性：</p>
<ul>
<li>最大堆的堆顶是整个堆中的最大元素</li>
<li>最小堆的堆顶是整个堆中的最小元素</li>
</ul>
<p>因此，可以用最大堆来实现最大优先队列，最小堆实现最小优先队列。</p>
<p>例如，利用最大堆实现优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p>
<h3 id="入队操作">入队操作</h3>
<p>插入新节点 5</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1453b834fa13364850369c2208a50ebb.png" alt="queue-push-1" /></p>
<p>新节点 5 上浮到合适位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8cd301ed63dbdab28e7b4d0ea91db56d.png" alt="queue-push-2" /></p>
<h3 id="出队操作">出队操作</h3>
<p>把原堆顶节点 10 “出队”</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2f1c78c35c28c8bff505bf021fe6471b.png" alt="queue-pop-1" /></p>
<p>最后一个节点 1 替换到堆顶位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a8fbf13ff7a16a6625ccef5a51a0b48b.png" alt="queue-pop-2" /></p>
<p>节点1下沉，节点 9 成为新堆顶</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a074669d494a4b18c5e819976f4c1ae7.png" alt="queue-pop-3" /></p>
<h2 id="优先队列的时间复杂度">优先队列的时间复杂度</h2>
<p>因为二叉堆节点上浮和下沉的时间复杂度都是 <span class="math inline">\(O(logn)\)</span> ，所以优先队列入队和出队的时间复杂度也是 <span class="math inline">\(O(logn)\)</span></p>
<h2 id="参考实现-2">参考实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty queue with the default capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">int</span>[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty queue with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity the initial capacity of the queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.queue = (capacity &gt; <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">int</span>[capacity] : <span class="keyword">new</span> <span class="title class_">int</span>[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * floating</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i Index of its own node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The value to insert</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">floating</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(queue[p] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line">            queue[i] = queue[p];</span><br><span class="line">            i = p;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[i] =  x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sinking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The value to move to the root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sinking</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>, b = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; size &amp;&amp; queue[b] &gt; queue[a]) a = b;</span><br><span class="line">            <span class="keyword">if</span>(queue[a] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">            queue[i] = queue[a];</span><br><span class="line">            i = a;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of the queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = Arrays.copyOf(<span class="built_in">this</span>.queue, <span class="built_in">this</span>.size * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == queue.length) resize();</span><br><span class="line">        floating(size++, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue[<span class="number">0</span>];</span><br><span class="line">        sinking(queue[--size]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">front</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) queue.push(e);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            System.out.print(queue.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">https://en.wikipedia.org/wiki/Heap_(data_structure)</a></p>
<p><a href="https://mp.weixin.qq.com/s/23CwW5eSv-lI6vaZHzSwhQ">https://mp.weixin.qq.com/s/23CwW5eSv-lI6vaZHzSwhQ</a></p>
<p><a href="https://mp.weixin.qq.com/s/PWuuChodYGMr8iJzW2VW9Q">https://mp.weixin.qq.com/s/PWuuChodYGMr8iJzW2VW9Q</a></p>
<p><a href="https://mp.weixin.qq.com/s/CdK1l2kB3aCUtBORjS4DVQ">https://mp.weixin.qq.com/s/CdK1l2kB3aCUtBORjS4DVQ</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stack-and-queue</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>priority-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort</title>
    <url>/posts/c96e6ef1/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Quicksort">快速排序（Quicksort）</a>，又称分区交换排序（partition-exchange sort），简称快排，是一种高效的排序算法。由英国计算机科学家 Tony Hoare 于 1959 年开发并于 1961 年发表，至今它仍然是一种常用的排序算法。事实上，如果实施得当，它可以比归并排序、堆排序快两到三倍。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>快速排序是图灵奖得主 <a href="http://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE">C. R. A. Hoare</a> 于 1960 年提出的一种划分交换排序，它采用了一种分治的策略，通常称其为 <a href="http://en.wikipedia.org/wiki/Quicksort">分治法(Divide-and-ConquerMethod)</a>。</p>
<p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地求解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
<h1 id="算法步骤">算法步骤</h1>
<ol type="1">
<li>从序列中挑出一个元素，作为"基准" (pivot)</li>
<li>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准值的后面（相同的数可以放到任一边），这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序，直到所有子序列的大小为 0 或 1，这时整体已经排好序了</li>
</ol>
<h1 id="算法图解">算法图解</h1>
<p>传送门 <a href="http://developer.51cto.com/art/201403/430986.htm">坐在马桶上看算法：快速排序</a></p>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/90fb5f9dd147f5acbb04419c8c8b4ac0.gif" alt="QuickSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right, pivot = arr[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[i];</span><br><span class="line">        arr[i] = pivot;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            recursiveSort(arr, left, idx - <span class="number">1</span>);</span><br><span class="line">            recursiveSort(arr, idx + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nonRecursiveSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(left);</span><br><span class="line">        stack.push(right);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            right = stack.pop();</span><br><span class="line">            left = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">                stack.push(left);</span><br><span class="line">                stack.push(idx - <span class="number">1</span>);</span><br><span class="line">                stack.push(idx + <span class="number">1</span>);</span><br><span class="line">                stack.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//        QuickSort.recursiveSort(arr, 0, arr.length - 1);</span></span><br><span class="line">        QuickSort.nonRecursiveSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>partition的另一种写法，选取最右元素作为基准</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[right]) swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++j, right);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>快速排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(logn) \sim O(n)\)</span></td>
<td>In-place</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a></p>
<p><a href="http://developer.51cto.com/art/201403/430986.htm">http://developer.51cto.com/art/201403/430986.htm</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>MergeSort</title>
    <url>/posts/be59dafc/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Merge_sort">归并排序（Merge sort）</a>，是创建在归并操作上的一种基于比较的排序算法。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>归并排序算法是分治策略实现对 n 个元素进行排序的算法。</p>
<p>其基本思想是：将待排序元素分成大小大致相同的 2 个子集合，分别对 2 个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。</p>
<h1 id="算法步骤">算法步骤</h1>
<ol type="1">
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h1 id="算法图解">算法图解</h1>
<p>参考 dreamcatcher-cx 博客 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a></p>
<p>采用经典的分治（divide-and-conquer）策略（分治法将问题分解成规模更小、解法相同的子问题，然后通过子问题的解构造出原问题的解)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1c4291f66d3badeecf8da5db0fa7f258.png" alt="divide-and-conquer" /></p>
<p>分阶段是递归拆分子序列的过程，递归深度为 <span class="math inline">\(log_2 n\)</span>.</p>
<p>对于治阶段，需要将两个已经有序的子序列合并成一个有序序列，例如上图中的最后一次合并，要将 [4,5,7,8] 和 [1,2,3,6] 两个已经有序的子序列，合并为最终序列 [1,2,3,4,5,6,7,8] ，具体实现步骤如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9dd09eee984f8c7cc06470fe6bc9cbc3.png" alt="merge-1" /> <img src="https://cdn.jsdelivr.net/gh/wylu/img/1ccc14e8d728905f4b80ae1478e1e625.png" alt="merge-2" /></p>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b99460f4173a23f9ed1be77f2f9fd224.gif" alt="MergeSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) tmp[t++] = (arr[i] &lt;= arr[j]) ? arr[i++] : arr[j++];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) tmp[t++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) tmp[t++] = arr[j++];</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) arr[left++] = tmp[t++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] tmp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            recursiveSort(arr, left, mid, tmp);</span><br><span class="line">            recursiveSort(arr, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">            merge(arr, left, mid, right, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nonRecursiveSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>; size &lt; arr.length; size *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left, mid, right;</span><br><span class="line">            <span class="keyword">for</span> (left = <span class="number">0</span>; left + size &lt; arr.length; left = right + <span class="number">1</span>) &#123;</span><br><span class="line">                mid = left + size - <span class="number">1</span>;</span><br><span class="line">                right = Math.min(mid + size, arr.length - <span class="number">1</span>);</span><br><span class="line">                merge(arr, left, mid, right, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//        MergeSort.recursiveSort(arr, 0, arr.length - 1, new int[arr.length]);</span></span><br><span class="line">        MergeSort.nonRecursiveSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>归并排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>ShellSort</title>
    <url>/posts/84f0663c/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Shellsort">希尔排序（Shellsort）</a>，是一种就地比较排序。它可以被看作是交换排序(冒泡排序)或插入排序(插入排序)的泛化。该方法首先对彼此相距很远的元素对进行排序，然后逐步缩小要比较的元素之间的差距。从距离较远的元素开始，它可以比简单的最近邻交换更快地将一些不合适的元素移动到位。1959 年，Donald Shell 出版了第一个版本。Shellsort 的运行时间严重依赖于它使用的间隙序列。对于许多实际的变体，确定它们的时间复杂度仍然是一个悬而未决的问题。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>希尔排序，也称 <strong>缩小增量排序</strong>，是插入排序的一种更高效的改进版本，是 <strong>不稳定</strong> 的排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出的改进方法：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<h1 id="算法步骤">算法步骤</h1>
<ul>
<li>选择增量 gap = length/2，以 gap = gap/2 的方式缩小增量，用序列表示为 {n/2, (n/2)/2, ..., 1}</li>
<li>按增量序列个数 k，对序列进行 k 趟排序</li>
<li>每趟排序，根据对应的增量 gap，将待排序列分割成 gap 个长度子序列，分别对各子序列进行直接插入排序。</li>
<li>当增量 gap 为 1 时，对整个序列进行插入排序。</li>
</ul>
<h1 id="算法图解">算法图解</h1>
<p>图片来源 dreamcatcher-cx 博客 <a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c52e08027910d98f78ee1d225cf03a8b.png" alt="ShellSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用希尔增量序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//从第gap个元素开始，逐个对其所在的子序列进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, tmp = arr[i];</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= gap &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Knuth增量序列</span></span><br><span class="line"><span class="comment">     * Knuth增量序列递推式：h(1) = 1, h(i) = 3 * h(i-1) + 1</span></span><br><span class="line"><span class="comment">     * Hibbard增量序列递推式：h(1) = 1, h(i) = 2 * h(i-1) + 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">knuthSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &lt; arr.length) &#123;</span><br><span class="line">            gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, tmp = arr[i];</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= gap &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = (gap - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//        ShellSort.shellSort(arr);</span></span><br><span class="line">        ShellSort.knuthSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>希尔排序</td>
<td><span class="math inline">\(O(nlogn) \sim O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^{1.3})\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>In-place</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">6. References</h1>
<p><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
<p><a href="https://blog.csdn.net/Foliciatarier/article/details/53891144">https://blog.csdn.net/Foliciatarier/article/details/53891144</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>InsertSort</title>
    <url>/posts/743f83de/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">插入排序（Insertion Sort）</a>是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>每步将一个待排序的元素，将其插入前面已排好序的部分中，直到全部插入完为止。</p>
<h1 id="算法步骤">算法步骤</h1>
<ol type="1">
<li>将待排序序列第一个元素看做已排序序列，把第二个元素到最后一个元素当成是未排序序列</li>
<li>从未排序序列中取出下一个元素记为 a，在已排序的序列中从后向前扫描</li>
<li>如果该元素（已排序）大于 a，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于 a 的位置</li>
<li>将 a 插入到该位置后</li>
<li>重复步骤 2~5，直至没有未排序元素</li>
</ol>
<h1 id="动画演示">动画演示</h1>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ffda0249330d775e6fd3488f198c5c43.gif" alt="InsertSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">1</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp; j--) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        InsertSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>In-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>SelectSort</title>
    <url>/posts/abf7fe9b/</url>
    <content><![CDATA[<p>在计算机科学中，<a href="https://en.wikipedia.org/wiki/Selection_sort">选择排序（Selection sort）</a>是一种排序算法，切确的说是就地比较排序。它具有 <span class="math inline">\(O(n^2)\)</span> 时间复杂度，使其在大型列表上效率低下，并且通常比类似的插入排序更差。选择排序因其简单性而着称，并且在某些情况下具有优于更复杂算法的性能优势，特别是在辅助存储器有限的情况下。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>初始时在序列中找到最小（大）元素，放到序列的起始（末尾）位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的尾部（首部）。以此类推，直到所有元素均排序完毕。</p>
<h1 id="算法步骤">算法步骤</h1>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的尾部（首部）。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h1 id="动画演示">动画演示</h1>
<p>以找最小元素为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f37e5468225dff6e2edd0d9bec3778a2.gif" alt="SelectSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一轮选择最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxSelectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxIdx</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[maxIdx]) &#123;</span><br><span class="line">                    maxIdx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, maxIdx, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一轮选择最小元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minSelectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                    minIdx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, minIdx, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        SelectSort.maxSelectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">12</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">25</span>, -<span class="number">1</span>, <span class="number">0</span> , <span class="number">17</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        SelectSort.minSelectSort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>选择排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>In-place</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Selection_sort">https://en.wikipedia.org/wiki/Selection_sort</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>BubbleSort</title>
    <url>/posts/b3a07667/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Bubble_sort">冒泡排序（Bubble Sort）</a> 是一种简单的排序算法，它重复遍历列表，比较相邻的两个元素，如果它们的顺序错误则交换它们。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>依次比较相邻的两个元素，如果相邻的两个元素的顺序是错误的，则将它们交换，直至没有元素需要交换，排序完成。</p>
<p>在实现上有两种方法：</p>
<ul>
<li>每一轮让未排序的最大元素交换到正确位置，以下称之为"最大冒泡"</li>
<li>每一轮让未排序的最小元素交换到正确位置，以下称之为"最小冒泡"</li>
</ul>
<h1 id="算法步骤">算法步骤</h1>
<p>以最大冒泡为例：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数，是已排序的。</li>
<li>对剩下所有未排序的元素重复以上步骤，直至所有元素都是已排序的。</li>
</ul>
<h1 id="动画演示">动画演示</h1>
<p>以最小冒泡为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e1a5e701ab13aa61112dcf0d7732e929.gif" alt="BubbleSort" /></p>
<h1 id="参考实现">参考实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大冒泡，每轮的交换都是从左往右进行的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxBubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小冒泡，每轮的交换都是从右往左进行的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minBubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        BubbleSort.maxBubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">12</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">25</span>, -<span class="number">1</span>, <span class="number">0</span> , <span class="number">17</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        BubbleSort.minBubbleSort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析">复杂度分析</h1>
<table>
<thead>
<tr class="header">
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>In-place</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p>
<p><a href="https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80">https://youliao.163yun.com/api-server/rss/xiaomi/item/IN2WDOMKAWVNTZV.html?ref=browser_news&amp;s=mb&amp;cp=cn-netease-youliao-browser&amp;docid=44797c69e120935b2c4790d933d02a9b&amp;itemtype=news&amp;cateCode=rec&amp;category=%E7%A7%91%E6%8A%80</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/posts/caff8000/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bab29d94280b344e35ccc4d058d82fcd.png" alt="git-logo" /></p>
<p>一些 git 常用命令总结。</p>
<span id="more"></span>
<h1 id="仓库管理">仓库管理</h1>
<h2 id="clone-远程仓库">Clone 远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo url&gt;</span><br></pre></td></tr></table></figure>
<p>url 有两种：</p>
<ul>
<li><code>https://github.com/username/reponame.git</code></li>
<li><code>git@github.com:username/reponame.git</code></li>
</ul>
<h2 id="clone-远程仓库指定分支">Clone 远程仓库指定分支</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b &lt;remote branch name&gt; &lt;repo url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="clone-含子模块的仓库">Clone 含子模块的仓库</h2>
<p>若需要克隆含有子模块的仓库，直接进行克隆无法拉取子模块的代码，可加上 <strong><code>--recursive</code></strong> 参数，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recursive &lt;repo url&gt;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo url&gt;</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<h2 id="查看已添加的远程仓库">查看已添加的远程仓库</h2>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p>
<h2 id="查看远程仓库的信息">查看远程仓库的信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote show &lt;repo name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库">添加远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;repo name&gt; &lt;repo url&gt;</span><br></pre></td></tr></table></figure>
<p><code>repo name</code> 为远程仓库的本地名称，可自定义，相当于给 url 对应的仓库起了个别名，对于 <code>git clone</code> 的仓库在本地的名称默认为 <code>origin</code></p>
<h2 id="删除远程仓库">删除远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;repo name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改远程仓库">修改远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url [--push|--add|--delete] &lt;repo name&gt; &lt;new url&gt; [&lt;old url&gt;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可选项：</span><br><span class="line">--push                manipulate push URLs</span><br><span class="line">--add                 add URL</span><br><span class="line">--delete              delete URLs</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/reponame.git</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库">拉取远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull [&lt;repo name&gt; &lt;branch name&gt;]</span><br></pre></td></tr></table></figure>
<p>这里的 <code>repo name</code> 和 <code>branch name</code> 都是远程的</p>
<h2 id="推送远程仓库">推送远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push [&lt;repo name&gt; &lt;branch name&gt;]</span><br></pre></td></tr></table></figure>
<p>这里的 <code>repo name</code> 是远程的， <code>branch name</code> 为本地分支名</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h1 id="分支管理">分支管理</h1>
<h2 id="查看分支">查看分支</h2>
<h3 id="查看本地分支">查看本地分支</h3>
<p>前面有 "*" 标记的为当前所在分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h3 id="查看远程分支">查看远程分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<h3 id="查看所有分支">查看所有分支</h3>
<p>查看所有分支，包括本地的和远程的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h2 id="删除分支">删除分支</h2>
<h3 id="删除远程分支">删除远程分支</h3>
<p>推送一个空分支以删除远程分支，本地分支依然存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;repo name&gt; :&lt;remote branch name&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;repo name&gt; --delete &lt;remote branch name&gt;</span><br></pre></td></tr></table></figure>
<p><code>repo name</code> 为仓库的本地别名，默认为 <code>origin</code></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :develop</span><br></pre></td></tr></table></figure>
<h3 id="删除本地分支">删除本地分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 选项只能删除已参与了合并的分支，对于未合并的分支是无法删除的，如果想强制删除一个分支，可以使用 <code>-D</code> 选项。</p>
<h2 id="切换分支">切换分支</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建分支">创建分支</h2>
<h3 id="创建本地分支">创建本地分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch &lt;Branch Name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建本地分支并切换到新分支">创建本地分支并切换到新分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建远程分支">创建远程分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push [-u] &lt;repo name&gt; &lt;local branch name&gt;:&lt;remote branch name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p>提交本地 dev 分支作为远程的 develop 分支，实际应用中 <strong>应该保持本地分支名称与远程分支名称一致</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin dev:develop</span><br></pre></td></tr></table></figure>
<p>如果本地分支名称与远程分支名称不一致，在 <code>git push</code> 时会有如下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push</span></span><br><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD:develop</span><br><span class="line"></span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin dev</span><br><span class="line"></span><br><span class="line">To choose either option permanently, see push.default in &#x27;git help config&#x27;.</span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用 <code>git push origin HEAD:develop</code> ，则会将当前 HEAD 指向的 dev 分支 push 到远程的 develop 分支</li>
<li>如果使用 <code>git push origin dev</code> ，则会在远程仓库中创建一个名为 "dev" 的新分支（如果原先不存在），并将当前本地的 dev 分支推送到远程的 dev 分支</li>
<li>如果推送时使用 <code>-u</code> 选项，Git 不但会把本地的 <code>dev</code> 分支内容推送的远程新的 <code>develop</code> 分支，还会把本地的 <code>dev</code> 分支和远程的 <code>develop</code> 分支关联起来，以后在推送或者拉取时就可以使用简化命令 <code>git push|pull</code>。</li>
</ul>
<h2 id="关联本地分支与远程分支">关联本地分支与远程分支</h2>
<p>如果已添加远程仓库，但是本地分支与远程分支没有关联，使用 <code>git pull</code> 会导致失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p>错误提示也给出解决方法：</p>
<p>方法一：指定要拉取的仓库的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull &lt;repo name&gt; &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>这里我把 <code>remote</code> 写成 <code>repo name</code> 是为了与上面保持一致，其含义也是相同的，都是表示远程仓库在本地的别名。<strong>一般而言，远程远程仓库名为项目名称，而在本地代表该仓库的名称默认为"origin"</strong></p>
<p>方法二：关联本地分支与远程分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=&lt;repo name&gt;/&lt;remote branch name&gt; &lt;local branch name&gt;</span><br></pre></td></tr></table></figure>
<p>在关联本地分支与远程分支之后，就不用每次都指定仓库名和分支名了，只需执行 <code>git pull</code></p>
<h2 id="查看本地分支与远程分支的跟踪关系">查看本地分支与远程分支的跟踪关系</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<p>可看到当前分支与对应的远程关联分支</p>
<h2 id="合并分支">合并分支</h2>
<h3 id="合并本地分支">合并本地分支</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：将 "dev" 分支合并到当前分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<h3 id="合并远程分支">合并远程分支</h3>
<ul>
<li><p>先检出仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>默认为 master 分支，然后查看全部的远程分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -r</span></span><br><span class="line">  origin/develop</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支，要合并到哪个分支就切换到哪个分支</p>
<p>如果要合并到 master 分支，就不用切换</p></li>
<li><p>合并分支</p>
<p>例如：将远程的 develop 分支合并到 master 分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge origin/develop</span><br></pre></td></tr></table></figure></li>
<li><p>推送合并后的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分支重命名">分支重命名</h2>
<h3 id="本地分支重命名">本地分支重命名</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;old name&gt; &lt;new name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="远程分支重命名">远程分支重命名</h3>
<ul>
<li><p>重命名远程分支对应的本地分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;old name&gt; &lt;new name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --delete &lt;origin&gt; &lt;old name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>上传新命名的本地分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;origin&gt; &lt;new name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>把修改后的本地分支与远程分支关联</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=&lt;origin&gt;/&lt;new name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="工作现场的保存与恢复">工作现场的保存与恢复</h2>
<h3 id="分支修改相互影响">分支修改相互影响</h3>
<p>现象：</p>
<p>假设当前有两个分支，一个 master 分支，一个 dev 分支。 master 分支的工作区和暂存区( stage )是干净的，也即 <code>nothing to commit, working tree clean</code>， dev 分支由 master 分支 checkout 并创建得到。假设此时在 dev 分支下创建一个文件 <code>touch abc.txt</code> ，然后切回 master 分支，会发现 master 分支下的工作区也包含该文件。</p>
<p>原因：</p>
<p>git 切换分支时会把未 add 或未 commit 的内容带过去。未 add 的内容不属于任何一个分支，未 commit 的内容也不属于任何一个分支，也就是说，对于所有分支而言，工作区和暂存区都是共享的。未 add 的内容会存放在工作区，已 add 且未 commit 的内容会存放在暂存区( stage )，对于 add 后已 commit 的内容独立存放当前分支。</p>
<p>解决方法：</p>
<p>总的来说，只要保证工作区和暂存区是干净的就可以了。</p>
<p>具体来说通常有以下两种方法：</p>
<ul>
<li>使用 <code>git add</code> 和 <code>git commit</code> 提交修改，那么此时使用 <code>git status</code> 检查工作区和暂存区就是干净的</li>
<li>如果当前分支上的工作还未完成或者还不能提交，但又需要去修改其它分支的，这时可以把当前分支的工作现场保存起来。使用 <code>git stash</code> 可以保存当前暂存区的内容，此时使用 <code>git status</code> 检查工作区和暂存区就是干净的，详情查看工作现场的保存与恢复。</li>
</ul>
<h3 id="保存工作现场">保存工作现场</h3>
<p><code>git stash</code> 可以保存当前工作现场，实际上是保存当前暂存区( stage )的内容，对于未 add (未跟踪)的文件的修改不会保存(不会隐藏)。stash 功能，可以让我们暂时放下当前分支的工作，转而切换到另一分支进行其它工作，在完成其它分支工作后，可以切回该分支恢复现场继续未完成的工作。</p>
<p><strong>注意：如果当前分支中，不存在未 add 的文件，执行 <code>git stash</code> 保存工作现场后，此时使用 <code>git status</code> 检查工作区和暂存区就是干净的，如果存在未 add 的文件，那么工作区是不干净的而暂存区是干净的。</strong></p>
<p>举例来说，如果修改发生在新文件中且已 add，那么 <code>git stash</code> 后工作区将不会看到该新文件；如果修改发生在新文件中且未 add ，那么 <code>git stash</code> 不会对该文件进行任何操作，该文件依然在工作区中可见。</p>
<p><strong>可以多次 stash ，包括同一分支多次 stash ，不同分支多次 stash。</strong></p>
<h3 id="查看保存的工作现场">查看保存的工作现场</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<h3 id="恢复工作现场">恢复工作现场</h3>
<p>恢复现场有两种方法：</p>
<ul>
<li>使用 <code>git stash apply</code> 恢复，但是恢复后，stash 内容并不删除，需要用 <code>git stash drop</code> 来删除</li>
<li>使用 <code>git stash pop</code> ，恢复的同时把 stash 内容删除，这时用 <code>git stash list</code> 就看不到已经 pop 了的工作现场了</li>
</ul>
<p>恢复的时候，先用 <code>git stash list</code> 查看，然后用 <code>git stash apply &lt;stash@&#123;id&#125;&gt;</code> 或者 <code>git stash pop &lt;stash@&#123;id&#125;&gt;</code> 恢复指定的 stash ，例如 <code>git stash apply stash@&#123;0&#125;</code></p>
<h1 id="标签管理">标签管理</h1>
<p><a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Basics - Tagging</a></p>
<p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、 v2.0 等等）。</p>
<h2 id="列出标签">列出标签</h2>
<p>在 Git 中列出已有的标签只需要输入 <code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure>
<p>可以按照特定的模式查找标签。例如，如果只对 1.8.5 系列感兴趣，可以运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&quot;v1.8.5*&quot;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure>
<h2 id="创建标签">创建标签</h2>
<p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p>
<p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p>
<h3 id="annotated-tags-附注标签">Annotated Tags 附注标签</h3>
<p>使用 <code>git tag</code> 命令创建附注标签时需要指定 <code>-a</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h3 id="lightweight-tags-轻量标签">Lightweight Tags 轻量标签</h3>
<p>轻量标签本质上是将 commit checksum 存储到一个文件中，没有保存任何其他信息。创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure>
<p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。命令只会显示出提交信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<h2 id="后期打标签">后期打标签</h2>
<p>你也可以对过去的提交打标签。假设提交历史是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure>
<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 "updated rakefile" 提交。你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure>
<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.2</span></span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="共享标签">共享标签</h2>
<p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样，你可以运行 <code>git push origin &lt;tagname&gt;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.5</span></span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>
<p>如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>
<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<h2 id="删除标签">删除标签</h2>
<h3 id="删除本地仓库标签">删除本地仓库标签</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4-lw</span></span><br><span class="line">Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure>
<p>注意上述命令并不会从任何远程仓库中移除这个标签。</p>
<h3 id="删除远程仓库标签">删除远程仓库标签</h3>
<ul>
<li><p>第一种方法是使用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v1.4-lw</span></span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line">- [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</p>
<ul>
<li><p>第二种更直观的删除远程标签的方式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="检出标签">检出标签</h2>
<p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于"分离头指针（detacthed HEAD）"的状态——这个状态有些不好的副作用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0.0</span></span><br><span class="line">Note: checking out &#x27;2.0.0&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final</span><br></pre></td></tr></table></figure>
<p>在"detacthed HEAD"状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置SSH Key</title>
    <url>/posts/5b767b23/</url>
    <content><![CDATA[<p>记录 Git 配置 SSH-Key 的过程，方便以后查阅。</p>
<span id="more"></span>
<h1 id="https-url-和-ssh-url">HTTPS URL 和 SSH URL</h1>
<p>在使用 git clone 项目时，可以使用仓库的 HTTPS URL 也可以 使用 SSH URL</p>
<ul>
<li><p>HTTPS URL，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/&lt;username&gt;/&lt;repo name&gt;.git</span><br></pre></td></tr></table></figure></li>
<li><p>SSH URL，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@github.com:&lt;username&gt;/&lt;repo name&gt;.git</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这两种方式的主要区别在于：使用 HTTPS URL 克隆时，每次 fetch 和 push 代码都需要输入账号和密码，而使用 SSH URL 在配置好 SSH Key 后，每次 fetch 和 push 代码都不需要输入账号和密码。</p>
<h1 id="初次运行-git-前的配置">初次运行 Git 前的配置</h1>
<h2 id="git-环境变量">Git 环境变量</h2>
<p>Git 提供了一个叫做 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<h2 id="配置用户信息">配置用户信息</h2>
<p>初次运行 Git 前需要配置用户信息，一个是你个人的用户名称，一个是你的电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>
<p>如果用了 <code>--global</code> 选项，那么更改的配置文件就是位于你用户主目录下的 <code>~/.gitconfig</code> 文件，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者邮箱，只要去掉 <code>--global</code> 选项重新配置即可，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>
<h2 id="查看配置信息">查看配置信息</h2>
<p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line">user.name=Scott Chacon</span><br><span class="line">user.email=schacon@gmail.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code> ），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的环境变量名称跟在后面即可，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line">Scott Chacon</span><br></pre></td></tr></table></figure>
<h1 id="检查是否已有-ssh-key">检查是否已有 SSH Key</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>ls</code> 或 <code>ll</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure>
<p>看是否存在 id_rsa 和 id_rsa.pub 文件（或者是其它文件名），如果存在说明已有 ssh key，可以直接跳过生成密钥，其中 id_rsa 为私钥，id_rsa.pub 为公钥。</p>
<h1 id="生成-ssh-key">生成 SSH key</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-t</code></td>
<td>指定密钥类型，默认是rsa，可以省略</td>
</tr>
<tr class="even">
<td><code>-C</code></td>
<td>设置注释文字，比如邮箱</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>指定密钥文件存储文件名</td>
</tr>
</tbody>
</table>
<p>以上代码省略了 <code>-f</code> 参数，因此在运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (~/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>当然，你也可以不输入文件名，直接回车使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个密钥文件。</p>
<p>接着又会提示你输入两次密码（该密码是你 push 文件的时候要输入的密码，而不是 github 管理者的密码），当然，你也可以不输入密码，直接连续两次按回车。那么 push 的时候就不需要输入密码，直接提交到 github 上了，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (~/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>连续两次回车确认后，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (~/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in ~/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in ~/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:1qRb99eh19t8bqtivWkuxpNLnwKzXIg1e1u2JASyMfU your_email@example.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|        ..       |</span><br><span class="line">|       + ..      |</span><br><span class="line">|        = oE     |</span><br><span class="line">|       . * .     |</span><br><span class="line">|        S B .  . |</span><br><span class="line">|       o B = =. +|</span><br><span class="line">|        o B.O.o.+|</span><br><span class="line">|         o.@.++o=|</span><br><span class="line">|          o.OBo=*|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>看到以上 save 成功的提示，说明 SSH Key 已经创建成功，提示已经说明密钥文件已保存在 <code>~/.ssh</code> 文件夹下。</p>
<h1 id="添加-ssh-key-到-github">添加 SSH Key 到 Github</h1>
<p>登录 github，点击头像，点击 Settings 进入设置页面。</p>
<p>然后点击菜单栏的 SSH Key 进入页面添加 SSH Key。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1e024a483acf652e219e88cdc4f51272.png" alt="github-ssh-keys" /></p>
<p>点击 New SSH Key 按钮后进行 Key 的填写，其中 Title 随意， Key 为刚刚生成的公钥，公钥在文件 id_rsa.pub 文件中，直接 copy 文件中的内容粘贴即可。</p>
<h1 id="测试-ssh-key">测试 SSH key</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>
<p>当执行以上代码时，会有一段警告，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:<span class="built_in">df</span>:a6:48.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Are you sure you want to <span class="built_in">continue</span> connecting (<span class="built_in">yes</span>/no)?</span></span><br></pre></td></tr></table></figure>
<p>这是正常的，直接输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enter passphrase for key &#x27;~/.ssh/id_rsa&#x27;:</span><br></pre></td></tr></table></figure>
<p>当然如果你密码输错了，会再要求你输入，直到对了为止。注意：输入密码时如果输错一个字符就会不正确，使用删除键是无法更正的。正确输入密码后你会看到下面这段话，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>如果用户名是正确的，你已经成功设置 SSH 密钥。如果你看到 "access denied" ，者表示拒绝访问，那么你就需要使用 HTTPS 去访问，而不是 SSH 。</p>
<h1 id="references">References</h1>
<p><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE</a></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/3572582.html">https://www.cnblogs.com/ayseeing/p/3572582.html</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo相关问题和优化</title>
    <url>/posts/78c745f0/</url>
    <content><![CDATA[<p>本文记录一些 Hexo 的难点问题及其解决方案。</p>
<span id="more"></span>
<h1 id="环境及版本声明">环境及版本声明</h1>
<p>本文基于以下环境及版本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">1.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">7.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">OS:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span> <span class="string">LTS</span> <span class="string">x86_64</span></span><br></pre></td></tr></table></figure>
<h1 id="禁止爬虫跟踪外链">禁止爬虫跟踪外链</h1>
<p>搜索引擎的蜘蛛来爬取文章内容时，如果你的文章中有外部链接，它就会到外链的站点去爬取，有可能再也不会回来了。为了告诉搜索引擎不要跟踪这些外链，需要在这些链接标签中添加属性 <code>rel="nofollow"</code> 或 <code>rel="external nofollow"</code> 。</p>
<p><code>rel="nofollow"</code> 是通用格式，即是告诉搜索引擎不要跟踪此链接，<code>rel="external nofollow"</code> 是更具体的写法，进一步告诉搜索引擎这是一个外部的链接，不要跟踪它。</p>
<p>我们可以 <code>hexo-autonofollow</code> 插件来给外链添加 <code>nofollow</code> 属性，这样有利于 SEO 。</p>
<h2 id="安装-hexo-autonofollow">安装 <a href="https://github.com/liuzc/hexo-autonofollow">hexo-autonofollow</a></h2>
<p>在站点根目录下执行下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure>
<h2 id="编辑-站点配置文件">编辑 <code>站点配置文件</code></h2>
<p>在 <code>站点配置文件</code> _config.yml 末尾添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adds nofollow attribute to all external links in your hexo blog posts automatically.</span></span><br><span class="line"><span class="comment">## https://github.com/liuzc/hexo-autonofollow</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="comment"># 例外的链接，可将友链放在此处</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yourname.github.io</span> <span class="comment"># 排除你的站点</span></span><br><span class="line">    <span class="comment"># - 友链地址</span></span><br></pre></td></tr></table></figure>
<p>配置后，在生成的静态文件中，例外的链接就不会被加上 <code>nofollow</code> 属性。</p>
<h1 id="设置永久链接">设置永久链接</h1>
<p>链接层级过深、链接中包含中文、因为 title 变动导致链接也经常发生变动，这些都不利于 SEO 。推荐 permalink 的解决方案是使用插件 <a href="https://post.zz173.com/detail/hexo-abbrlink.html">hexo-abbrlink</a> 生成 permalink 。</p>
<h2 id="安装-hexo-abbrlink">安装 <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a></h2>
<p>站点根目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<h2 id="编辑-站点配置文件-1">编辑 <code>站点配置文件</code></h2>
<p>修改 <code>站点配置文件</code> _config.yml 的 <code>permalink</code> 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>:abbrlink</code> 代表连接地址。可以在 <code>站点配置文件</code> 下添加 abbrlink 的配置（其中 alg 和 rep 分别为生成的算法和表示方式），如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="comment">## https://github.com/rozbo/hexo-abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># support dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<p>不同配置生成的链接效果如下：</p>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>进制</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>crc16</td>
<td>hex</td>
<td>https://post.zz173.com/posts/3ab2.html</td>
</tr>
<tr class="even">
<td>crc16</td>
<td>dec</td>
<td>https://post.zz173.com/posts/12345.html</td>
</tr>
<tr class="odd">
<td>crc32</td>
<td>hex</td>
<td>https://post.zz173.com/posts/9a8b6c4d.html</td>
</tr>
<tr class="even">
<td>crc32</td>
<td>dec</td>
<td>https://post.zz173.com/posts/1690090958.html</td>
</tr>
</tbody>
</table>
<p><strong>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态文件后，源文件 front-matter 中会包含 <code>abbrlink: xxx</code> 。</strong></p>
<p>这样不论我们的文件名、文章的 title 、文章的内容有没有发生改变，abbrlink 都不会改变，同时对搜索引擎更加友好。</p>
<p>CRC 全称 Cyclic Redundancy Check，又叫循环冗余校验。CRC32 跟 MD5一样都是哈希算法的一种。<strong>从 <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 的源码来看，实际上它并没有利用到时间，只是利用了文章 title 来生成。</strong></p>
<p>使用这种方法生成 permalink 时，在每次提交修改前，最好先执行 <code>hexo clean &amp;&amp; hexo g</code>，确保提交前你所有的文章的 front-matter 中都包含 abbrlink ，避免因 title 的改变导致生成 abbrlink 不一致（如果已存在 abbrlink，就不会重新生成，不论 title 是否发生变化）。</p>
<h1 id="分类存放文章源文件">分类存放文章源文件</h1>
<p>Hexo 默认所有的文章都会放在 <code>source/_posts</code> 文件夹下，当文章越来越多时，将很难管理文章源文件同时也不利于快速查找到想要的文章。</p>
<p>我个人的做法就是分层分类存放，同时利用上面提到的 abbrlink 来设置 permalink，以确保不管文章源文件如何变换分类、分类层次有多深，生成的静态页面的链接始终对 SEO 友好。</p>
<p>例如，在 <code>_posts</code> 文件夹，创建了 <code>Algorithm</code> 和 <code>Linux</code> 两个文件夹作为一级分类， <code>Linux</code> 分类下创建了 <code>command</code> 文件夹作为二级分类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f6ca2d672327ac83e9adf5673d4688f5.png" alt="source-fold" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/247c69250b3a3f331204c256865d2324.png" alt="source-unfold" /></p>
<p>其中，文章的同名同级的文件夹是它的资源文件夹，存放文章对应的资源，如图片等。</p>
<p>本地运行测试，查看文章 QuickSort 如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3ddb9093059b94f1ad766a6b66fba473.png" alt="posts-classify" /></p>
<p>不管源文件如何存放，链接始终是 <code>/posts/xxxxxxx/</code> 的形式，另外需要注意 <strong>文章 front-matter 中的 <code>categories</code> 与这里的分类存放没有任何关系</strong> ，如上图中 QuickSort 文章分类于 <code>Algorithm -&gt; Sort</code>，而其 md 文件是直接放在了 Algorithm 目录下。</p>
<p>如果你想让 URL 直接对应源文件的分类也是可以的，但不推荐这么做，编辑 <code>站点配置文件</code>，修改 permalink 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span></span><br></pre></td></tr></table></figure>
<p>重新生成，测试结果如下，注意 URL 与源文件存放位置的对应关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/694fae594f7b31a0d088d4b70f07b390.png" alt="post-quicksort" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e5ae38e2560f83a73435a9f05128caec.png" alt="post-netstat" /></p>
<h1 id="英文引号变成中文引号">英文引号变成中文引号</h1>
<p>引号显示异常，英文单引号 ' 双引号 "，都显示成中文单引号’ 双引号”。</p>
<h2 id="方法一">方法一</h2>
<p><strong>因为 hexo-renderer-marked 渲染 Markdown 有很多问题，所以推荐使用方法二。</strong></p>
<p>Hexo 默认使用 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 作为 Markdown 的解析引擎，它的 <code>smartypants</code> 配置项默认为 <code>true</code>，只需将其禁用就可以解决引号显示异常的问题。</p>
<p>编辑 <code>站点配置文件</code>，在文件末尾添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prohibit English quotation marks from becoming Chinese quotation marks</span></span><br><span class="line"><span class="comment">## https://github.com/hexojs/hexo/issues/1981</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>保存修改，重新生成站点，就可以正常显示了。</p>
<h2 id="方法二">方法二</h2>
<p>Hexo 默认自带的 Markdown 渲染引擎 <code>hexo-renderer-marked</code> 有很多不足，例如在渲染数学公式时会有很多问题，同时因为它默认开启 <code>smartypants</code>，导致引号显示异常，所以最好的解决方案是更换 Hexo 默认的 Markdown 渲染引擎。</p>
<p>这里推荐使用 <a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>，这个插件依赖于 <a href="https://github.com/jgm/pandoc">Pandoc</a>，具体的操作可以参考下面 "数学公式渲染"。</p>
<p><strong>更换渲染引擎后，无需修改任何配置，引号的显示就是正常的。</strong></p>
<h1 id="hexo-next-数学公式渲染">Hexo NexT 数学公式渲染</h1>
<p>参考：</p>
<ul>
<li><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">NexT MATH</a></li>
<li><a href="https://theme-next.org/docs/third-party-services/math-equations">NexT Math Equations</a></li>
<li>jdhao 博客 <a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/">Hexo 书写 LaTeX 公式时的一些问题及解决方法</a></li>
<li>天空的城 博客 <a href="https://shomy.top/2016/10/22/hexo-markdown-mathjax/">Hexo下mathjax的转义问题</a></li>
<li>Peter 博客 <a href="https://peterxugo.github.io/2017/05/27/hexo%E5%86%99%E5%8D%9A%E5%AE%A2/">hexo写博客</a></li>
</ul>
<blockquote>
<p>为什么要替换 Hexo 的默认 Markdown 引擎?</p>
<p>Hexo 默认使用 marked.js 去解析我们写的 markdown，比如一些符号，<code>_</code> 代表斜体，会被处理为 <code>&lt;em&gt;</code> 标签，比如 <code>x_i</code> 在开始被渲染的时候，处理为 <code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候 mathjax 就无法渲染成下标了。很多符号都有这个问题，比如粗体 <code>*</code>，也是无法在 mathjax 渲染出来的，好在有替代的乘法等，包括 <code>\\</code> 同理。</p>
</blockquote>
<p>目前，NexT 提供两种数学公式渲染引擎，分别为 <a href="https://www.mathjax.org/">MathJax</a> 和 <a href="https://khan.github.io/KaTeX/">Katex</a>，默认为 MathJax。</p>
<p>如果你选择使用 MathJax 进行数学公式渲染，你需要使用 <a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a> 或者 <a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a> 这两个渲染器的其中一个。</p>
<p>这里推荐使用 <code>MathJax</code> + <code>hexo-renderer-pandoc</code> ，并以此为例：</p>
<h2 id="本地测试">本地测试</h2>
<ol type="1">
<li><p>因为 <code>hexo-renderer-pandoc</code> 依赖 Pandoc，所以首先需要安装 Pandoc，具体安装步骤参考 <a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">how to install pandoc</a> 。</p></li>
<li><p>站点根目录下执行下列命令，卸载原有的渲染器 <code>hexo-renderer-marked</code>，然后安装 <code>hexo-renderer-pandoc</code> ：</p></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>编辑 <code>主题配置文件</code>，修改配置如下：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front Matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">engine:</span> <span class="string">mathjax</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>重新生成并测试：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -o</span><br></pre></td></tr></table></figure>
<h2 id="travis-ci-配置">Travis CI 配置</h2>
<p>因为 <code>hexo-renderer-pandoc</code> 依赖 Pandoc，所以 Travis CI 中也要安装 Pandoc，而且最好安装较新的版本，比较旧的版本如 <code>1.19.X</code> 可能解析出错。</p>
<p>在 .travis.yml 中添加类似配置，参考 <a href="https://docs.travis-ci.com/user/installing-dependencies/#installing-packages-without-an-apt-repository">installing-packages-without-an-apt-repository</a>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">wget</span> <span class="string">https://github.com/jgm/pandoc/releases/download/2.7.2/pandoc-2.7.2-1-amd64.deb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">dpkg</span> <span class="string">-i</span> <span class="string">pandoc-2.7.2-1-amd64.deb</span></span><br></pre></td></tr></table></figure>
<p>完整配置可参考 <a href="https://github.com/wylu/wylu.github.io/blob/dev/.travis.yml">wylu.github.io/.travis.yml</a></p>
<h1 id="文章更新时间异常">文章更新时间异常</h1>
<h2 id="方法一使用-updated-属性">方法一：使用 updated 属性</h2>
<p><strong>推荐使用方法二，避免手动操作。</strong></p>
<p>当使用 Travis CI 自动部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。另外，本地测试显示的更新时间是正常的。</p>
<p>这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 <code>front-matter</code> 中指定 <code>updated</code>，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。</p>
<p>总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而 Travis CI 每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间，可以在 <code>front-matter</code> 中指定，或者改用本地手动推送部署。</p>
<p>下面是一个 python 脚本，用来向 <code>front-matter</code> 中插入最后修改时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">file_encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">last_modify</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(os.stat(path).st_mtime))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write2file</span>(<span class="params">file_path, updated=time.strftime(<span class="params"><span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(<span class="params"></span>)</span>)</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=file_encoding) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    updated = <span class="string">&#x27;updated: &#x27;</span> + updated + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> lines[i].startswith(<span class="string">&#x27;updated: &#x27;</span>):</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> lines[i] == <span class="string">&#x27;---\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===&gt; Existed. &quot;</span> + file_path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    lines = lines[:i] + [updated] + lines[i:]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=file_encoding) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;&#x27;</span>.join(lines))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;===&gt; Success. &quot;</span> + file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_paths</span>(<span class="params">path</span>):</span><br><span class="line">    paths = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path) <span class="keyword">and</span> path.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> [&#123;<span class="string">&quot;file_path&quot;</span>: path, <span class="string">&quot;updated&quot;</span>: last_modify(path)&#125;]</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(os.path.join(path)):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">                file_path = os.path.join(root, file)</span><br><span class="line">                paths.append(&#123;<span class="string">&quot;file_path&quot;</span>: file_path, <span class="string">&quot;updated&quot;</span>: last_modify(file_path)&#125;)</span><br><span class="line">    <span class="keyword">return</span> paths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_update_time</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.path.join(path)):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    paths = get_paths(path)</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(paths):</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        write2file(item[<span class="string">&#x27;file_path&#x27;</span>], item[<span class="string">&#x27;updated&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> file_encoding</span><br><span class="line">    argc = <span class="built_in">len</span>(sys.argv)</span><br><span class="line">    <span class="keyword">if</span> argc &lt; <span class="number">2</span> <span class="keyword">or</span> argc &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!\nUsage: python post_util &lt;post directory&gt; [file encoding], for example:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\tpython post_util.py /home/wylu/hexo/source/_post&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\tpython post_util.py &quot;/home/wylu/hexo/source/_post&quot; utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> argc == <span class="number">3</span>:</span><br><span class="line">        file_encoding = sys.argv[<span class="number">2</span>]</span><br><span class="line">    add_update_time(path=sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指定 _post 文件夹路径，可批量操作，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python post_util.py /home/yourname/hexo/source/_post</span><br></pre></td></tr></table></figure>
<p>如果 <code>front-matter</code> 中已存在 <code>updated</code>，则不会覆盖。如果想重新生成，可以删掉 <code>updated</code> 所在的行然后重新执行。</p>
<h2 id="方法二使用-git-推送时间">方法二：使用 git 推送时间</h2>
<p>参考 <a href="https://theme-next.org/docs/getting-started/deployment">NexT deployment .travis.yml</a></p>
<p>在 Travis CI 的配置文件 .travis.yml 中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="comment"># Restore last modified time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;git ls-files -z | while read -d &#x27;&#x27; path; do touch -d \&quot;$(git log -1 --format=\&quot;@%ct\&quot; \&quot;$path\&quot;)\&quot; \&quot;$path\&quot;; done&quot;</span></span><br></pre></td></tr></table></figure>
<p>实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。</p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT第三方服务集成</title>
    <url>/posts/aa960b18/</url>
    <content><![CDATA[<p>本文将介绍一些第三方服务的集成与使用，如评论、搜索、SEO、持续集成等。</p>
<span id="more"></span>
<h1 id="环境及版本声明">环境及版本声明</h1>
<p>本文基于以下环境及版本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">1.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">7.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">OS:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span> <span class="string">LTS</span> <span class="string">x86_64</span></span><br></pre></td></tr></table></figure>
<p><strong>若主题版本不一致，下面的配置方法可能不适用。</strong></p>
<h1 id="集成-gitalk-评论系统">集成 Gitalk 评论系统</h1>
<p>参考</p>
<ul>
<li><p>zhujian hexo指南 <a href="https://hexo-guide.readthedocs.io/zh_CN/latest/third-service/%5BGitalk%5D%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html">Gitalk评论系统</a></p></li>
<li><p><a href="https://theme-next.org/docs/third-party-services/comments-and-widgets#Gitalk">https://theme-next.org/docs/third-party-services/comments-and-widgets#Gitalk</a></p></li>
<li><p>asdfv1929 博客 <a href="https://asdfv1929.github.io/2018/01/20/gitalk/">Hexo NexT主题中集成gitalk评论系统</a></p></li>
</ul>
<p>Gitalk是一个基于 GitHub Issue 和 Preact 的现代评论组件。详见 <a href="https://github.com/gitalk/gitalk">官方Github</a> 和 <a href="https://gitalk.github.io/">官方Demo</a>。</p>
<p>实际上现在 NexT 已经集成了 gitalk，我们只需做一些配置即可，配置步骤如下。</p>
<h2 id="注册-oauth-app">注册 OAuth App</h2>
<p>进入 github 注册页面 <a href="https://github.com/settings/applications/new">Register a new OAuth application</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c07a8e6aa530fe5379293dd058183813.png" alt="github-oauth-app" /></p>
<ul>
<li>Application name： 应用名称，随意</li>
<li>Homepage URL： 使用 gitalk 的网站地址，如果为 GithubPage，则为 https://yourname.github.io</li>
<li>Application description 应用描述，随意</li>
<li>Authorization callback URL： 使用 gitalk 的网站地址（授权回调 URL），如果为 GithubPage，则为 https://yourname.github.io</li>
</ul>
<p>注册成功后，页面跳转，生成 <code>Client ID</code> 和 <code>Client Secret</code> 在后面的配置会用到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/27304cbbe291de40f7c1ae7d9a2e11fd.png" alt="client-id-secret" /></p>
<h2 id="修改主题-_config.yml-配置">修改主题 <code>_config.yml</code> 配置</h2>
<p>编辑 <code>主题配置文件</code>，启用 <code>gitalk</code> 模块，修改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># Demo: https://gitalk.github.io</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">wylu</span> <span class="comment"># github账号 Github repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">github-pages-comments</span> <span class="comment"># 保存评论的仓库 Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">填写刚刚注册生成的</span> <span class="string">Client</span> <span class="string">ID</span> <span class="comment"># Github Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">填写刚刚注册生成的</span> <span class="string">Client</span> <span class="string">Secret</span> <span class="comment"># Github Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">wylu</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize github issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en, es-ES, fr, ru, zh-CN, zh-TW</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<p>gitalk 实际上是利用提 Issues 的方式来存储评论的，所以需要使用 <code>repo</code> 指定一个仓库来存储 Issues，<strong>建议新建一个仓库专门用来存储 GithubPages 的评论</strong>，如这里我使用了仓库 <code>github-pages-comments</code> 来存储评论，而不是使用部署 GithubPages 的仓库。</p>
<h2 id="初始化评论">初始化评论</h2>
<p>部署成功后，打开一篇文章，登录 github 就会初始化文章评论。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d6e901ddbcec1336c86f9dc452f65dd8.png" alt="login-to-initialize" /></p>
<p>登录成功后</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bea138602e2a900100b697bd25833c90.png" alt="comments" /></p>
<p>自动创建的 Issues</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/814b5c261fcbbe5c40f1692a27a45248.png" alt="issues" /></p>
<p><strong>注意：所有没有初始化过的评论的文章都需要进入到该文章页面下才会初始该文章对应的评论（Issues）。</strong></p>
<p><strong>另外，如果文章的链接变了，文章会重新初始化评论，即创建新的 Issues 并指向它。猜测 gitalk 可能是根据文章链接来创建 Issues 的，每一个链接对应一个页面，每一个页面对应一个 Issues 。所以推荐使用 <a href="https://wylu.github.io/posts/78c745f0/">abbrlink</a> 设置永久链接，以避免同一篇文章重复创建 Issues 。</strong></p>
<h2 id="取消一些页面的评论">取消一些页面的评论</h2>
<p>成功配置 gitalk 评论系统后，将会在每个页面末尾添加评论框，对于不需要评论的文章或页面，可在 front-matter 设置如下属性进行隐藏：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="创建留言板">创建留言板</h1>
<p>成功配置 gitalk 评论功能后，我们就可以利用它来实现留言板的功能了。</p>
<h2 id="新建-guestbook-页面">新建 guestbook 页面</h2>
<p>与添加标签页、分类页类似，留言板的 layout 也是 page，在站点根目录下执行下列命令创建一个新页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page guestbook</span><br></pre></td></tr></table></figure>
<h2 id="添加菜单项">添加菜单项</h2>
<p>编辑 <code>主题配置文件</code>，在 <code>menu</code> 下添加 <code>guestbook: /guestbook/ || commenting</code>，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">guestbook:</span> <span class="string">/guestbook/</span> <span class="string">||</span> <span class="string">commenting</span></span><br></pre></td></tr></table></figure>
<h2 id="设置菜单项显示文本">设置菜单项显示文本</h2>
<p>如果存在该菜单项对应的翻译，则将加载翻译的文本，否则将直接使用 key 的值，这里的 key 就是冒号前面的 <code>guestbook</code>。</p>
<p>假设我们现在站点用的语言是 <code>zh-CN</code>，则编辑 <code>themes/next/languages/zh-CN.yml</code> 文件，在 <code>menu</code> 下添加 <code>guestbook: 留言板</code>，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">(^_^)</span> <span class="comment"># 首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">guestbook:</span> <span class="string">留言板</span></span><br></pre></td></tr></table></figure>
<p>设置完成后，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/75d406657d2d0f325e4152b6bb67a49b.png" alt="menu-guestbook" /></p>
<p>打开页面如下（部署成功后，登录就可以评论留言了）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/162daf9032013430be26af8cd5edbb37.png" alt="guestbook-page" /></p>
<h1 id="不蒜子访客数和访问量统计">不蒜子访客数和访问量统计</h1>
<p>统计项包括：</p>
<ul>
<li>站点总访客数</li>
<li>站点总访问量</li>
<li>文章总阅读数</li>
</ul>
<p>NexT 已经集成了 busuanzi 统计服务。更多关于 busuanzi 的介绍请移步 <a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a></p>
<p>编辑 <code>主题配置文件</code>，启用 <code>busuanzi_count</code> 统计模块，修改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span> <span class="comment"># 是否展示站点总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 对应 font awesome 图标名称，如果没有定义则不显示图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span> <span class="comment"># 是否展示站点总访问量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span> <span class="comment"># 对应 font awesome 图标名称</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span> <span class="comment"># 是否展示文章总访问量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span> <span class="comment"># 对应 font awesome 图标名称</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/48535284cf34681a51fc43e0ade8548f.png" alt="busuanzi-count" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/45cde387ea3599b2d0088fd583f43840.png" alt="busuanzi-post-views" /></p>
<p><strong>注意：通过查看 <code>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code> 中的代码，可以发现 <code>total_visitors</code> 使用的是 <code>uv</code> 的计算方式，即单个用户连续点击n篇文章，只记录 1 次访客数； <code>total_views</code> 使用的是 <code>pv</code> 的计算方式，单个用户点击 1 篇文章，本篇文章记录 1 次阅读量。查看 <code>themes/next/layout/_macro/post.swig</code> 中的代码，可知 <code>post_views</code> 使用的是 <code>pv</code> 计算方式。</strong></p>
<p><strong>另外一个需要注意的是，在本地预览时会看到的统计结果数异常，不用理会，只要部署到 GithubPages 后就会正常统计。启用 不蒜子 后，就算设置不显示统计结果，统计任务也一样会继续运行。</strong></p>
<h1 id="使用-localsearch-搜索功能">使用 LocalSearch 搜索功能</h1>
<p><strong>NexT 支持许多搜索服务，只需选择其中一种即可。</strong></p>
<p>参考 yashuning 博客 <a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">hexo - Next 主题添加搜索功能</a></p>
<h2 id="安装插件">安装插件</h2>
<p><code>local_search</code> 依赖于插件 <a href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a></p>
<p>在站点根目录下执行下列安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h2 id="编辑-站点配置文件-_config.yml">编辑 <code>站点配置文件</code> _config.yml</h2>
<p>在文件末尾添加如下默认配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>path - 文件路径。默认情况下是 <code>search.xml</code>。如果文件扩展名为 <code>.json</code>，则输出格式为 JSON。否则将导出 XML 格式文件。</li>
<li>field - 要搜索的搜索范围，可选项:
<ul>
<li>post (Default) - 仅涵盖您博客的所有文章。</li>
<li>page - 仅涵盖您博客的所有页面。</li>
<li>all - 将涵盖您博客的所有文章和页面。</li>
</ul></li>
<li>format - 页面内容的形式，适用于xml模式，可选项:
<ul>
<li>html (Default) - original html string being minified.</li>
<li>raw - markdown text of each posts or pages.</li>
<li>excerpt - only collect excerpt.</li>
<li>more - act as you think.</li>
</ul></li>
<li>limit - 定义被索引的帖子的最大数量，优先取最新的。</li>
</ul>
<h2 id="编辑-主题配置文件-_config.yml">编辑 <code>主题配置文件</code> _config.yml</h2>
<p>启用 <code>local_search</code> 模块，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>开启 <code>local_search</code> 后就可以在菜单栏看到搜索选项了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/003d4275fe74181b022a5e6ed6f14e7e.png" alt="menu-localsearch" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/1aa5feca19ddf4753a82b99d7dde743f.png" alt="localsearch" /></p>
<h1 id="集成-algolia-search-搜索服务">集成 Algolia Search 搜索服务</h1>
<p>网上很多配置过程都比较老了，现在 Algolia Search 界面已经发生比较大的变化。<a href="https://www.algolia.com/">Algolia 官网</a></p>
<p>参考 <a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search">http://theme-next.iissnan.com/third-party-services.html#algolia-search</a></p>
<h2 id="登录-algolia">登录 algolia</h2>
<p>点击 <a href="https://www.algolia.com/users/sign_in">https://www.algolia.com/users/sign_in</a> 进入登录页面，注册一个新账户，或者直接使用 Github 账号 或 Google 账号直接登录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/616fb92fdabfcf0cff6e6d7ddf62e4ac.png" alt="algolia-login" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5efc2b44575e055670065d5e8bed8a15.png" alt="algolia-about-you" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b5a2cbf37c0e83439a0e3f422523d951.png" alt="algolia-datacenter" /></p>
<p>跳过创建 Project , 然后进入 Dashboard</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4f9f542a313caf5722b0e66756cc685f.png" alt="algolia-dashboard" /></p>
<p>可以直接跳过教学，也可以选择开始教学</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e475c375151879ba58f585ac5767902d.png" alt="algolia-tutorial" /></p>
<h2 id="创建一个新的-index">创建一个新的 Index</h2>
<p>没有任何 Index 时：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8ed38f58e6eba26d4438a6a6fa420c7d.png" alt="algolia-create-index-1" /></p>
<p>如果已经有一个 Index 时：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/db41e963745fc8eb50e1a0b3d293a707.png" alt="algolia-create-index-2" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/19a04628ff4e931d205eb93172eaea01.png" alt="algolia-index-name" /></p>
<h2 id="设置用于搜索-index-的-api-keys">设置用于搜索 Index 的 API Keys</h2>
<p><strong>这里说明一下，最好使用两个 API Key，其中一个 Key 只有 search 权限，而另一个 Key 具有 Indices 的 CRUD 权限。</strong></p>
<p>默认会有一把名为 <code>Search-Only API Key</code> 的 Key，这个 Key 只有 search 权限，点击 <code>All API Keys</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2e7c82aa7ed780529d47400e307609c3.png" alt="algolia-search-only-key" /></p>
<p>编辑 <code>Search-only API Key</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b9e0278ab9ff44285e9b094cb67eb161.png" alt="algolia-edit-search-key" /></p>
<p>在 Indices 中添加刚才新创建的 Index 然后 Update 保存:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/020b0aaf89b85229fbf18894af1b0143.png" alt="algolia-select-index" /></p>
<h2 id="新建一个用于管理-index-的-api-key">新建一个用于管理 Index 的 API Key</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/035e70ff0a01b94f27e82fd7fe6fcd5e.png" alt="algolia-new-api-key" /></p>
<p>Description 随意，Indices 添加上面创建的 Index，ACL 中只选择四种操作 <code>addObject</code>、<code>deleteObject</code>、<code>deleteIndex</code>、<code>listIndexes</code>，其它的默认就行，然后点击Create：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3ca85bce8e4b1302901545b7f394cddb.png" alt="algolia-new-key-indices" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a709224c0d603d8527293fc751c06618.png" alt="algolia-new-key-acl" /></p>
<p>创建完成后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3b411f4a174eed2c1182f516df1692c3.png" alt="algolia-keys" /></p>
<h2 id="安装插件-1">安装插件</h2>
<p>在站点根目录下安装插件 hexo-algolia</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>
<p>在主题目录下安装插件 theme-next-algolia-instant-search</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-algolia-instant-search source/lib/algolia-instant-search</span><br></pre></td></tr></table></figure>
<h2 id="编辑-站点配置文件-_config.yml-1">编辑 <code>站点配置文件</code> _config.yml</h2>
<p>在文件末尾添加如下配置，更多说明请看 <a href="https://github.com/oncletom/hexo-algolia">官方github</a>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo plugin: hexo-algolia</span></span><br><span class="line"><span class="comment"># https://github.com/oncletom/hexo-algolia</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">applicationID:</span> <span class="comment"># 你的 Application ID</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment"># 你的 Search-Only API Key</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="comment"># 新建的Index的名称，如&#x27;dev_PASSAGE&#x27;</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p><strong>点击 API keys 选项，可以查看你的 <code>Application ID</code> 和<code>Search-Only API Key</code></strong></p>
<h2 id="编辑-主题配置文件-_config.yml-1">编辑 <code>主题配置文件</code> _config.yml</h2>
<p>启用 <code>algolia_search</code> 模块（不要启用多个搜索服务），修改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/search-services#Algolia-Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-algolia-instant-search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用管理的-key-创建页面索引">使用管理的 Key 创建页面索引</h2>
<p>algolia 上还没有网站的索引数据，所以需要先创建。</p>
<p>执行下列命令设置环境变量，（也可以在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件中 export，这样就不需要每次都手动 export 了），导入用于管理 Index 的 Key，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=&quot;填入刚才创建的用于管理 Index 的 Key&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/05aa32026e9270f8ed7d51b9ccadfae0.png" alt="export-key" /></p>
<p>因为这个 Key 有管理 Index 的权限，所以必须用它才能创建或更新页面索引。</p>
<p>执行下列命令，将检索数据上传到 Algolia 网站，它会保存在之前新建的 Index 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">╭─wylu@X555LJ ~/WorkSpace/VScode/hexo  ‹dev*›</span><br><span class="line">╰─$ hexo clean</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line">╭─wylu@X555LJ ~/WorkSpace/VScode/hexo  ‹dev*›</span><br><span class="line">╰─$ hexo algolia</span><br><span class="line">INFO  [hexo-algolia] Testing HEXO_ALGOLIA_INDEXING_KEY permissions.</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  [hexo-algolia] 7 records to index (post, page).</span><br><span class="line">INFO  [hexo-algolia] Indexing chunk 1 of 1 (7 records)</span><br><span class="line">INFO  [hexo-algolia] Indexing done.</span><br></pre></td></tr></table></figure>
<p>这时在 algolia 网站点击 Indices 就能看到创建的索引数据了。</p>
<p><strong>注意：每次网站更新后，在部署之前都应先更新 algolia 索引数据，如果你使用的是 algolia 搜索服务。另外还需要注意的是，当你删除一篇文章，使用 <code>hexo algolia</code> 更新站点索引时，这个被删除的文章的索引并不会被删除，如果你想去掉这些已经不存在的文章的索引，可以执行 <code>hexo algolia --flush</code> 命令。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/aecd63619ceb3041871d1d3f0461efe6.png" alt="algolia-search" /></p>
<p>索引结果的链接是站点配置文件中的 <code>url+root+permalink</code>。</p>
<h1 id="让-google-收录-githugpages-站点">让 Google 收录 GithugPages 站点</h1>
<p>参考</p>
<ul>
<li>hoxis 博客 <a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html">Hexo博客Next主题SEO优化方法</a></li>
<li>张杰钧 博客 <a href="https://zhangjiejun.com/posts/set_hexo_available_in_google/">使hexo博客被谷歌检索</a></li>
<li>EvanLi 博客 <a href="https://evanli.github.io/blog/2018/10/25/let-jekyll-github-pages-be-searched-by-google/">让Google搜索到用Jekyll搭建在Github Pages上的博客</a></li>
</ul>
<p>通过设置站点地图，可以让搜索引擎获取你的页面信息，这样可以使别人可以搜索到你的博客。</p>
<h2 id="查看是否被收录">查看是否被收录</h2>
<p>首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:https://xxx.github.io</span><br></pre></td></tr></table></figure>
<p>其中 <code>https://xxx.github.io</code> 为你的博客地址，如果结果是 <code>尝试使用 Google Search Console ... 找不到和您查询的“site:xxx.github.io”相符的内容或信息。</code>，则意味着没有被收录。</p>
<h2 id="生成站点地图">生成站点地图</h2>
<p>安装插件 hexo-generator-sitemap，它能自动生成站点地图，在站点根目录下执行下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>编辑 <code>站点配置文件</code>，在文件末尾添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo plugin: hexo-generator-sitemap</span></span><br><span class="line"><span class="comment"># https://github.com/hexojs/hexo-generator-sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure>
<p>更多配置说明详见 <a href="https://github.com/hexojs/hexo-generator-sitemap">官方Github</a></p>
<p>配置完成后，执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成静态文件，它会在 public 文件夹下生成 sitemap.xml 文件，这就是生成的站点地图。</p>
<h2 id="添加蜘蛛协议">添加蜘蛛协议</h2>
<p>在站点根目录 source 文件夹下新建 robots.txt 文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /images/</span><br><span class="line">Disallow: /lib/</span><br><span class="line">Disallow: /assets/</span><br><span class="line"></span><br><span class="line">Sitemap: https://yourname.github.io/sitemap.xml</span><br></pre></td></tr></table></figure>
<p><strong>将 <code>Sitemap</code> 属性值替换成自己的地址, <code>Allow</code> 字段值为允许搜索引擎抓取的文件，<code>Disallow</code>为不需要抓取的内容，可以根据具体情况修改。</strong></p>
<p>例如生成站点的静态文件中有 <code>guestbook</code> 目录，里面有留言板页面，这是需要抓取的，所以在 robots 中添加 <code>Allow: /guestbook/</code>，这样就会抓取 guestbook 文件夹下的所有内容。</p>
<p><strong>这个文件不是必需的，如果没有该文件，Google 默认会抓取站点所有内容。</strong></p>
<h2 id="提交搜索资源">提交搜索资源</h2>
<p>选择 立即使用 <a href="https://search.google.com/search-console/about">Google Search Console</a>，需要先登录 Google 账号。</p>
<p><strong>因为我已经添加了 GithubPages 的搜索资源，所以为了方便，这里使用另一个代码托管平台 gitee 的 Pages 的服务，以此为例介绍如何添加搜索资源，对于 GithubPages 操作步骤和方法是一样的，只要把地址对应地换成 <code>https://yourname.github.io</code> 即可。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bb1d8135b432400ab15e167a8298ad45.png" alt="google-add-site-1" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c10c0c1f686890228e28cc48ce7b102e.png" alt="google-add-site-2" /></p>
<p>根据具体情况输入网址，如 <code>https://xxx.github.io</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/70b634c943eca66d489432f71630cc1e.png" alt="google-site-url" /></p>
<p>点击继续后，会提示你验证站点的所有权，验证的方法有多种，选择其中一种即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/405a98c1ff959ec800ea61e93d62ec7f.png" alt="google-site-verify" /></p>
<p><strong>因为 NexT 主题已集成了该验证实现，所以这里推荐使用第二种验证方法，即 <code>HTML 标记</code>。</strong></p>
<p>下面使用 <code>HTML 标记</code> 进行验证：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c17c61fd18a80046598ef637133bf55f.png" alt="google-verify-html-tag" /></p>
<p>编辑 <code>主题配置文件</code>，修改 <code>google_site_verification</code> 配置，复制粘贴上面 content 中的验证码，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters</span></span><br><span class="line"><span class="attr">google_site_verification:</span> <span class="string">hn30FFDlMIuK4H41vDD2EWny80OZIx8kMDYZiXrFFjg</span></span><br></pre></td></tr></table></figure>
<p><strong>重新生成站点并部署成功后，你会看到主页的源代码中会包含有该验证码的 HTML tag，如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/36965817b1073d12a50270f97585fc85.png" alt="google-index-html-tag" /></p>
<p>回到验证所有权的页面，点击验证，验证成功后会有如下提示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9104f04975be34418ab35719550a40d5.png" alt="google-finish-site-verify" /></p>
<p>点击前往资源页面，然后添加站点地图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9bcdc6e6599bc5e1c62a1c29b991db03.png" alt="google-submit-sitemap" /></p>
<p>提交后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5a163f01074b1a69b8e55903c1615dc6.png" alt="google-submit-sitemap-success" /></p>
<p>等待一段时间后（可能需要一两天），就可以使用 Google 搜索到博客了。</p>
<h1 id="配置-travis-ci-持续集成">配置 Travis CI 持续集成</h1>
<p>参考</p>
<ul>
<li><p>zhujian hexo指南 <a href="https://hexo-guide.readthedocs.io/zh_CN/latest/third-service/%5BTravis%20CI%5D%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html">[Travis CI]持续集成</a></p></li>
<li><p>隔壁老杨 知乎 <a href="https://zhuanlan.zhihu.com/p/37014376">使用 Travis CI 部署你的 Hexo 博客</a></p></li>
<li><p>KChen 博客 <a href="https://kchen.cc/2016/11/12/hexo-instructions/#Travis-CI-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90">基于 Hexo 的全自动博客构建部署系统</a></p></li>
</ul>
<p>现假设你的项目已有两个分支，一个为 dev 分支，用于更新站点，如添加、修改、删除文章等；一个为 master 分支，用于部署站点。</p>
<p>Travis CI 是一个深度结合 github 的持续集成服务。使用它我们不需要手动部署站点，即不需要手动 push 生成的 public 文件夹的内容到 master 分支。<strong>配置了 Travis CI 后，每当我们提交 dev 分支下的修改后，Travis CI 就会根据配置文件生成虚拟机，配置环境后进行静态文件的生成和部署。</strong></p>
<p>配置过程主要分为三个部分：</p>
<h2 id="配置-travis-ci">配置 Travis CI</h2>
<p>Travis CI 不需要单独注册，进入 <a href="https://travis-ci.org/">Travis CI 官网</a> 后，直接使用 GitHub 账号登录即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2aa26878232c676cadc29fe0e1f41d9c.png" alt="travis-ci-setting" /></p>
<p>登录后，勾选要集成的仓库，默认是没有勾选的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3939c07150e19d3d4c3580f417e3b1f6.png" alt="travis-ci-select-repo" /></p>
<p>如果没有看到自己的项目，先点击左上角 <code>Sync account</code> 同步一下。勾选后，点击该仓库进入工作页面。</p>
<p>选择右上角的 <code>More options -&gt; Settings</code> 进入设置页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/abf077b042e146587f0cdb1e16fcbdc1.png" alt="travis-ci-repo-settings" /></p>
<h2 id="设置环境变量">设置环境变量</h2>
<p>有三个环境变量是需要设置的，用于赋予 Travis CI 操作我们的仓库的权限：</p>
<ul>
<li><code>GITHUB_REPO_TOKEN</code>: 操作 Github 仓库的 personal access token</li>
<li><code>USER_EMAIL</code>: 你的 Github 账号的邮箱</li>
<li><code>USER_NAME</code>： 你的 Github 账号的用户名</li>
</ul>
<p>如果你使用了 Algolia Search 服务，那么还需要设置一个变量：</p>
<ul>
<li><code>HEXO_ALGOLIA_INDEXING_KEY</code>: 管理 algolia Index 的 key</li>
</ul>
<p>这里的 HEXO_ALGOLIA_INDEXING_KEY 与上面集成 aloglia search 是一致的。</p>
<p><code>USER_EMAIL</code>，<code>USER_NAME</code>，<code>HEXO_ALGOLIA_INDEXING_KEY</code> 我们都已经有了，现在需要生成一个 Github 仓库的 token，参考 <a href="https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a>。</p>
<p>登录 Github，点击 <code>头像-&gt;Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token</code>，新生成一个 token， token 名称随意填写，给这个 token 赋予下图中的权限，可以根据需要自行调整：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6d6351612726069e4672bafa48f9f8b1.png" alt="personal-access-token" /></p>
<p>然后点击 Generate token，生成的 token 只显示一次，页面刷新后将无法看到，需要先复制下来（如果忘记了，可以重新生成）,这个值就是 <code>GITHUB_REPO_TOKEN</code> 变量的值。</p>
<p>有了 <code>GITHUB_REPO_TOKEN</code> 变量的值后就可开始设置环境变量了，设置环境变量有多种方法，可以参考官方文档 <a href="https://docs.travis-ci.com/user/environment-variables/">Environment Variables</a>，这里使用的是其中的 <a href="https://docs.travis-ci.com/user/environment-variables/#defining-variables-in-repository-settings">Defining Variables in Repository Settings</a> 方法。</p>
<p>回到刚才 Travis CI 的设置页面，在 Environment Variables 一栏中进行添加环境变量操作。如下图，分别填入四个变量名和对应变量值并点击 Add 进行添加，如果勾选了 <code>Display value in build log</code>，那么在构建日志中就能看到变量值的明文（如果你不用 Algolia Search，则不需要 HEXO_ALGOLIA_INDEXING_KEY）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ab0a4632dd87ed84cc752c310a788a42.png" alt="travis-ci-env-var" /></p>
<h2 id="添加-.travis.yml-文件">添加 .travis.yml 文件</h2>
<p>在站点根目录下新建 <code>.travis.yml</code> 文件，当包含该文件的项目上传到 Github 时，Travis CI 自动根据该配置文件中的内容进行构建和部署。</p>
<p>该配置文件指导 Travis CI 操作的内容类似于，我们在一台全新的机器上 clone 这个项目后，配置环境依赖，然后生成并部署站点的操作，它包含了这一系列操作所执行的命令，所以不同项目 <code>.travis.yml</code> 文件的内容是不同的，下面是 <a href="https://github.com/wylu/wylu.github.io/blob/dev/.travis.yml">我的配置</a> ，仅供参考：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虚拟机操作系统，xenial 是 Ubuntu 16.04</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">xenial</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 构建环境</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;10.15.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置只检测 dev 分支的 push 操作</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dev</span> <span class="comment"># 只有 dev 分支提交时才运行 Travis CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cache these folders</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 把 node_modules 放入缓存可以节约构建的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start: Build Lifecycle</span></span><br><span class="line"><span class="attr">before_install:</span> <span class="comment"># 配置环境</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span> <span class="comment"># 安装依赖</span></span><br><span class="line">  <span class="comment"># install the plugins in package.json</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="comment"># it will auto export after setting environment variables from repository settings</span></span><br><span class="line">  <span class="comment">#- export HEXO_ALGOLIA_INDEXING_KEY=&quot;$&#123;HEXO_ALGOLIA_INDEXING_KEY&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pwd</span> <span class="comment"># 查看当前工作目录</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="comment"># --flush option used to remove invalid indexes or update some indexes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">algolia</span> <span class="string">--flush</span> <span class="comment"># 更新 algolia search 索引</span></span><br><span class="line">  <span class="comment"># this operation is not required as it will be done by &quot;hexo deploy&quot;</span></span><br><span class="line">  <span class="comment">#- hexo generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$USER_NAME</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$USER_EMAIL</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i&#x27;&#x27;</span> <span class="string">&quot;s~git@github.com:yourname/yourname.github.io.git~https://$&#123;GITHUB_REPO_TOKEN&#125;@github.com/yourname/yourname.github.io.git~&quot;</span> <span class="string">_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line"><span class="comment"># End: Build Lifecycle</span></span><br></pre></td></tr></table></figure>
<p>上面的配置需要根据具体情况修改，如：</p>
<ul>
<li>如果你的源码分支名不是 <code>dev</code>，那么 <code>only:</code> 下的分支名就要改成你相应的分支名。</li>
<li>如果你没有使用 Algolia Search 服务，那么就不需要执行 <code>hexo algolia --flush</code>。</li>
</ul>
<p>最后的 <code>after_success：</code> 中，使用到了我们设置的环境变量的值 <code>USER_NAME</code>、<code>USER_EMAIL</code> 和 <code>GITHUB_REPO_TOKEN</code>。sed 命令将 hexo 的 <code>站点配置文件</code> 中的部署仓库的链接替换成了 access_token 形式，其中前面的 <code>git@github.com:yourname/yourname.github.io.git</code> 是你在 <code>站点配置文件</code> 中的链接，后面的 <code>https://$&#123;GITHUB_REPO_TOKEN&#125;@github.com/yourname/yourname.github.io.git</code> 是 token 形式的链接。</p>
<p><strong>注意：如果你也是部署到 GithubPages，需要将上面全部的 <code>yourname</code> 换成你的 github 用户名。</strong></p>
<p><strong>在 dev 分支下配置完成后，git 提交修改。</strong></p>
<p>如果配置 Travis CI 成功，它会检测到 dev 分支的提交，然后根据 <code>.travis.yml</code> 开始执行构建任务，构建任务完成时，查看构建日志，<strong>如果站点静态文件的生成与部署都没有报错</strong>，而且构建任务的完成状态是绿色的 <code>passed</code> 的话，可以判定构建任务成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a84f86159a0c339a5fcbf5693a545e61.png" alt="travis-ci-build-passed" /></p>
<p>构建过程中的部分日志：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ae05c6521546b5dbeb60121b62d157d7.png" alt="travis-ci-build-log" /></p>
<p><strong>需要注意 <code>hexo deploy</code> 是否真正成功，有时没执行成功，例如最后的 push 失败了，但是构建任务的状态还是绿色的 <code>passed</code>，如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4b54538db9a382713522f7c925b30403.png" alt="travis-ci-push-fail" /></p>
<p>虽然上面的也是 <code>passed</code>，但是却没有成功部署静态页面，下面是成功 push 时打印的日志：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4b98aee354f84939a4e13c9411506435.png" alt="travis-ci-push-success" /></p>
<p>构建历史：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/80e43d7a4bca9831b64bd53f2de284df.png" alt="travis-ci-build-history" /></p>
<h2 id="给项目添加持续集成徽章">给项目添加持续集成徽章</h2>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/deac6a4a1f8148118b71ce95f9c1ca85.png" alt="travis-ci-dev" /></p>
<p>参考 <a href="https://docs.travis-ci.com/user/status-images/">Embedding Status Images</a>，点击上图中右上角的徽章，会弹出一个编辑框，然后选择分支和格式，就会生成对应的链接，将其复制到站点根目录下的 README.md 文件中，推送后效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8e6e371cbf868516983749930e2d4e57.png" alt="travis-ci-build-passing" /></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题进阶配置</title>
    <url>/posts/e0424f3f/</url>
    <content><![CDATA[<p>本文将介绍一些针对 NexT 主题的个性化配置。</p>
<span id="more"></span>
<h1 id="环境及版本声明">环境及版本声明</h1>
<p>本文基于以下环境及版本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">1.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">7.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">OS:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span> <span class="string">LTS</span> <span class="string">x86_64</span></span><br></pre></td></tr></table></figure>
<p><strong>若主题版本不一致，下面的配置方法可能不适用。</strong></p>
<h1 id="设置-rss">设置 RSS</h1>
<p>NexT 中 RSS 有三个设置选项，满足特定的使用场景：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># false：禁用 RSS，不在页面上显示 RSS 连接.</span></span><br><span class="line"><span class="comment"># 留空：使用Hexo生成订阅源并自动插入链接。你可能需要先安装插件: `npm install hexo-generator-feed --save`.</span></span><br><span class="line"><span class="comment"># 具体的链接地址：适用于已烧制过 Feed 的情形.</span></span><br><span class="line"><span class="attr">rss:</span></span><br></pre></td></tr></table></figure>
<p>具体操作如下：</p>
<p>首先在站点根目录下执行下列命令安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>更改 <code>主题配置文件</code>，设定 rss 字段的值如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure>
<p>重新生成、启动服务器显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6a863e31d62150fa37aecbccc3dbe9d0.png" alt="RSS" /></p>
<h1 id="添加-tags-页面">添加 tags 页面</h1>
<p>新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。下面是一篇包含标签的文章的例子：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: QuickSort</span><br><span class="line">date: 2019-04-13 17:49:09</span><br><span class="line">tags: [Java, Sort]</span><br><span class="line">categories:</span><br><span class="line"><span class="section">- [Algorithm, Sort]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">QuickSort Demo</span><br></pre></td></tr></table></figure>
<h2 id="新建页面">新建页面</h2>
<p>在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new page tags</span></span><br><span class="line">INFO  Created: ~/VScode/hexo/source/tags/index.md</span><br></pre></td></tr></table></figure>
<h2 id="设置页面类型">设置页面类型</h2>
<p>编辑刚刚新建的页面（source/tags/index.md），将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-13 17:56:13</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="修改菜单">修改菜单</h2>
<p>在菜单中添加链接。编辑 <code>主题配置文件</code>，添加 tags 到 menu 中，如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h2 id="注意">注意</h2>
<p>如果没有设置页面类型，默认情况下「标签」页面 会被当成普通页面，我们文章的标签信息不会出现在「标签」页面中，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f669e97e808a65a5a1d88e7c84502951.png" alt="default-tags-page" /></p>
<p>在设置了页面类型后，再打开：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/67f906fe63b6197deae058150503d296.png" alt="tags-page" /></p>
<p><strong>如果有集成评论服务，页面也会带有评论。若需要关闭的话，请添加字段 comments 并将值设置为 false，如：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-13 17:56:13</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h1 id="添加-categories-页面">添加 categories 页面</h1>
<p>与 "添加 tags 页面" 类似</p>
<h2 id="新建页面-1">新建页面</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new page categories</span></span><br><span class="line">INFO  Created: ~/VScode/hexo/source/categories/index.md</span><br></pre></td></tr></table></figure>
<h2 id="设置页面类型-1">设置页面类型</h2>
<p>编辑刚刚新建的页面（source/categories/index.md），将页面的类型设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-13 17:57:40</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="修改菜单-1">修改菜单</h2>
<p>在菜单中添加链接。编辑 <code>主题配置文件</code>，添加 tags 到 menu 中，如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h2 id="注意-1">注意</h2>
<p>如果没有设置页面类型，则文章的分类信息不会出现在「分类」页面中，下面是设置了页面类型后的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d5b66158ea1099b3f0a3f5b1928f815d.png" alt="categories-page" /></p>
<p><strong>如果有集成评论服务，页面也会带有评论。若需要关闭的话，请添加字段 comments 并将值设置为 false</strong></p>
<h1 id="设置阅读全文">设置阅读全文</h1>
<p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法实现：</p>
<h2 id="使用----more---">使用 <code>&lt;!-- more --&gt;</code></h2>
<p>在文章中嵌入 <code>&lt;!-- more --&gt;</code> 标记，Hexo 会将其之上的内容作为首页预览内容，这是 Hexo 提供的方式</p>
<h2 id="使用-description">使用 description</h2>
<p>在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录</p>
<h2 id="使用-next-配置">使用 NexT 配置</h2>
<p>如果需要自动形成摘要，则将 <code>auto_excerpt</code> 下的 <code>enable</code> 设置成 <code>true</code>，默认截取的长度为 150 字符，可以根据需要在 <code>主题配置文件</code> 中自行设定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动将页面滚动到&lt;!-- more --&gt;标记下的部分.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Cookie中自动保存每个帖子/页面上的滚动位置.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动摘录 description 作为主页的预览内容.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动摘录（不推荐）.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># 如果为true，则会在摘录部分显示read more按钮.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hexo 建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外，可以让 Hexo 中的插件更好的识别。</p>
</blockquote>
<h1 id="设置文章置顶">设置文章置顶</h1>
<h2 id="默认顺序">默认顺序</h2>
<p>Hexo 默认主页文章按日期降序。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: 博客主页根路径. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: 每页显示文章数量. (0 = 禁用分页)</span></span><br><span class="line"><span class="comment"># order_by: 文章排序. (默认按日期降序)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>
<h2 id="安装-hexo-generator-index-pin-top">安装 <a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a></h2>
<p>首先是卸载默认排序插件，安装新插件，新插件支持文章置顶：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure>
<h2 id="置顶文章">置顶文章</h2>
<p>在需要置顶的文章的 <code>front-matter</code> 中设置 <code>top: 1</code> 即可实现文章置顶功能，并且数字越大文章越靠前，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="section">top: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="添加置顶图标">添加置顶图标</h2>
<p>上面置顶文章会文章排在前面，但是不会有任何有关 "置顶" 的标识。我们可以修改 NexT 主题的<code>/themes/next/layout/_macro/post.swig</code> 文件，在 <code>&lt;div class="post-meta"&gt;</code> 下加入 "置顶" 标识，如图标和文字描述：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>此时的效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0f970802dea04d4ad860483537326452.png" alt="sticky" /></p>
<h1 id="设置代码块高亮">设置代码块高亮</h1>
<p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night，night blue，night bright，night eighties，对应的展示效果可到 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 查看：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure>
<h1 id="启用代码块复制功能">启用代码块复制功能</h1>
<p>编辑 <code>主题配置文件</code>，启用 <code>codeblock</code> 模块，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Manual define the border radius in codeblock, leave it blank for the default value: 1</span></span><br><span class="line">  <span class="attr">border_radius:</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Style: only &#x27;flat&#x27; is currently available, leave it blank if you prefer default theme</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/94da904774ea7c6622d75349f186d611.png" alt="codeblock-copy" /></p>
<p>设置 <code>copy_button: true</code>，启用复制按钮；同时设置 <code>show_result: true</code>，显示代码复制结果。</p>
<h1 id="修改文章链接样式">修改文章链接样式</h1>
<p>打开文件 <code>/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加以下 CSS 样式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>颜色可自定义，在这里选中状态为橙色，链接样式为蓝色，效果如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ccca2b9227cb2d7c89beba1691a931ce.png" alt="link-style" /></p>
<h1 id="修改文章底部标签样式">修改文章底部标签样式</h1>
<p>打开模板文件 <code>/themes/next/layout/_macro/post.swig</code>，找到 <code>for tag in post.tags</code> 部分，将 <code>#</code> 换成 <code>&lt;i class="fa fa-tag"&gt;&lt;/i&gt;</code>，如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for tag in post.tags %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>修改后，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6f19e3d7fa72f87f770c3a3d9b20b093.png" alt="bottom-tags-style" /></p>
<h1 id="统一添加文章结束标记">统一添加文章结束标记</h1>
<p>在 <code>/themes/next/layout/_macro</code> 下新建 <code>passage-end-tag.swig</code> 文件，并添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;</span>-------------本文结束 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 感谢阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开 <code>/themes/next/layout/_macro/post.swig</code> 文件，在 <code>END POST BODY</code> 后面引入 <code>passage-end-tag.swig</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.passage_end_tag.enable and not is_index %&#125;</span><br><span class="line">  &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>主题配置文件</code> _config.yml 的末尾添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章结束标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="comment"># 是否显示文章结束标记</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>该配置为自定义配置，与上面的代码配套使用，方便通过简单的配置来启用或者关闭文章结束标记。显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0a8565a0f258b56d9a3594deaa6227e0.png" alt="passage-end-tag" /></p>
<h1 id="添加版权信息">添加版权信息</h1>
<p>编辑 <code>主题配置文件</code>，修改如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># 许可证的可用值: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># 如果你喜欢CC许可证的翻译版本，可以设置 lanuage 的值.</span></span><br><span class="line"><span class="comment"># CC许可证有39种语言版本，你可以根据需要找到特定的正确的缩写.</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="comment"># 是否在侧边栏显示版权信息</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否在文章底部显示版权信息</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 可以设置CC许可证的翻译版本</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<p><code>by-nc-sa</code> 表示 <code>署名-非商业性使用-相同方式共享</code>，更加详细的解释请查阅官网 <a href="https://creativecommons.org/licenses/?lang=zh">creativecommons.org</a></p>
<p>设置 <code>sidebar: true</code> 后，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/884c30540f5e9b2bd1841eb605d2a74e.png" alt="CC-sidebar" /></p>
<p>设置 <code>post: true</code> 后，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/03a34a8a35a4f2a94968102af15ad386.png" alt="CC-passage-bottom" /></p>
<p>如果需要自定义文章底部版权信息的，可以自行修改 /themes/next/layout/_partials/post/post-copyright.swig 文件。</p>
<h1 id="设置打赏功能">设置打赏功能</h1>
<p>首先将你的 <code>WeChat Pay</code> / <code>Alipay</code> / <code>Bitcoin</code> 的收款二维码图片放到 <code>/themes/next/source/images</code> 文件夹下，或者上传到图床并获取它们的绝对 HTTP 地址。</p>
<p>编辑 <code>站点配置文件</code>，启用打赏功能，例如选择使用微信支付和支付宝：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># 如果为true，则默认会在每篇文章底部显示打赏.</span></span><br><span class="line">  <span class="comment"># 你可以通过在 Front-matter 中设置 `reward: true | false` 在特定文章中显示或隐藏打赏.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">坚持原创技术分享，您的支持将鼓励我继续创作！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.jpg</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/524e8f2608583b918cc133a50a8cf912.png" alt="reward" /></p>
<p>点击打赏按钮：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cf295270c65c6b1970adfbbd65fe95ee.png" alt="click-reward" /></p>
<h1 id="设置站点背景">设置站点背景</h1>
<p>NexT 默认提供3种背景配置，但都需要安装依赖。<strong>以下配置均不修改 <code>vendors:</code> 下的内容。</strong></p>
<h2 id="canvas-nest-背景">Canvas-nest 背景</h2>
<h3 id="step-1">Step 1</h3>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h3 id="step-2">Step 2</h3>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure>
<h3 id="step-3">Step 3</h3>
<p>编辑 <code>主题配置文件</code>，启用 <code>cavas_nest</code> 模块，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span> <span class="comment"># 是否在手机上显示</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;0,0,255&quot;</span> <span class="comment"># RGB颜色值, 用 &#x27;,&#x27; 分隔</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># 线条透明度: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># 背景的 z-index 属性值</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># 线条数量</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>站点根目录下</strong> 启动服务器，显示效果如下（其它设置可根据需要自行修改）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b4ff0844867fb472858a5aa828bc7747.png" alt="canvas-nest" /></p>
<h2 id="javascript-3d-library-背景">JavaScript 3D library 背景</h2>
<h3 id="step-1-1">Step 1</h3>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h3 id="step-2-1">Step 2</h3>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-three source/lib/three</span><br></pre></td></tr></table></figure>
<h3 id="step-3-1">Step 3</h3>
<p>编辑 <code>主题配置文件</code>，设 <code>three_waves</code>，<code>canvas_lines</code>，<code>canvas_sphere</code> 其中一项为 <code>true</code>，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>站点根目录下</strong> 启动服务器，<code>three_waves</code> 显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6a978684816a16a4030afde92a3e979d.png" alt="three-waves" /></p>
<p><code>canvas_lines</code> 效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3520b20f81c09c280f976da05a6f2f64.png" alt="canvas-lines" /></p>
<p><code>canvas_sphere</code> 效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dca998ed8e376cf7116969be13262790.png" alt="canvas-sphere" /></p>
<h2 id="canvas-ribbon-背景">Canvas-ribbon 背景</h2>
<h3 id="step-1-2">Step 1</h3>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h3 id="step-2-2">Step 2</h3>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-ribbon source/lib/canvas-ribbon</span><br></pre></td></tr></table></figure>
<h3 id="step-3-2">Step 3</h3>
<p>编辑 <code>主题配置文件</code>，启用 <code>canvas_ribbon</code> 模块，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span></span><br><span class="line"><span class="comment"># size: ribbon的宽度.</span></span><br><span class="line"><span class="comment"># alpha: ribbon的透明度.</span></span><br><span class="line"><span class="comment"># zIndex: ribbon的显示级别.</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>站点根目录下</strong> 启动服务器，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/07c4f937823e9d2878bd8f2399c0fc6a.png" alt="canvas-ribbon" /></p>
<h1 id="设置左上角或右上角-github-图标">设置左上角或右上角 github 图标</h1>
<h2 id="开启默认设置">开启默认设置</h2>
<p>NexT 支持通过配置开启右上角 github 图标，编辑 <code>主题配置文件</code>，启用 github-banner 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 点击即跳转到该链接，自行设定</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span></span><br><span class="line">  <span class="comment"># 当鼠标悬浮于上方时显示的文本</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/083b63ce1740296767946e649baaf23c.png" alt="github-banner" /></p>
<h2 id="进阶自定义设置">进阶自定义设置</h2>
<p>自定义配置使其可以使用 <a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a> 和 <a href="http://tholman.com/github-corners/">GitHub Corners</a> 中的任何一款图标。</p>
<p>修改 <code>/themes/next/layout/_partials/github-banners.swig</code> 文件内容如下：</p>
<p><a href="https://github.com/wylu/cdn/blob/master/next/swig/github-banner.swig">github-banner.swig</a></p>
<p>同时编辑 <code>站点配置文件</code>，修改 <code>github_banner</code> 部分如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-left or top-right corner.</span></span><br><span class="line"><span class="comment"># `Fork me on GitHub` banner in the top-left or top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/wylu</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line">  <span class="comment"># Available values of ribbons:</span></span><br><span class="line">  <span class="comment"># See: https://github.blog/2008-12-19-github-ribbons/</span></span><br><span class="line">  <span class="comment"># ribbons-left-red | ribbons-left-green | ribbons-left-darkblue</span></span><br><span class="line">  <span class="comment"># ribbons-left-orange | ribbons-left-gray | ribbons-left-white</span></span><br><span class="line">  <span class="comment"># ribbons-right-red | ribbons-right-green | ribbons-right-darkblue</span></span><br><span class="line">  <span class="comment"># ribbons-right-orange | ribbons-right-gray | ribbons-right-white</span></span><br><span class="line">  <span class="comment"># Available values of corners:</span></span><br><span class="line">  <span class="comment"># See: http://tholman.com/github-corners/</span></span><br><span class="line">  <span class="comment"># corners-right-black | corners-right-green | corners-right-red</span></span><br><span class="line">  <span class="comment"># corners-right-blue | corners-right-white</span></span><br><span class="line">  <span class="comment"># corners-left-black | corners-left-green | corners-left-red</span></span><br><span class="line">  <span class="comment"># corners-left-blue | corners-left-white</span></span><br><span class="line">  <span class="comment"># If not set, it will use NexT default style.</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line">  <span class="comment"># You can set size of banner.</span></span><br><span class="line">  <span class="comment"># Default values for ribbons: width = height = 120</span></span><br><span class="line">  <span class="comment"># Default values for corners: width = height = 80</span></span><br><span class="line">  <span class="attr">size:</span></span><br><span class="line">  <span class="comment"># whether to display on the mobile side.</span></span><br><span class="line">  <span class="comment"># If use left banner, you should better set it &quot;false&quot; as the banner will cover menu button.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样你就可以通过 <code>type</code> 随意切换 banner 的样式了。</p>
<h1 id="设置侧栏阅读进度百分比">设置侧栏阅读进度百分比</h1>
<p>编辑 <code>站点配置文件</code>，修改 <code>back2top</code> 部分如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ac3db59f21c3bbf42b7a6dbfef8ab20e.png" alt="sidebar-reading-progress" /></p>
<h1 id="设置顶部阅读进度条">设置顶部阅读进度条</h1>
<h2 id="step-1-3">Step 1</h2>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h2 id="step-2-3">Step 2</h2>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</span><br></pre></td></tr></table></figure>
<h2 id="step-3-3">Step 3</h2>
<p>编辑 <code>主题配置文件</code>，启用 <code>reading_progress</code> 模块，如下：</p>
<p><strong>注意：不是<code>vendors:</code>下的<code>reading_progress</code></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-reading-progress</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">2px</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dc42eca74ccfbedb9cbba2ae0cbad195.png" alt="top-reading-progress" /></p>
<h1 id="设置顶部页面加载进度条">设置顶部页面加载进度条</h1>
<h2 id="step-1-4">Step 1</h2>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h2 id="step-2-4">Step 2</h2>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>
<h2 id="step-3-4">Step 3</h2>
<p>编辑 <code>主题配置文件</code>，启用 <code>pace</code> 模块，如下：</p>
<p><strong>注意：不是<code>vendors:</code>下的<code>pace</code></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment"># pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom</span></span><br><span class="line"><span class="comment"># pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment"># pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure>
<h1 id="设置阅读位置标记功能">设置阅读位置标记功能</h1>
<blockquote>
<p>Bookmark 是一个插件，允许用户保存他们的阅读位置。只需单击页面左上角的书签图标（如书签）即可保存阅读位置，当他们下次访问您的博客时，他们可以通过单击主页上的书签图标继续读取最后一个位置。</p>
</blockquote>
<p><strong>注意：实测当站点语言设置为 <code>en</code> 时，该功能不能正常使用，若设置为 <code>zh-CN</code> 可以正常使用，其它语言未测试。</strong></p>
<h2 id="step-1-5">Step 1</h2>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h2 id="step-2-5">Step 2</h2>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark</span><br></pre></td></tr></table></figure>
<h2 id="step-3-5">Step 3</h2>
<p>编辑 <code>主题配置文件</code>，启用 <code>bookmark</code> 模块，如下：</p>
<p><strong>注意：不是 <code>vendors:</code> 下的 <code>bookmark</code></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bookmark Support</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-bookmark</span></span><br><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, save the reading position when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/490e68c798058d770101c3c669e38d40.png" alt="bookmark-save-reading-position" /></p>
<h1 id="启用数学公式渲染引擎">启用数学公式渲染引擎</h1>
<p>编辑 <code>主题配置文件</code>，修改 <code>bookmark</code> 配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front Matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="comment">#engine: katex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line">    <span class="comment">#cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="comment">#mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span><br><span class="line">    <span class="comment">#mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) needed to full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css</span></span><br><span class="line">    <span class="comment">#cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">copy_tex:</span></span><br><span class="line">      <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">copy_tex_js:</span> <span class="string">//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js</span></span><br><span class="line">      <span class="attr">copy_tex_css:</span> <span class="string">//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a0d0c6eae1a5bac306c2ec902a1494b3.png" alt="math-equations-render" /></p>
<p>设置 <code>enable: true</code>，即启用引擎渲染数学公式。<code>per_page</code> 表示是否自动渲染每一页，如果为 <code>true</code> 则只渲染 <code>front-matter</code> 中包含 <code>mathjax: true</code> 的文章。例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2019-04-12 17:49:09</span><br><span class="line">top: 1</span><br><span class="line"><span class="section">mathjax: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>要想更好的支持 mathjax 需要安装 hexo-rendering-pandoc (或者 hexo-renderer-kramed)，详见 <a href="https://wylu.github.io/posts/78c745f0/">Hexo相关问题和优化</a> 中有关数学公式渲染的说明。</p>
<h1 id="设置字数统计和预计阅读时间">设置字数统计和预计阅读时间</h1>
<p>包括文章字数统计、预计阅读时间，和页面底部站点总字数统计、总阅读时间预计。</p>
<blockquote>
<p>Symbols count and time to read of articles.</p>
<p>Better than <code>hexo-reading-time</code> and faster than <code>hexo-worcount</code>. No external dependencies.</p>
</blockquote>
<p>插件 <code>hexo-symbols-count-time</code> 的使用说明详见 <a href="https://github.com/theme-next/hexo-symbols-count-time">https://github.com/theme-next/hexo-symbols-count-time</a></p>
<h2 id="step-1-6">Step 1</h2>
<p>进入到工程目录下，安装 Hexo 插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<h2 id="step-2-6">Step 2</h2>
<p>编辑 <code>站点配置文件</code>，添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo plugin: hexo-symbols-count-time</span></span><br><span class="line"><span class="comment"># https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment"># 文章预计阅读时间</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment"># 页面底部站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment"># 页面底部站点总阅读时间预计</span></span><br></pre></td></tr></table></figure>
<h2 id="step-3-6">Step 3</h2>
<p>此插件集成在 NexT 主题中，在 Hexo <code>站点配置文件</code> 中启用插件后，你可以调整 NexT 配置中的选项，查看 <code>主题配置文件</code>，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span> <span class="comment"># 文章统计结果是否独立一行显示</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span> <span class="comment"># 是否展示文章统计结果的文本</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 是否展示站点统计结果的文本</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dc963651272ae5d65985ca42a954c633.png" alt="paper-symbols-count-time" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4a75d49b72160644d0d383c7a6a6d35e.png" alt="site-symbols-count-time" /></p>
<p>如果 <code>separated_meta: false</code>，则效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f42d78f41dd1ee30ff8469ded63ee026.png" alt="no-separated-symbols-count-time" /></p>
<ul>
<li><p><code>awl</code></p>
平均字长（平均一个字的字符数），默认值：4。
<ul>
<li>CN≈2</li>
<li>EN≈5</li>
<li>RU≈6</li>
</ul></li>
<li><p><code>wpm</code></p>
每分钟阅读字数，默认值：275。
<ul>
<li>慢≈200</li>
<li>正常≈275</li>
<li>快≈350</li>
</ul></li>
</ul>
<blockquote>
<p>中国用户注意事项：因为中文平均字长约为 1.5，如果你大多数情况下用中文写帖子（没有混合英文），建议将 awl 设置为 2，将 wpm 设置为 300。但是，如果你通常将你的帖子与英语混合，那么 awl 到 4 和 wpm 到 275 就会很好。</p>
</blockquote>
<h1 id="添加-live2d-看板娘-萌宠">添加 Live2D 看板娘 萌宠</h1>
<p>插件 <code>hexo-helper-live2d</code> 的使用说明详见 <a href="https://github.com/EYHN/hexo-helper-live2d">https://github.com/EYHN/hexo-helper-live2d</a></p>
<p><strong>详细配置过程及说明推荐参考 Miaia 的博客 <a href="https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/">用Live2D让看板喵入住你的Hexo博客吧(<sup>o</sup>)/~</a></strong></p>
<h2 id="step-1-7">Step 1</h2>
<p>进入到工程目录下，安装 Hexo 插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure>
<h2 id="step-2-7">Step 2</h2>
<p>在 <a href="https://huaji8.top/post/live2d-plugin-2.0/">插件作者的博客</a> 中挑选一个模型，记录该模型的名字。模型资源名称为 <code>live2d-widget-model-模型名称</code>，例如选择模型 <code>shizuku</code> ，则其对应的 Live2D 资源名称为 <code>live2d-widget-model-shizuku</code>，然后直接在站点根目录下安装该模型，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku --save</span><br></pre></td></tr></table></figure>
<h2 id="step-3-7">Step 3</h2>
<p>编辑 <code>站点配置文件</code>，添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo plugin: hexo-helper-live2d</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># Root path of plugin to be on the site (Relative)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># JavaScript path related to plugin&#x27;s root (Relative)</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># Relative model path related to plugin&#x27;s root (Relative)</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># Default</span></span><br><span class="line">  <span class="comment">#scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment">#scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment">#scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # Your custom url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># Whether only to replace live2d tag instead of inject to all pages</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span> <span class="comment"># Whether to show logs in console</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-shizuku</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment">#use: wanko # folder name in (hexo base dir)/live2d_models/</span></span><br><span class="line">    <span class="comment">#use: ./wives/wanko # folder path relative to hexo base dir</span></span><br><span class="line">    <span class="comment">#use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # Your custom url</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-10</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.05</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure>
<p>执行命令 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c5254dee956d1a569497f496a54ecac.png" alt="live2d" /></p>
<p>配置项说明，摘自 Miaia 博客 <a href="https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/">用Live2D让看板喵入住你的Hexo博客吧(<sup>o</sup>)/~</a></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 6%" />
<col style="width: 29%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">配置项</th>
<th style="text-align: left;">类型</th>
<th style="text-align: left;">属性</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">enable</td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;"><code>true</code>或者<code>false</code></td>
<td style="text-align: left;">控制live2d插件是否生效。</td>
</tr>
<tr class="even">
<td style="text-align: left;">scriptFrom</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;"><code>local</code>或者<code>jsdelivr</code>或者<code>unpkg</code></td>
<td style="text-align: left;">l2dwidget.js使用的CDN地址，local表示使用本地地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pluginRootPath</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>live2dw/</code></td>
<td style="text-align: left;">插件在站点上根目录的相对路径。</td>
</tr>
<tr class="even">
<td style="text-align: left;">pluginJsPath</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>lib/</code></td>
<td style="text-align: left;">脚本文件相对与插件根目录路径。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pluginModelPath</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>assets/</code></td>
<td style="text-align: left;">模型文件相对与插件根目录路径。</td>
</tr>
<tr class="even">
<td style="text-align: left;">tagMode</td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;"><code>true</code>或者<code>false</code></td>
<td style="text-align: left;">标签模式, 控制是否仅替换tag标签而非插入到所有页面中。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">debug</td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;"><code>true</code>或者<code>false</code></td>
<td style="text-align: left;">调试模式, 控制是否在控制台输出日志。</td>
</tr>
<tr class="even">
<td style="text-align: left;">model.use</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>live2d-widget-model-hijiki</code></td>
<td style="text-align: left;">npm 模块包名（上文例中即使用的这个方式）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">model.use</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>hijiki</code></td>
<td style="text-align: left;">博客根目录/live2d_models/ 下的目录名。</td>
</tr>
<tr class="even">
<td style="text-align: left;">model.use</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>./wives/hijiki</code></td>
<td style="text-align: left;">相对于博客根目录的路径。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">model.use</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">例如：<code>https://域名/model.json</code></td>
<td style="text-align: left;">你自定义live2d模型json文件的url。</td>
</tr>
<tr class="even">
<td style="text-align: left;">model.scale</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>1</code></td>
<td style="text-align: left;">模型与canvas的缩放。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">model.hHeadPos</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0.5</code></td>
<td style="text-align: left;">模型头部横坐标。</td>
</tr>
<tr class="even">
<td style="text-align: left;">model.vHeadPos</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0.618</code></td>
<td style="text-align: left;">模型头部横坐标。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">display.superSample</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>2</code></td>
<td style="text-align: left;">超采样等级。</td>
</tr>
<tr class="even">
<td style="text-align: left;">display.width</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>150</code></td>
<td style="text-align: left;">canvas的长度。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">display.height</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">可选值，默认值为 <code>300</code></td>
<td style="text-align: left;">canvas的高度。</td>
</tr>
<tr class="even">
<td style="text-align: left;">display.position</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>right</code></td>
<td style="text-align: left;">显示位置：左或右。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">display.hOffset</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0</code></td>
<td style="text-align: left;">canvas水平偏移。</td>
</tr>
<tr class="even">
<td style="text-align: left;">display.vOffset</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>-20</code></td>
<td style="text-align: left;">canvas水平偏移。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mobile.show</td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;">可选值，默认值为 <code>true</code></td>
<td style="text-align: left;">控制是否在移动设备上显示。</td>
</tr>
<tr class="even">
<td style="text-align: left;">mobile.scale</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0.5</code></td>
<td style="text-align: left;">移动设备上的缩放。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">react.opacityDefault</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0.7</code></td>
<td style="text-align: left;">默认透明度。</td>
</tr>
<tr class="even">
<td style="text-align: left;">react.opacityOnHover</td>
<td style="text-align: left;">Number</td>
<td style="text-align: left;">可选值，默认值为 <code>0.2</code></td>
<td style="text-align: left;">鼠标移上透明度（此项貌似没有效果）。</td>
</tr>
</tbody>
</table>
<p><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html">官方API文档</a></p>
<h1 id="添加文章分享按钮">添加文章分享按钮</h1>
<h2 id="step-1-8">Step 1</h2>
<p>进入到 NexT 主题目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<h2 id="step-2-8">Step 2</h2>
<p>安装模块到 source/lib 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton</span><br></pre></td></tr></table></figure>
<h2 id="step-3-8">Step 3</h2>
<p>编辑 <code>主题配置文件</code>，启用 <code>needmoreshare2</code> 模块，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NeedMoreShare2</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-needmoreshare2</span></span><br><span class="line"><span class="comment"># iconStyle: default | box</span></span><br><span class="line"><span class="comment"># boxForm: horizontal | vertical</span></span><br><span class="line"><span class="comment"># position: top / middle / bottom + Left / Center / Right</span></span><br><span class="line"><span class="comment"># networks:</span></span><br><span class="line"><span class="comment"># Weibo,Wechat,Douban,QQZone,Twitter,Facebook,Linkedin,Mailto,Reddit,Delicious,StumbleUpon,Pinterest,</span></span><br><span class="line"><span class="comment"># GooglePlus,Tumblr,GoogleBookmarks,Newsvine,Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru</span></span><br><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postbottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">bottomCenter</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">  <span class="attr">float:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">middleRight</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br></pre></td></tr></table></figure>
<p>启用 <code>postbottom</code> 分享按钮，点击按钮效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e840a671c4365c3e5c4e92f72bb1bba2.png" alt="share-post-bottom" /></p>
<p>启用 <code>float</code> 分享按钮，点击按钮效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/92b05a5daf72d55ec9e6b146cc1af68b.png" alt="share-post-float" /></p>
<p><strong>这两个分享按钮可同时启用，也可以单独使用其中一个，其它参数配置效果可自行测试。</strong></p>
<h1 id="设置网页底部信息">设置网页底部信息</h1>
<p>查看 <code>主题配置文件</code>，默认 <code>footer</code> 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo main config will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer.</span></span><br><span class="line">  <span class="comment"># http://www.beian.miit.gov.cn</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Any custom text can be defined here.</span></span><br><span class="line">  <span class="comment">#custom_text: Hosted by &lt;a href=&quot;https://pages.coding.me&quot; class=&quot;theme-link&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Coding Pages&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f987c4b47567eff37c0877720631c457.png" alt="default-site-footer" /></p>
<p><strong>注意：默认是没有 <code>站点总字数</code> 和 <code>站点阅读时长</code> 的，这里有相关显示是因为上面启用了统计功能。</strong></p>
<h2 id="设置建站时间">设置建站时间</h2>
<p>编辑 <code>footer</code> 下的 <code>since</code> 配置如下，例如建站时间为2019，则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># 指定建站日期，若没有定义则使用当前的年份作为建站日期。</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<h2 id="设置版权所有者">设置版权所有者</h2>
<p>编辑 <code>footer</code> 下的 <code>copyright</code> 配置如下，例如版权所有者为 wylu，则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># 如果没有定义, 则站点作者的配置会用于此处。</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">wylu</span></span><br></pre></td></tr></table></figure>
<h2 id="设置建站时间和版权所有者之间的图标">设置建站时间和版权所有者之间的图标</h2>
<p>编辑 <code>footer</code> 下的 <code>icon</code> 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里使用 <code>fa-heart</code> 的图标，并且启用动画和设置 icon 的颜色为红色。</p>
<h2 id="隐藏-hexo-和-next-信息">隐藏 Hexo 和 NexT 信息</h2>
<p>编辑 <code>footer</code> 下的 <code>powered</code> 和 <code>theme</code> 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改完配置后，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e9dc63201adb508ccd88d00ecd633e99.png" alt="custom-site-footer" /></p>
<h1 id="添加站点运行时间">添加站点运行时间</h1>
<p>在 <code>/themes/next/layout/_custom</code> 文件夹下新建一个名称为 <code>site-runtime.swig</code> 的文件，并添加内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;site-runtime&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-clock-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;runtime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">isPC</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> userAgentInfo = navigator.<span class="property">userAgent</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> agents = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; agents.<span class="property">length</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (userAgentInfo.<span class="title function_">indexOf</span>(agents[i]) &gt; <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">siteTime</span>(<span class="params">openOnPC, start</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="string">&quot;siteTime(openOnPC, start)&quot;</span>, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> years = days * <span class="number">365</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#123;% <span class="keyword">if</span> theme.<span class="property">footer</span>.<span class="property">runtime</span>.<span class="property">start</span> %&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      start = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;&#123;&#123; theme.footer.runtime.start &#125;&#125;&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#123;% endif %&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> year = now.<span class="title function_">getFullYear</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> month = now.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> date = now.<span class="title function_">getDate</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> hour = now.<span class="title function_">getHours</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> minute = now.<span class="title function_">getMinutes</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> second = now.<span class="title function_">getSeconds</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diff = now - start;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diffYears = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / years);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diffDays = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff / days) - diffYears * <span class="number">365</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diffHours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days) / hours);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diffMinutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours) / minutes);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> diffSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (openOnPC) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;runtime&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Running: &quot;</span> + diffYears + <span class="string">&quot; years &quot;</span> + diffDays + <span class="string">&quot; days &quot;</span> + diffHours + <span class="string">&quot; hours &quot;</span> + diffMinutes + <span class="string">&quot; mins &quot;</span> + diffSeconds + <span class="string">&quot; secs&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;runtime&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Running: &quot;</span> + diffYears + <span class="string">&quot;y &quot;</span> + diffDays + <span class="string">&quot;d &quot;</span> + diffHours + <span class="string">&quot;h &quot;</span> + diffMinutes + <span class="string">&quot;m &quot;</span> + diffSeconds + <span class="string">&quot;s&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> showOnMobile = &#123;&#123; theme.<span class="property">footer</span>.<span class="property">runtime</span>.<span class="property">mobile</span> &#125;&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> openOnPC = <span class="title function_">isPC</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">siteTime</span>(openOnPC, start);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> (!openOnPC &amp;&amp; !showOnMobile) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;site-runtime&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>编辑文件 <code>/themes/next/layout/_partials/footer.swig</code>，在文件底部添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.runtime.enable %&#125;</span><br><span class="line">  &#123;% include &#x27;../_custom/site-runtime.swig&#x27; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>编辑 <code>主题配置文件</code>，在 <code>footer</code> 下添加如下配置作为其子配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site Runtime</span></span><br><span class="line"><span class="attr">runtime:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The time of the site started running. If not defined, current time of local time zone will be used.</span></span><br><span class="line">  <span class="comment"># You can specify the time zone by adding the `+HOURS` or `-HOURS` format time zone.</span></span><br><span class="line">  <span class="comment"># If not specify the time zone, it will use `+0000` as default.</span></span><br><span class="line">  <span class="comment"># ex: &quot;2015-06-08 07:24:13 +0800&quot;, `+0800` specify that it is the time in the East Eight Time Zone.</span></span><br><span class="line">  <span class="attr">start:</span> <span class="number">2015-06-08 08:00:00</span> <span class="string">+0800</span></span><br><span class="line">  <span class="comment"># Whether to show on the mobile side</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2db816845000ffe330f38f9d7c6a5afe.png" alt="site-runtime" /></p>
<p><strong>注意：<code>runtime</code> 必须在 <code>footer</code> 下才能正常工作，与 <code>footer</code> 下的 <code>theme</code> 是平级关系，该配置支持设置是否在移动端显示，不支持修改展示文本语言。对于要修改展示文本语言的，可以直接修改 <code>site-runtime.swig</code> 文件。</strong></p>
<h1 id="添加鼠标点击效果">添加鼠标点击效果</h1>
<h2 id="爱心点击效果">爱心点击效果</h2>
<p>在 <code>/themes/next/source/js/src</code> 下新建文件 <code>love.js</code>，接着把该 <a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js">链接</a> 下的 js 代码复制到 <code>love.js</code> 文件中。如果链接失效，可以到 <a href="https://github.com/wylu/cdn/blob/master/next/js/love.js">博主Github</a> 复制。如果没有 <code>src</code> 目录，则自行手动创建。</p>
<h2 id="烟花点击效果">烟花点击效果</h2>
<p>在 <code>/themes/next/source/js/src</code> 下新建文件 <code>fireworks.js</code>，接着把该 <a href="https://github.com/wylu/cdn/blob/master/next/js/fireworks.js">链接</a> 下的 js 代码复制到 <code>fireworks.js</code> 文件中。</p>
<h2 id="新建-click-animation.swig">新建 <code>click-animation.swig</code></h2>
<p>在 <code>/themes/next/layout/_custom</code> 文件夹下新建文件 <code>click-animation.swig</code>，并添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.click_animation.enable %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function isPC() &#123;</span><br><span class="line">      var userAgentInfo = navigator.userAgent;</span><br><span class="line">      var agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">      for (var i = 0; i &lt; agents.length; i++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(agents[i]) &gt; 0) &#123;</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    var showOnMobile = &#123;&#123; theme.click_animation.mobile &#125;&#125;;</span><br><span class="line">    var openOnPC = isPC();</span><br><span class="line"></span><br><span class="line">    &#123;% if theme.click_animation.style == &quot;love&quot; %&#125;</span><br><span class="line">      if (openOnPC || showOnMobile) $.getScript(&quot;/js/src/love.js&quot;);</span><br><span class="line">    &#123;% elseif theme.click_animation.style == &quot;fireworks&quot; %&#125;</span><br><span class="line">      if (openOnPC || showOnMobile) &#123;</span><br><span class="line">        var newCanvas = $(&#x27;&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed; left: 0; top: 0; z-index: 1; pointer-events: none;&quot;&gt;&lt;/canvas&gt;&#x27;);</span><br><span class="line">        $(&quot;body&quot;).append(newCanvas);</span><br><span class="line">        $.getScript(&quot;http://cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;).done(function (script, textstatus) &#123;</span><br><span class="line">          if (textstatus == &quot;success&quot; &amp;&amp; typeof(anime) != undefined) &#123;</span><br><span class="line">            $.getScript(&quot;/js/src/fireworks.js&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改-_layout.swig">修改 <code>_layout.swig</code></h2>
<p>在 <code>/themes/next/layout/_layout.swig</code> 文件 <code>&lt;body&gt;</code> 标签内的底部添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% include &#x27;_custom/click-animation.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加自定义配置项">添加自定义配置项</h2>
<p>编辑 <code>主题配置文件</code>，在文件末尾添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mouse Click Animation.</span></span><br><span class="line"><span class="attr">click_animation:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values of style: love | fireworks</span></span><br><span class="line">  <span class="comment"># If not define, there will be no click animation even enabled.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">love</span></span><br><span class="line">  <span class="comment"># Whether to show on the mobile side</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当 <code>style: love</code> 时，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cdaa3218fa2b5c59ce814312ee7702a2.png" alt="click-love" /></p>
<p>当 <code>style: fireworks</code> 时，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/10cb612abdc1c2cbc7adbdcf601b13e9.png" alt="click-fireworks" /></p>
<h1 id="添加自定义404页面">添加自定义404页面</h1>
<p>参考 MOxFIVE 博客 <a href="http://moxfive.xyz/2015/10/16/hexo-404-page/">在 Hexo 中创建匹配主题的404页面</a></p>
<p>在站点根目录下，执行如下命令创建404页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>
<p>编辑新建的页面文件，默认在站点根目录下 <code>/source/404/index.md</code>，在 <code>front-matter</code> 中添加 <code>permalink: /404</code>，表示指定该页面固定链接为 <code>http://"主页"/404.html</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">date: 2019-05-07 22:30:57</span><br><span class="line">comments: false</span><br><span class="line"><span class="section">permalink: /404</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span>404 Not Found</span><br><span class="line">对不起，您所访问的页面不存在或者已删除</span><br><span class="line">[<span class="string">点击此处</span>](<span class="link">https://wylu.github.io</span>)返回首页</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 我的Github：[<span class="string">http://github.com/wylu</span>](<span class="link">http://github.com/wylu</span>)</span><br><span class="line"><span class="bullet">*</span> 我的CSDN：[<span class="string">https://blog.csdn.net/qq_32767041</span>](<span class="link">https://blog.csdn.net/qq_32767041</span>)</span><br><span class="line"><span class="bullet">*</span> 给我留言：[<span class="string">https://wylu.github.io/guestbook/</span>](<span class="link">https://wylu.github.io/guestbook/</span>)</span><br></pre></td></tr></table></figure>
<p>在本地打开链接 <a href="http://localhost:4000/404.html">http://localhost:4000/404.html</a> ，如果能看到如下效果，则表示配置成功。<strong>需要注意的是，在本地测试时，当你尝试跳转到一个不存在的页面时，不会显示自定义的404页面，但是当我们将页面部署到 GithubPages 时，它就会使用我们自定义的404页面。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d5c6e4f654644fda640cf55779020b41.png" alt="404-page" /></p>
<h1 id="添加图片放大预览功能">添加图片放大预览功能</h1>
<p>利用 Fancybox 能放大查看图片。</p>
<p>有 <a href="https://github.com/theme-next/theme-next-fancybox">Fancybox2</a> 和 <a href="https://github.com/theme-next/theme-next-fancybox3">Fancybox3</a> 两个版本，这里使用 Fancybox3。</p>
<p>如果已经有 fancybox2 的，需要在站点根目录下执行下列命令进行删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf themes/next/source/lib/fancybox</span><br></pre></td></tr></table></figure>
<p>进入到 <code>themes/next</code> 主题目录下，执行以下命令安装 fancybox3 模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox</span><br></pre></td></tr></table></figure>
<p>编辑 <code>主题配置文件</code>，启用 fancybox，修改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>放大预览效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/18857e7fba96e91b9d1b22284294f9e0.png" alt="fancybox3" /></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT侧边栏配置</title>
    <url>/posts/a2725fd8/</url>
    <content><![CDATA[<p>本文将介绍一些关于 NexT 侧边栏的配置。</p>
<span id="more"></span>
<h1 id="环境及版本声明">环境及版本声明</h1>
<p>本文基于以下环境及版本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">1.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">7.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">OS:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span> <span class="string">LTS</span> <span class="string">x86_64</span></span><br></pre></td></tr></table></figure>
<h1 id="设置侧边栏">设置侧边栏</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 侧边栏位置, 可选值: left | right (仅适用于 Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 手动定义侧边栏宽度. 如果注释，将默认为：</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="comment">#width: 300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏显示, 可选值 (仅适用于 Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    默认行为，在文章页面（拥有目录列表）时显示</span></span><br><span class="line">  <span class="comment">#  - always  在所有页面中都显示</span></span><br><span class="line">  <span class="comment">#  - hide    在所有页面中都隐藏（可以手动展开）</span></span><br><span class="line">  <span class="comment">#  - remove  完全移除</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏相对于顶部菜单栏的偏移量（以像素为单位） (仅适用于 Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  <span class="comment"># 在窄视图上启用侧边栏 (仅适用于 Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 点击页面的任何空白部分关闭侧边栏 (仅适用于 Muse | Mist).</span></span><br><span class="line">  <span class="attr">dimmer:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="设置返回顶部">设置返回顶部</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="comment"># 是否启用点击返回顶部按钮</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否在侧边栏显示点击返回顶部按钮</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 是否在返回顶部按钮显示已滚动百分比</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="设置头像">设置头像</h1>
<p>NexT 默认不会在侧边栏展示头像，你可以在 <code>主题配置文件</code> 中修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 头像资源路径，可以在主题目录下，也可以在站点目录，还可以是网络链接</span></span><br><span class="line">  <span class="comment"># 将头像放至主题目录下 (source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># 将头像放至站点目录下 (source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># 或者任何头像URL: http(s)://example.com/avatar.png</span></span><br><span class="line">  <span class="attr">url:</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># 如果为 true, 头像将会显示为圆形.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 头像透明度，取值从0到1,1表示完全不透明.</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 如果为 true, 当光标移动至头像时，头像会旋转.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="设置作者昵称">设置作者昵称</h1>
<p>编辑 <code>站点配置文件</code>，设置 author 为你的昵称。</p>
<h1 id="设置站点描述">设置站点描述</h1>
<p>编辑 <code>站点配置文件</code>，设置 description 字段为你的站点描述，站点描述也可以是你喜欢的一句签名</p>
<h1 id="设置社交链接">设置社交链接</h1>
<p>侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。两者配置均在 <code>主题配置文件</code> 中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key 是向最终用户显示的链接标签.</span></span><br><span class="line"><span class="comment"># `||` 分隔符之前的值是目标的永久链接.</span></span><br><span class="line"><span class="comment"># `||` 分隔符后面的值是FontAwesome图标的名称。如果未指定图标（带或不带分隔符），则将加载globe图标.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="comment"># 是否启用社交链接图标</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否只显示社交链接图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 是否显示具有转换效果的社交链接图标</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>NexT 内置了多个网站的链接，可以取消想要添加链接的注释，也可以自定义，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">    <span class="attr">Github:</span> <span class="string">https://github.com/wylu</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">    <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/qq_32767041</span> <span class="string">||</span> <span class="string">book</span></span><br></pre></td></tr></table></figure>
<h1 id="设置友情链接">设置友情链接</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="comment"># NexT默认会在links_title之前显示链接图标，你可以使用FontAwesome的其它图标</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="comment"># NexT默认使用Links作为blogroll的名称，你可以自行修改</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="comment"># NexT默认所有blogrolls都以块显示，你可以改为内联</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="comment"># 此处添加你的友情链接</span></span><br><span class="line">  <span class="comment">#Title: http://example.com</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">福利链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">Title1:</span> <span class="string">http://example.com</span></span><br><span class="line">  <span class="attr">Title2:</span> <span class="string">http://example.com</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d4f899906a03a62ae6bb2da4d3d98174.png" alt="links" /></p>
<h1 id="设置文章目录">设置文章目录</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="comment"># 是否启用侧边栏文章目录.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否自动将列表编号添加到TOC.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果为true，如果标题宽度大于侧边栏宽度，则所有单词将放在下一行.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果为true，将显示帖子中的所有TOC级别，而不是其中的激活部分.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 生成的TOC的最大深度. 你可以在一个帖子中通过Front Matter中的`toc_max_depth`设置它.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo配置NexT主题</title>
    <url>/posts/6f2f62d0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/5f9817e7c2fd8745e73fd4788617bba4.png" alt="next-theme" /></p>
<span id="more"></span>
<h1 id="环境及版本声明">环境及版本声明</h1>
<p>本文基于以下环境及版本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">1.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">7.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">OS:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span> <span class="string">LTS</span> <span class="string">x86_64</span></span><br></pre></td></tr></table></figure>
<h1 id="next-主题简介">NexT 主题简介</h1>
<p>NexT is a high quality elegant Hexo theme.</p>
<p>原项目已不再维护</p>
<ul>
<li><a href="https://theme-next.iissnan.com/">NexT文档</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next">Github</a></li>
</ul>
<p>目前使用的是其社区版本</p>
<ul>
<li><a href="https://theme-next.org/docs/getting-started/">NexT文档</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next">Github</a></li>
</ul>
<h1 id="描述约定">描述约定</h1>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 <code>站点配置文件</code>， 后者称为 <code>主题配置文件</code>。</p>
<h1 id="主题选择">主题选择</h1>
<p>Hexo 有许多 <a href="https://hexo.io/themes/">主题</a> 供你选择，总有一款是适合你的，其中 <a href="https://github.com/theme-next/hexo-theme-next">NexT</a> 是一个简洁优雅同时集成了许多功能的主题。</p>
<h1 id="安装-next">安装 NexT</h1>
<p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。NexT 安装步骤如下。</p>
<h2 id="下载主题">下载主题</h2>
<p>在终端窗口下，进入到 Hexo 站点目录下。使用 Git 克隆最新版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>
<h2 id="启用主题">启用主题</h2>
<p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p>
<h2 id="验证主题">验证主题</h2>
<p>执行下列命令启动 Hexo 本地站点，可以加上 <code>--debug</code> 开启调试模式，方便观察异常信息，进而定位错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>
<p>当命令行输出提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>当你看到站点的外观与下图所示类似时说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/2afbbc17939fa78a52fe4d81d7075b8c.png" alt="checking-NexT" /></p>
<h1 id="主题版本管理">主题版本管理</h1>
<p>因为我们的主题是 clone 下来的，所以主题本身也是一个 git 项目，所以当我们尝试在站点根目录下执行 <code>git add</code> 时，是无法加入到我们项目的版本管理的，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">db.json</span><br><span class="line">node_modules</span><br><span class="line">public</span><br><span class="line">Use -f if you really want to add them.</span><br><span class="line">warning: adding embedded git repository: themes/next</span><br><span class="line">hint: You&#x27;ve added another git repository inside your current repository.</span><br><span class="line">hint: Clones of the outer repository will not contain the contents of</span><br><span class="line">hint: the embedded repository and will not know how to obtain it.</span><br><span class="line">hint: If you meant to add a submodule, use:</span><br><span class="line">hint:</span><br><span class="line">hint: 	git submodule add &lt;url&gt; themes/next</span><br><span class="line">hint:</span><br><span class="line">hint: If you added this path by mistake, you can remove it from the</span><br><span class="line">hint: index with:</span><br><span class="line">hint:</span><br><span class="line">hint: 	git rm --cached themes/next</span><br><span class="line">hint:</span><br><span class="line">hint: See &quot;git help submodule&quot; for more information.</span><br></pre></td></tr></table></figure>
<p><strong>警告信息提示我们已在当前仓库添加了另一个 git 仓库，但当我们在其它地方 clone 外部仓库（也即当前仓库）时，它不会 clone 嵌套仓库的内容，也不知道如何获取嵌套仓库的内容。</strong></p>
<p>简单地说，就是外部仓库无法 track 一个嵌套仓库，外部仓库所有的 <code>add</code>，<code>commit</code>，<code>push</code> 都与嵌套仓库没有任何关系。下面介绍 3 种方法来管理我们的主题。</p>
<p><strong>注意：如果你之前尝试添加过嵌套仓库，应该先执行以下命令移除它：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -f --cached themes/next</span><br></pre></td></tr></table></figure>
<h2 id="第1种-将嵌套仓库纳入当前仓库">第1种 将嵌套仓库纳入当前仓库</h2>
<p>最简单直接的方法就是把 themes/next 目录下的 <code>.git</code> 文件夹删掉，这样我们的主题文件夹就是一个普通的目录，而不是一个 git 仓库，这样嵌套仓库的内容就会成为当前仓库内容的一部分，就可以使用 <code>git add</code> 对这些文件进行跟踪。</p>
<h2 id="第2种-使用-git-submodule">第2种 使用 git submodule</h2>
<p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。也许是第三方库，或者你独立开发的，用于多个父项目的库。现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p>
<p>Git 通过子模块来解决这个问题。子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还 <strong>保持提交的独立</strong> 。</p>
<p>具体介绍请参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git-工具-子模块</a></p>
<h3 id="add-一个-submodule">add 一个 submodule</h3>
<p>执行以下命令，使 NexT 成为当前仓库的子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/theme-next/hexo-theme-next themes/next</span></span><br><span class="line">Adding existing repo at &#x27;themes/next&#x27; to the index</span><br></pre></td></tr></table></figure>
<p>执行完成后，会在站点根目录下生成 <code>.gitmodules</code> 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    path = themes/next</span><br><span class="line">    url = https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射，如果有多个子模块，该文件中就会有多条记录。要重点注意的是，该文件应像 <code>.gitignore</code> 文件一样受到（通过）版本控制，和该项目的其他部分一同被拉取推送。有了映射关系，克隆该项目的人就知道去哪获得子模块了。</p>
<p><strong>添加子模块完成后，当在父仓库时，Git 仍然不会跟踪 submodule 的文件， 而是将它看作该仓库中的一个特殊提交。</strong></p>
<p><strong>这种方法适用于使用第三方模块时，我们自己不做任何自定义修改，只是单纯地使用或者希望同步上游的修改的情况。</strong></p>
<blockquote>
<p>官方：项目中使用子模块的最简模型，就是 只使用子项目 并不时地获取更新，而并不在你的检出中进行任何修改。</p>
</blockquote>
<p>显然这种方法并不适合我们的需求，因为我们的 NexT 主题都是需要自定义的，但是这种方法却适用于我们为 NexT 主题管理第三方依赖的情况，因为这些第三方依赖我们一般不会去修改它。</p>
<p>添加了子模块后，就可以像平时一样推送分支了，推送的时候不会包含子模块的文件（意味着你对子模块所做的任何修改都不会被推送，也不会被记录）。假设我们推送到 <code>username.github.io.git</code> 的 dev 分支，可以参考 <a href="https://wylu.github.io/posts/Tool/Hexo/Hexo部署站点至Github">提交源码分支</a></p>
<p><strong>推送到远程仓库后，远程仓库中 submodule 会和指定的 commit 关联起来。</strong></p>
<h3 id="clone-含有子模块的项目">clone 含有子模块的项目</h3>
<p>克隆含有子模块的项目时，默认会包含该子模块目录，但其中没有任何文件，假设现在要 clone 我们刚刚推送的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span> dev分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> -b dev git@github.com:wylu/wylu.github.io.git</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到项目文件夹</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> wylu.github.io</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目注册submodule</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule init</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span> submodule代码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b dev --recursive git@github.com:wylu/wylu.github.io.git</span><br></pre></td></tr></table></figure>
<p><strong>现在 /themes/next 子目录是处在和之前提交时相同的状态了。就算官方的 NexT 仓库有了新提交，也不会有影响，因为子模块指向的 commit 与 push 时指向的 commit 是一致的，也就说在执行 <code>git submodule update</code> 时会 clone 指定 commit 的代码，而不是 clone 最新提交。</strong></p>
<p>例如我当前主题子模块指向的是 hash 以 "71c9e8f" 为开头的提交，并不是官方最新提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8f9f558fda25195afa0dcdd74ec8c414.png" alt="submodule-commit" /></p>
<p>这个提交的完整 hash 为 "71c9e8fc1056bc070d22461696b1078d6419caf5"</p>
<h3 id="update-项目子模块">update 项目子模块</h3>
<p>只要在 子模块 的目录下，所有的常规 Git 操作，如 push，pull，reset，status等，都可以正常工作，假设现在我们要同步子模块 NexT 的更新，只要在 /themes/next 目录下执行 <code>git pull</code> 即可。</p>
<ul>
<li>如果你得到一个错误信息，说你不在任何分支之上，只要运行 <code>git checkout master</code> 就可修复</li>
<li>如果你在 pull 后 submodule 有一些更新, 父仓库会告诉你有一些变动需要 commit 了。submodule 自身指向一个指定的 commit, 并且如果这个 commit 改变了, 父仓库会得知这个改变。如果你的 submodule 需要在一个指定 commit 上工作, 可用 <code>git reset</code> 来恢复。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 419caf5</span><br></pre></td></tr></table></figure>
<p>直接指向 子模块 历史的某次 commit 即可。</p>
<h2 id="第3种-创建自己的主题仓库">第3种 创建自己的主题仓库</h2>
<p>将 Hexo 项目 与自定义的 NexT 主题项目分仓库管理。</p>
<p>首先，<code>fork</code> NexT 主题仓库到自己的 github，然后 <code>clone</code> 该仓库到本地。</p>
<p>然后自定义 NexT 主题，接着提交我们对 NexT 主题的修改，<code>push</code> 到我们自己的远程主题仓库。</p>
<p>而对于 Hexo 源码仓库同样使用 git submodule 的方式管理我们自定义的主题模块，此时子模块的URL应该映射到你自己的仓库，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">    path = themes/next</span><br><span class="line">    url = https://github.com/username/hexo-theme-next</span><br><span class="line">    # The submodule will never be considered modified</span><br><span class="line">    # (but will nonetheless show up in the output of status and commit when it has been staged).</span><br><span class="line">    ignore = all</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里添加了 <code>ignore</code> 配置项并设置为 <code>all</code>，它的可选值及含义如下：</strong></p>
<ul>
<li>all：子模块永远不会被视为已修改（但仍将显示在状态输出中并在提交时提交）。</li>
<li>dirty：将忽略对子模块工作树的所有更改，仅考虑子模块的HEAD与其在超级项目中的记录状态之间的已提交差异。</li>
<li>untracked：只有子模块中未跟踪的文件才会被忽略。将显示对跟踪文件的提交的差异和修改。</li>
<li>none：默认选项，不会忽略对子模块的修改，显示所有已提交的差异以及对已跟踪和未跟踪文件的修改。</li>
</ul>
<p>因为我们的自定义主题仓库和 Hexo 项目仓库是分开提交的，所以 Hexo 项目的提交不需要关注子模块的修改，而子模块的修改直接在其目录下提交即可。这样就可以管理我们自定义的主题，同时保持 Hexo 项目和自定义主题提交的独立。</p>
<h1 id="选择-scheme">选择 Scheme</h1>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持4种 Scheme，他们是：</p>
<p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 看起来像 Pisces，但是列块带有更加明显的阴影，视觉上更敏感</p>
<p>Scheme 的切换通过更改 <code>主题配置文件</code>，搜索 scheme 关键字。你会看到有4行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>每种 Schemes 的效果可以到 Github <a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/README.md#%E5%8D%B3%E6%97%B6%E9%A2%84%E8%A7%88">预览示例</a></p>
<h1 id="设置主题语言">设置主题语言</h1>
<p>首先，需要编辑 <code>站点配置文件</code>， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>然后若要修改具体显示的文本，则到 /themes/next/languages 文件夹下找到指定语言的文件，根据需要修改里面字段的值即可。</p>
<p>例如，修改 zh-CN.yml 文件中 <code>home</code> 对应的值如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">(^_^)</span></span><br></pre></td></tr></table></figure>
<p>默认为"主页"，这里我们改成"(^_^)"，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/344960fb309535f6577f9f5b5f4c0908.png" alt="language-setting" /></p>
<p>NexT 常用语言如下：</p>
<table>
<thead>
<tr class="header">
<th>Language</th>
<th>Code</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr class="even">
<td>简体中文</td>
<td>zh-CN</td>
<td>language: zh-CN</td>
</tr>
<tr class="odd">
<td>繁體中文</td>
<td>zh-TW or zh-HK</td>
<td>language: zh-TW</td>
</tr>
</tbody>
</table>
<p>目前 NexT 支持的语言，详见 <a href="https://theme-next.org/docs/getting-started/">Choosing Language</a></p>
<h1 id="设置菜单">设置菜单</h1>
<p>菜单配置项的格式为 <code>key: /link/ || icon</code>，包含三个部分，第一是菜单项的名称，第二是菜单项的链接，第三是菜单项对应的图标。</p>
<ul>
<li><p>key</p>
<p>key 为菜单项显示的名称（如<code>home</code>，<code>archives</code>等），Hexo 首先会根据 key 在 languages 文件夹找对应语言的翻译，如果找到则会加载该翻译，如果找不到，将使用 key 本身的值。其中 key 的值大小写敏感。</p></li>
<li><p>link</p>
<p>link 是你网站内相对网址的目标链接。</p></li>
<li><p>icon</p>
<p>FontAwesome 图标的名称。NexT 使用的是 <a href="https://fontawesome.com/">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景。</p></li>
</ul>
<p>NexT 默认开启了 <code>主页</code> 和 <code>归档页</code> 菜单项：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0e60b9cd331d695fc2daf19a13070e12.png" alt="default-menu-settings" /></p>
<h2 id="next-默认菜单项">NexT 默认菜单项</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>link</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>home</td>
<td>/</td>
<td>主页</td>
</tr>
<tr class="even">
<td>about</td>
<td>/about/</td>
<td>关于</td>
</tr>
<tr class="odd">
<td>tags</td>
<td>/tags/</td>
<td>标签</td>
</tr>
<tr class="even">
<td>categories</td>
<td>/categories/</td>
<td>分类</td>
</tr>
<tr class="odd">
<td>archives</td>
<td>/archives/</td>
<td>归档</td>
</tr>
<tr class="even">
<td>schedule</td>
<td>/schedule/</td>
<td>日程表</td>
</tr>
<tr class="odd">
<td>sitemap</td>
<td>/sitemap.xml</td>
<td>站点地图</td>
</tr>
<tr class="even">
<td>commonweal</td>
<td>/404/</td>
<td>404页面</td>
</tr>
</tbody>
</table>
<p>可以根据需要取消菜单项的注释，这样就可以在菜单栏看到相应的菜单项了，你也可以添加新的菜单项，然后设置菜单项的显示文本，例如取消注释 <code>about</code>，<code>tags</code>，<code>categories</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/03d2a3bc68ccbe5776bae52a125a9e48.png" alt="about-tags-categories" /></p>
<h2 id="设置菜单项显示文本">设置菜单项显示文本</h2>
<p><strong>在菜单设置中的 <code>key</code> 并不直接用于界面上的展示。Hexo 在生成的时候将使用这个 <code>key</code> 查找对应的语言翻译，并提取显示文本。</strong> 这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。</p>
<p>以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-CN.yml，在 menu 字段下添加一项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br><span class="line">  <span class="attr">something:</span> <span class="string">有料</span></span><br></pre></td></tr></table></figure>
<h2 id="设置菜单项图标">设置菜单项图标</h2>
<p>默认情况下，NexT 显示没有徽章的菜单项图标。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>如果不想显示图标可以设置 icons 为 false，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">icons:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/255376cd7f83e09e9fb74e49697b432e.png" alt="without-menu-icons" /></p>
<p>如果启用徽章，那么在菜单栏会显示 Posts / Categories / Tags 的计数，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d13981a985b2c5a07bb76e55a525a969.png" alt="enable-badges" /></p>
<h1 id="新建-about-页面">新建 about 页面</h1>
<p>在启用 <code>about</code> 或者 <code>关于</code> 菜单项后，因为我们没有提供 about 页面或者配置的目标链接与实际页面位置不匹配，所以点击该菜单项时会提示无法获取 <code>about</code> 页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br></pre></td></tr></table></figure>
<p>因为这里 <code>about</code> 菜单项的目标链接是 <code>/about/</code>，所以正确的文件结构是，在 source 文件夹下包含文件夹 about，about 文件夹下包含 index.md 文件。</p>
<p>直接在站点根目录下执行，该命令会在 source 文件夹下生成 about 文件夹及相关页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>如果你在 <code>站点配置文件</code> 中设置了 <code>post_asset_folder: true</code>，那么生成的 about 文件夹的文件结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── about</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── index.md</span><br><span class="line">└── _posts</span><br><span class="line">    └── hello-world.md</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>如果 <code>post_asset_folder: false</code>，那么生成的 about 文件夹的文件结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── about</span><br><span class="line">│   └── index.md</span><br><span class="line">└── _posts</span><br><span class="line">    └── hello-world.md</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>默认生成的 index.md 文件内容如下，你可以根据需要修改文件的 <code>Front-matter</code> 同时添加内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line"><span class="section">date: 2019-04-13 17:09:44</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="设置站点图标">设置站点图标</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，Hexo 站点使用 hexo-site/themes/next/source/images/ 目录中的 NexT favicons，不同的设备使用不同大小的 NexT favicons。你可以用你自己的图标替换它们。</p>
<p>例如，可以将你的 favicons 放在 hexo-site/source/images/ 目录中。然后，你需要重命名它们，并更改 <code>主题配置文件</code> 中 favicon 部分的设置，否则来自 Next 的图标将在 Hexo 中覆盖你的自定义图标。你还可以将自定义的 favicons 放入 hexo-site/source/ 目录中。这样，你必须在配置路径时删除 /images 前缀。</p>
<p>要生成自定义的 Favicon，可以访问 <a href="https://realfavicongenerator.net/">Favicon Generator</a>。</p>
<h1 id="references">References</h1>
<p><a href="https://incoder.org/2018/05/17/git-sub/">https://incoder.org/2018/05/17/git-sub/</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97</a></p>
<p><a href="https://git-scm.com/docs/gitmodules">https://git-scm.com/docs/gitmodules</a></p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署站点至Github</title>
    <url>/posts/27298702/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d0cbc052140d7821f4a458e3c8b4396b.png" alt="github-pages" /></p>
<span id="more"></span>
<h1 id="github-pages-简介">Github Pages 简介</h1>
<p><a href="https://pages.github.com/">Github Pages 官网</a></p>
<p><a href="https://help.github.com/en/articles/what-is-github-pages">GitHub Pages</a> 是一种静态站点托管服务，旨在直接从 GitHub 存储库托管您的个人，组织或项目页面。</p>
<h1 id="创建-github-pages-仓库">创建 Github Pages 仓库</h1>
<p>转到 <a href="https://github.com/">GitHub</a> 并<a href="https://github.com/new">创建</a>一个名为 <code>username.github.io</code> 的新仓库，其中 username 是您在 GitHub 上的用户名（或组织名称）。<strong>如果仓库名的第一部分（username 部分）与您的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b43a155c9bf24a198b351b4fb56dd441.png" alt="new-github-pages-repo" /></p>
<h1 id="配置-ssh-key">配置 SSH Key</h1>
<p>SSH Key 是你的身份凭证，拥有密钥你才能向仓库推送修改，如果无需任何凭证就能推送，那么谁都可以向你的仓库推送修改。如果已经配置过了就无需再配置，如果没有配置过或者需要重新配置的，请进行以下操作。</p>
<h2 id="配置用户信息">配置用户信息</h2>
<p>初次运行 Git 前需要配置用户信息，一个是你个人的用户名称，一个是你的电子邮件地址。如果已配置则可以跳过。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>
<h2 id="检查是否已有-ssh-key">检查是否已有 SSH Key</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>ls</code> 或 <code>ll</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure>
<p>看是否存在 id_rsa 和 id_rsa.pub 文件（或者是其它文件名），如果存在说明已有 ssh key，可以直接跳过生成密钥，其中 id_rsa 为私钥，id_rsa.pub 为公钥。</p>
<h2 id="生成-ssh-key">生成 SSH Key</h2>
<p>执行下列命令，三次回车确认</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="添加-ssh-key-到-github">添加 SSH Key 到 Github</h2>
<ul>
<li>登录 github，点击头像，点击 Settings 进入设置页面</li>
<li>然后点击菜单栏的 SSH Key 进入页面添加 SSH Key</li>
<li>点击 New SSH Key 按钮后进行 Key 的填写，其中 Title 随意，Key 为刚刚生成的公钥，公钥在文件 id_rsa.pub 文件中，直接 copy 文件中的内容粘贴即可</li>
</ul>
<h2 id="测试-ssh-key">测试 SSH Key</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>
<p>直接输入 yes 回车，如果提示以下内容说明已配置成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h1 id="安装-hexo-git-插件">安装 Hexo git 插件</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h1 id="分支管理说明">分支管理说明</h1>
<p><strong>推荐使用两个分支进行管理，一个分支用于部署站点，一个分支用于实现源代码的版本控制。</strong></p>
<p>当新建一个仓库的时候，仓库将自动包含一个 master 分支。如果将站点部署到 Github Pages，必须配置部署到 <code>username.github.io</code> 的 master 分支，因为现在 Github Pages 已经不支持指定分支进行部署了，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/604e9c09f3a913bf339340780a90d97a.png" alt="branch-manage" /></p>
<p>所以对于托管到 github 的，建议将 hexo 生成的站点文件推送到 master 分支，将源代码推送到另一个分支，如 dev 分支，那么所有的写作和各种配置修改都在 dev 分支下完成，dev 分支就是我们的写作分支。</p>
<blockquote>
<p>这一切是如何发生的？ 当执行 hexo deploy 时，Hexo 会创建或更新另外一个用于部署的分支，这个分支就是 _config.yml 配置文件中指定的分支。Hexo 会将生成的站点文件推送至该分支下，并且完全覆盖该分支下的已有内容。值得注意的是，hexo deploy 并不会对本地或远程的写作分支进行任何操作，因此依旧需要手动推送写作分支的所有改动以实现版本控制。</p>
</blockquote>
<h1 id="修改部署配置">修改部署配置</h1>
<p>打开站点配置文件 _config.yml，修改 deploy 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>repo</td>
<td>仓库库（Repository）地址</td>
</tr>
<tr class="even">
<td>branch</td>
<td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr class="odd">
<td>message</td>
<td>自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})</td>
</tr>
</tbody>
</table>
<p><strong>请将 <code>username</code> 改成你的用户名</strong></p>
<p><strong>Github Pages 仅在 <code>master</code> 分支下实现</strong></p>
<h1 id="部署站点">部署站点</h1>
<p>执行下列命令生成站点文件并推送至远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>
<p><code>hexo clean</code> 清除站点文件，<code>hexo deploy</code> 重新生成站点文件并将之推送到指定的仓库分支。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean &amp;&amp; hexo deploy</span></span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 672 ms</span><br><span class="line">...</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Setting up Git deployment...</span><br><span class="line">...</span><br><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></table></figure>
<p>也可以手动生成静态文件，然后使用 git 推送 <code>public</code> 文件夹内的静态文件到部署分支。在执行 <code>hexo deploy</code> 命令后，会在项目根目录下生成一个 <code>.deploy_git</code> 的文件夹，其中的文件其实就是 <code>public</code> 文件夹的文件，同时 <code>.deploy_git</code> 文件夹下还生成了一个 <code>.git</code> 目录，表明了 <code>.deploy_git</code> 是一个仓库目录，可以使用 git 进行版本控制。如果我们直接推送 <code>public</code> 文件夹的内容，需要将 <code>public</code> 初始化为一个仓库，即执行 <code>git init</code> 命令，然后再添加远程仓库进行推送。</p>
<p>部署到 Github Pages 完成后，就可以在浏览器中通过网址 <code>https://username.github.io/</code> 进行访问了。</p>
<h1 id="提交源码分支">提交源码分支</h1>
<h2 id="初次提交">初次提交</h2>
<h3 id="初始化仓库">初始化仓库</h3>
<p>如果是初次提交，此时项目根目录是没有 <code>.git</code> 文件夹的，所以需要执行下列命令将项目文件夹初始化为一个仓库，在项目根目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="定义忽略规则">定义忽略规则</h3>
<p>Hexo 在执行建站命令时默认会在项目根目录下生成 <code>.gitignore</code> 文件，该文件它已经配置好了不需要 push 的文件，如果没有则需要自行创建，然后在该文件定义如下忽略规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>db.json</code>：缓存文件，不需要 push</li>
<li><code>node_modules/</code>：模块包目录，在执行 <code>npm install</code> 时会重新生成，不需要 push</li>
<li><code>public/</code>：<code>hexo g</code> 生成的静态网页，不需要 push</li>
<li><code>.deploy_git/</code>：<code>hexo d</code> 生成，不需要 push</li>
</ul>
<h3 id="重命名当前分支">重命名当前分支</h3>
<p>在初始化仓库完成后，默认在名为 <code>master</code> 的分支下，因为我们这个分支是用于提交源代码的，所以需要另起一个分支名，以区别于远程库的用于部署站点的 <code>master</code> 分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m master dev</span><br></pre></td></tr></table></figure>
<p>这里我们将本地 <code>master</code> 分支重命名为 <code>dev</code>，在下面我们会推送该分支作为远程库的 <code>dev</code> 分支。</p>
<h3 id="本地提交更新">本地提交更新</h3>
<p>执行下列命令查看分支状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>使用下列命令跟踪新文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure>
<p>再次使用 <code>git status</code> 查看分支状态，如果某些隐藏文件未被跟踪而又需要对其进行跟踪的，例如这里需要跟踪 <code>.gitignore</code> 文件，所以还需要执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitignore</span><br></pre></td></tr></table></figure>
<p>执行下列命令，将更新提交到本地仓库分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;Commit Message&quot;</span><br></pre></td></tr></table></figure>
<h3 id="推送更新至远程仓库">推送更新至远程仓库</h3>
<p>上面的提交更新只是本地操作，与远程库并没有任何关联，所以还需要进行以下操作将更新推送至远程库。</p>
<p>添加远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure>
<p>可以使用如下命令查看已添加的远程仓库的信息，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	git@github.com:wylu/wylu.github.io.git (fetch)</span><br><span class="line">origin	git@github.com:wylu/wylu.github.io.git (push)</span><br></pre></td></tr></table></figure>
<p>执行下列命令，上传当前分支到远程库，并且关联当前分支与远程分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin dev:dev</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin dev:dev</span></span><br><span class="line">...</span><br><span class="line">To github.com:wylu/wylu.github.io.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>可以看到 git 会为我们自动在远程仓库创建 <code>dev</code> 分支，并且关联本地的 <code>dev</code> 分支和远程的 <code>dev</code> 分支。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6aac2f0cea761866a632d83ba528ab9d.png" alt="push-dev-branch" /></p>
<h2 id="后续提交更新">后续提交更新</h2>
<p>因为初次提交时我们已经关联了本地分支与远程分支，所以后续提交更新时，只需要执行下列命令即可。</p>
<p>跟踪新文件和修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure>
<p>提交更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;Commit Message&quot;</span><br></pre></td></tr></table></figure>
<p>推送更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h1 id="其它设备管理博客">其它设备管理博客</h1>
<p>当我们需要在其它电脑上管理博客时，首先需要配置相关环境。</p>
<h2 id="配置相关环境">配置相关环境</h2>
<ul>
<li>安装 <code>Git</code></li>
<li>安装 <code>Node.js</code></li>
<li>配置 SSH Key</li>
</ul>
<h2 id="clone-源码分支">Clone 源码分支</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b dev git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure>
<p><code>dev</code> 为我的源码分支名称，你应根据你的分支名称进行修改。</p>
<h2 id="安装-hexo-及相关依赖">安装 Hexo 及相关依赖</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo资源文件夹</title>
    <url>/posts/940b8194/</url>
    <content><![CDATA[<p>本文将介绍 Hexo 资源文件夹的使用，以及解决如何以相对路径的方式引用图片使其能够在主页和文章中正常显示。</p>
<span id="more"></span>
<p><strong>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo</a></strong></p>
<p><strong>本文基于 <code>hexo: 3.8.0</code></strong></p>
<h1 id="资源文件">资源文件</h1>
<p>资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。</p>
<h1 id="直接引用">直接引用</h1>
<p>如果 Hexo 项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中，然后通过以下方法引用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">direct</span>](<span class="link">/images/img.png</span>)</span><br></pre></td></tr></table></figure>
<p>编译成静态文件后 img.png 存放在 public/images 文件夹下，生成的 html 文件中的引用路径为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/img.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;direct&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="使用文章资源文件夹">使用文章资源文件夹</h1>
<p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo 也提供了更组织化的方式来管理资源。这个功能可以通过将 _config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>当资源文件管理功能打开后，Hexo 将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹与这个 markdown 文件同名。将所有与该文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，<strong>推荐使用该方式，其引用方式和原生 Markdown 方式一致，避免过多的使用 Hexo 的扩展标签。</strong></p>
<p><strong>使用 post_asset_folder 存在的一些问题，可以参考下方 "图片的相对引用"。</strong></p>
<h1 id="使用标签插件">使用标签插件</h1>
<p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确，你可以使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html">标签插件</a> 来解决这个问题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_img slug [title] %&#125;</span></span><br></pre></td></tr></table></figure>
<p>例如，当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](./example.jpg)</code> 或 <code>![](example.jpg)</code>，它将不会出现在首页上，但它会在文章中正常显示。</p>
<p>通过下列方式，图片将会同时出现在文章和主页以及归档页中。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_img example.jpg This is an example image %&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="图片的相对引用">图片的相对引用</h1>
<p>开启 <code>post_asset_folder</code> 后，例如创建一篇名为 "assetsTest" 的文章并引用一张图片，它的文件目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree <span class="built_in">source</span>/_posts</span></span><br><span class="line">source/_posts</span><br><span class="line">├── assetsTest</span><br><span class="line">│   └── example.png</span><br><span class="line">└── assetsTest.md</span><br></pre></td></tr></table></figure>
<p>三种相对引用的写法及其效果：</p>
<ul>
<li><p><code>![example](example.png)</code></p>
<p>Hexo 官方文档关于 markdown 的示例写法，图片不能在主页正常显示，但在文章中能正常显示。此外，这种相对引用写法在绝大数 markdown 编辑器的预览视图中都无法正常显示图片（Typora 通过设置 <code>Use Image Root Path</code> 可以解决，它会在文件头添加 <code>typora-root-url: xxxx</code>）。</p></li>
<li><p><code>{% asset_img example.png example %}</code></p>
<p>Hexo 官方推荐使用标签的写法，图片能在主页和文章中正常显示，但是不能在 markdown 编辑器的预览视图中预览图片。</p></li>
<li><p><code>![example](assetsTest/example.png)</code></p>
<p>几乎所有的 markdown 编辑器都支持的相对引用的写法，在markdown 编辑器的预览视图中都能正常显示图片，但在主页和文章中无法正常显示。</p></li>
</ul>
<p><strong>推荐使用第三种写法</strong>，为了解决无法在主页和文章中正常显示的问题，需要安装 <a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> 插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image@0.0.1 --save</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo站点配置</title>
    <url>/posts/8247e85f/</url>
    <content><![CDATA[<p>本文将详细介绍 Hexo 站点配置文件中的各个配置项的含义与作用。</p>
<span id="more"></span>
<p><strong>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo</a></strong></p>
<p><strong>本文基于 <code>hexo: 3.8.0</code></strong></p>
<h1 id="站点配置文件">站点配置文件</h1>
<p>Hexo 工程的配置文件是 _config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="site">Site</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>title</td>
<td>站点名称</td>
</tr>
<tr class="even">
<td>subtitle</td>
<td>站点副标题</td>
</tr>
<tr class="odd">
<td>description</td>
<td>站点描述</td>
</tr>
<tr class="even">
<td>author</td>
<td>作者名称</td>
</tr>
<tr class="odd">
<td>language</td>
<td>网站使用的语言</td>
</tr>
<tr class="even">
<td>timezone</td>
<td>网站时区。Hexo 默认使用本机的时区，可用<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>，例如：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code></td>
</tr>
</tbody>
</table>
<p>其中，description 主要用于 SEO，告诉搜索引擎一个关于站点的简单描述，通常建议在其中包含网站的关键词，也可以是你喜欢的一句签名。author 参数用于主题显示文章的作者。</p>
<p>对应于 NexT 主题 Gemini scheme 的显示效果下，不同主题显示效果不同，但原理类似。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0fc04b2d222ca2da9ea9f6e7368d5d2d.png" alt="Site-title" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/597f6b6ce45ae7a080638477ba05b6fe.png" alt="Site-subtitle" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b11159d4f39fd951165a367e0e21b70d.png" alt="Site-author-description" /></p>
<h1 id="url">URL</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>url</td>
<td>网站的URL</td>
<td></td>
</tr>
<tr class="even">
<td>root</td>
<td>网站根目录</td>
<td></td>
</tr>
<tr class="odd">
<td>permalink</td>
<td>文章的<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a>格式</td>
<td>:year/:month/:day/:title/</td>
</tr>
<tr class="even">
<td>permalink_defaults</td>
<td>永久链接中各部分的默认值</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则需要将 url 设为 <code>http://yoursite.com/blog</code> 并把 root 设为 <code>/blog/</code>。</p>
<h1 id="directory">Directory</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source_dir</td>
<td>资源文件夹，用来存放源文件，如文章的markdown文件</td>
<td>source</td>
</tr>
<tr class="even">
<td>public_dir</td>
<td>公共文件夹，用来存放生成的站点文件</td>
<td>public</td>
</tr>
<tr class="odd">
<td>tag_dir</td>
<td>标签文件夹</td>
<td>tags</td>
</tr>
<tr class="even">
<td>archive_dir</td>
<td>归档文件夹</td>
<td>archives</td>
</tr>
<tr class="odd">
<td>category_dir</td>
<td>分类文件夹</td>
<td>categories</td>
</tr>
<tr class="even">
<td>code_dir</td>
<td>Include code 文件夹</td>
<td>downloads/code</td>
</tr>
<tr class="odd">
<td>i18n_dir</td>
<td>国际化（i18n）文件夹</td>
<td>:lang</td>
</tr>
<tr class="even">
<td>skip_render</td>
<td>跳过指定文件的渲染，可以使用<a href="https://github.com/isaacs/node-glob">glob表达式</a>来匹配路径, 如跳过README.md的渲染</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="writing">Writing</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>new_post_name</td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr class="even">
<td>default_layout</td>
<td>默认布局</td>
<td>post</td>
</tr>
<tr class="odd">
<td>titlecase</td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr class="even">
<td>external_link</td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr class="odd">
<td>filename_case</td>
<td>把文件名称转换为"1"小写或"2"大写</td>
<td>0</td>
</tr>
<tr class="even">
<td>render_drafts</td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr class="odd">
<td>post_asset_folder</td>
<td>同步创建资源文件夹</td>
<td>false</td>
</tr>
<tr class="even">
<td>relative_link</td>
<td>把链接改为与根目录的相对地址</td>
<td>false</td>
</tr>
<tr class="odd">
<td>future</td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr class="even">
<td>highlight</td>
<td>代码块的设置</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="filename_case">filename_case</h2>
<p><code>filename_case</code> 默认值为 0，表示不做任何处理，为 1 则转为小写，为 2 则转为大写。</p>
<h2 id="post_asset_folder">post_asset_folder</h2>
<p>设置 <code>post_asset_folder</code> 为 true 后，每次新建文章都会自动创建一个同名的文件夹，用于存放一些图片文件，方便管理文章的图片资源，创建的文件夹与新建文章在目录结构上是同级关系。</p>
<h2 id="relative_link">relative_link</h2>
<blockquote>
<p>相对地址</p>
<p>默认情况下，Hexo生成的超链接都是绝对地址。 例如，如果您的网站域名为example.com，您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。 相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。 通常情况下，建议使用绝对地址。</p>
</blockquote>
<h2 id="highlight">highlight</h2>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>enable</td>
<td>启用代码高亮</td>
<td>true</td>
</tr>
<tr class="even">
<td>line_number</td>
<td>显示行号</td>
<td>true</td>
</tr>
<tr class="odd">
<td>auto_detect</td>
<td>自动检测语言</td>
<td>false</td>
</tr>
<tr class="even">
<td>tab_replace</td>
<td>使用指定字符串替换tab键</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>tab_replace</code> 会将代码块中所有的tab键都换成指定的字符串，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>那么所有的tab键都会被替换成字符串"true", 假设原代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换后为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">truepublic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">truetrueSystem.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="home-page-setting">Home page setting</h1>
<p>主页显示配置</p>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>path</td>
<td>博客主页根路径</td>
<td>''</td>
</tr>
<tr class="even">
<td>per_page</td>
<td>每页展示文章数量 (0 = 关闭分页功能)</td>
<td>10</td>
</tr>
<tr class="odd">
<td>order_by</td>
<td>排序，默认按时间降序排列</td>
<td>-date</td>
</tr>
</tbody>
</table>
<h1 id="category-tag">Category &amp; Tag</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>default_category</td>
<td>默认分类</td>
<td>uncategorized</td>
</tr>
<tr class="even">
<td>category_map</td>
<td>分类别名</td>
<td></td>
</tr>
<tr class="odd">
<td>tag_map</td>
<td>标签别名</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="date-time-format">Date / Time format</h1>
<p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>date_format</td>
<td>日期格式</td>
<td>YYYY-MM-DD</td>
</tr>
<tr class="even">
<td>time_format</td>
<td>时间格式</td>
<td>H:mm:ss</td>
</tr>
</tbody>
</table>
<h1 id="pagination">Pagination</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>per_page</td>
<td>每页显示的文章数量 (0 = 关闭分页功能)</td>
<td>10</td>
</tr>
<tr class="even">
<td>pagination_dir</td>
<td>分页目录</td>
<td>page</td>
</tr>
</tbody>
</table>
<h1 id="extensions">Extensions</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>theme</td>
<td>当前主题名称，值为false时禁用主题</td>
<td>landscape</td>
</tr>
</tbody>
</table>
<h1 id="deployment">Deployment</h1>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>deploy</td>
<td>部署部分的设置</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment"># https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span> <span class="string">name</span>] <span class="comment"># published</span></span><br><span class="line">  <span class="attr">message:</span> [<span class="string">commit</span> <span class="string">message</span>]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>Setting</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>type</td>
<td>deployer</td>
</tr>
<tr class="even">
<td>repo</td>
<td>仓库库（Repository）地址</td>
</tr>
<tr class="odd">
<td>branch</td>
<td>分支名称，如果使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测</td>
</tr>
<tr class="even">
<td>message</td>
<td>自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})</td>
</tr>
</tbody>
</table>
<p>一个正确的部署配置中至少要有 type 参数，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br></pre></td></tr></table></figure>
<p>可以同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">heroku</span></span><br><span class="line">  <span class="attr">repo:</span></span><br></pre></td></tr></table></figure>
<h1 id="添加-readme.md-文件">添加 README.md 文件</h1>
<p>Hexo 默认会将 source 文件夹下的 md 文件渲染成 html 文件，所以使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改 <code>站点配置文件</code>，skip_render 参数的值设置如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br></pre></td></tr></table></figure>
<p>表示在执行 <code>hexo g</code> 时跳过渲染 README.md 这个文件。</p>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo命令与服务器</title>
    <url>/posts/4f25baa7/</url>
    <content><![CDATA[<p>介绍 Hexo 常用命令的作用。</p>
<span id="more"></span>
<p><strong>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo</a></strong></p>
<p><strong>本文基于 <code>hexo: 3.8.0</code></strong></p>
<h1 id="命令">命令</h1>
<h2 id="常用命令">常用命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hexo init [folder]</code></td>
<td></td>
<td>新建网站</td>
</tr>
<tr class="even">
<td><code>hexo new [layout] &lt;title&gt;</code></td>
<td></td>
<td>新建文章</td>
</tr>
<tr class="odd">
<td><code>hexo generate</code></td>
<td><code>hexo g</code></td>
<td>生成静态文件</td>
</tr>
<tr class="even">
<td><code>hexo publish [layout] &lt;filename&gt;</code></td>
<td></td>
<td>发布草稿</td>
</tr>
<tr class="odd">
<td><code>hexo server</code></td>
<td><code>hexo s</code></td>
<td>启动服务器</td>
</tr>
<tr class="even">
<td><code>hexo deploy</code></td>
<td><code>hexo d</code></td>
<td>部署网站</td>
</tr>
<tr class="odd">
<td><code>hexo clean</code></td>
<td></td>
<td>清除缓存文件</td>
</tr>
<tr class="even">
<td><code>hexo list</code></td>
<td></td>
<td>列出站点信息</td>
</tr>
<tr class="odd">
<td><code>hexo version</code></td>
<td></td>
<td>显示 Hexo 版本</td>
</tr>
</tbody>
</table>
<h2 id="init">init</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<h2 id="new">new</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h2 id="generate">generate</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>或简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态文件，生成的文件保存在 public 文件夹内。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d, --deploy</code></td>
<td>文件生成后立即部署网站</td>
</tr>
<tr class="even">
<td><code>-w, --watch</code></td>
<td>监视文件变动</td>
</tr>
</tbody>
</table>
<h3 id="监视文件变动">监视文件变动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure>
<p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p>
<h3 id="完成后部署">完成后部署</h3>
<p>可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br></pre></td></tr></table></figure>
<p>或简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<h2 id="server">server</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>或简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： http://localhost:4000/</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i, --ip</code></td>
<td>Override the default server IP. Bind to all IP address by default.</td>
</tr>
<tr class="even">
<td><code>-l, --log [format]</code></td>
<td>Enable logger. Override log format.</td>
</tr>
<tr class="odd">
<td><code>-o, --open</code></td>
<td>Immediately open the server url in your default web browser.</td>
</tr>
<tr class="even">
<td><code>-p, --port</code></td>
<td>Override the default port.</td>
</tr>
<tr class="odd">
<td><code>-s, --static</code></td>
<td>Only serve static files.</td>
</tr>
</tbody>
</table>
<h2 id="deploy">deploy</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>或简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-g, --generate</code></td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<h2 id="clean">clean</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可以运行该命令清除缓存后重新生成静态文件。</p>
<h1 id="hexo-server">hexo-server</h1>
<p>Hexo 3.0 把服务器模块独立出来，如果 <code>hexo server</code> 命令无法使用，需要单独安装 hexo-server 才能使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<h2 id="启动服务器">启动服务器</h2>
<p>安装完成后，输入以下命令以启动服务器，网站会在 http://localhost:4000 下启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><strong>在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</strong></p>
<h2 id="修改端口">修改端口</h2>
<p>如果想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 <code>-p</code> 选项指定其它端口，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure>
<h2 id="静态模式">静态模式</h2>
<p>在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理源文件变动，在执行时，应该先自行执行 hexo generate，此模式通常用于生产环境（production mode）下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server -s</span><br></pre></td></tr></table></figure>
<h2 id="自定义ip">自定义IP</h2>
<p>服务器默认运行在 <code>0.0.0.0</code>，我们可以覆盖默认的 IP 设置，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server -i 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>指定这个参数后，就只能通过该 IP 才能访问站点。</p>
<p>例如，对于一台使用无线网络的笔记本电脑，除了指向本机的 <code>127.0.0.1</code> 外，通常还有一个 <code>192.168.*.*</code> 的局域网 IP，如果像上面那样使用 <code>-i</code> 参数，就不能用 <code>127.0.0.1</code> 来访问站点了。对于有公网 IP 的主机，如果您指定一个局域网 IP 作为 <code>-i</code> 参数的值，那么就无法通过公网来访问站点。</p>
<h2 id="输出调试信息">输出调试信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server --debug</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基本操作</title>
    <url>/posts/cd6e4d90/</url>
    <content><![CDATA[<p>介绍使用 Hexo 建站和进行本地测试的流程，以及模板的配置、自定义模板、新建文章等。</p>
<span id="more"></span>
<p><strong>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo</a></strong></p>
<p><strong>本文基于 <code>hexo: 3.8.0</code></strong></p>
<h1 id="建站">建站</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init blog</span></span><br><span class="line">INFO  Cloning hexo-starter to ~/VScode/blog</span><br><span class="line">Cloning into &#x27;/home/wylu/VScode/blog&#x27;...</span><br><span class="line">...</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>如果没有提供 <code>folder</code> 将在当前目录下存放网站相关文件。</p>
<p>网站初始化完成后，文件结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br><span class="line"></span><br><span class="line">4 directories, 3 files</span><br></pre></td></tr></table></figure>
<h2 id="config.yml">_config.yml</h2>
<p>站点配置文件，在此可以配置大部分参数，themes 文件夹下的主题也有 _config.yml 文件，我们称之为主题配置文件，它们是不同的配置文件。</p>
<h2 id="node_modules">node_modules</h2>
<p>node模块库</p>
<h2 id="package.json">package.json</h2>
<p>应用程序的信息，如已安装插件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.8.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="package-lock.json">package-lock.json</h2>
<p>执行 <code>npm install</code> 时自动生成，锁定安装时的包的版本号，无需关注</p>
<h2 id="scaffolds">scaffolds</h2>
<p>模板文件夹，当新建文章时，可以根据 scaffolds 中的模板来创建文件。Hexo 的模板是指在新建的 markdown 文件中默认填充的内容。</p>
<p>例如，如果修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h2 id="source">source</h2>
<p>资源文件夹是存放用户资源的地方，所有 <code>hexo new</code> 的 markdown 文件都会存放在 <code>_posts</code> 目录下。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<h2 id="themes">themes</h2>
<p>主题文件夹。Hexo 会根据主题来生成静态页面。</p>
<h1 id="启动服务器">启动服务器</h1>
<p>建站完成后，执行以下命令启动本地服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-p, --port</code></td>
<td>重设端口</td>
</tr>
<tr class="even">
<td><code>-s, --static</code></td>
<td>只使用静态文件</td>
</tr>
<tr class="odd">
<td><code>-l, --log</code></td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<p>默认情况下，访问网址为： http://localhost:4000/</p>
<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/74c5b2fc485f1dd4b8fb4fecea4a0d0b.png" alt="Hexo Default Demo" /></p>
<h1 id="新建文章">新建文章</h1>
<p>下面命令可以创建一篇新文章：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new <span class="string">&quot;First Passage&quot;</span></span></span><br><span class="line">INFO  Created: ~/VScode/blog/source/_posts/First-Passage.md</span><br></pre></td></tr></table></figure>
<p>在命令中可以指定文章的布局（layout），如果不指定，默认为 post 布局，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>
<h2 id="布局">布局</h2>
<p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，你可以自定义的其他布局，使用自定义布局新建的文章和 post 相同都将储存到 source/_posts 文件夹。</p>
<table>
<thead>
<tr class="header">
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>post</td>
<td>source/_posts</td>
</tr>
<tr class="even">
<td>page</td>
<td>source</td>
</tr>
<tr class="odd">
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody>
</table>
<p>Hexo 将布局模板放置在 scaffolds 文件夹下，默认的布局模板如下：</p>
<ul>
<li><p>post</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li>
<li><p>page</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line"><span class="section">date: &#123;&#123; date &#125;&#125;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li>
<li><p>dragt</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="front-matter">Front-matter</h2>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。Hexo支持 <code>YAML</code> 和 <code>JSON</code> 两种书写格式：示例如下</p>
<ul>
<li><p>YAML</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="section">date: 2013/7/13 20:46:25</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下是 Hexo 的预定义参数，可以在模板和文章中使用这些参数。</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr class="even">
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr class="odd">
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr class="even">
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr class="odd">
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr class="even">
<td>tags</td>
<td>标签（不适用于page布局）</td>
<td></td>
</tr>
<tr class="odd">
<td>categories</td>
<td>分类（不适用于page布局）</td>
<td></td>
</tr>
<tr class="even">
<td>permalink</td>
<td>重写文章的永久链接</td>
<td></td>
</tr>
<tr class="odd">
<td>type</td>
<td>指定页面类型，可设类型为"tags"或"categories"或不设定</td>
<td>默认不设定，此时为普通页面</td>
</tr>
</tbody>
</table>
<p>例如，使用 page 布局新建一个相册页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new page Photo</span></span><br><span class="line">INFO  Created: ~/VScode/blog/source/Photo/index.md</span><br></pre></td></tr></table></figure>
<p>打开 source/Photo/index.md ，内容如下，date会生成具体时间</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Photo</span><br><span class="line"><span class="section">date: 2019-04-12 10:50:49</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="categories和tags">categories和tags</h2>
<p>只有文章支持categories和tags，你可以在 Front-matter 中设置。在 Hexo 中分类具有顺序性和层次性，标签没有顺序和层次。</p>
<h3 id="categories">categories</h3>
<p>如果文章的 Front-matter 包含如下分类描述，表示将该文章分类于Fruits下的Apple类别，其中Apple为Fruits的子分类。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> Fruits</span><br><span class="line"><span class="bullet">  -</span> Apple</span><br></pre></td></tr></table></figure>
<p>对于父子分类还可以使用下面的写法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Fruits, Apple]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> - Fruits</span><br><span class="line"><span class="bullet">    -</span> Apple</span><br></pre></td></tr></table></figure>
<p>并列分类：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Fruits]</span><br><span class="line"><span class="bullet">  -</span> [Animals]</span><br></pre></td></tr></table></figure>
<p>并列 + 子分类：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Fruits, Apple]</span><br><span class="line"><span class="bullet">  -</span> [Animals, Dog]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> - Fruits</span><br><span class="line"><span class="bullet">    -</span> Apple</span><br><span class="line"><span class="bullet">  -</span> - Animals</span><br><span class="line"><span class="bullet">    -</span> Dog</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Asia, China, Beijing]</span><br><span class="line"><span class="bullet">  -</span> [Fruits, Apple]</span><br><span class="line"><span class="bullet">  -</span> Animals</span><br></pre></td></tr></table></figure>
<h3 id="tags">tags</h3>
<p>标签没有层次，有如下两种写法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> PS3</span><br><span class="line"><span class="bullet">  -</span> Games</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tags: [PS3, Games]</span><br></pre></td></tr></table></figure>
<h1 id="文件名称">文件名称</h1>
<p>Hexo 默认以标题做为文件名称，你可以编辑 站点配置文件 _config.yml 中 的 new_post_name 参数来改变默认的文件名称。</p>
<p>例如，修改默认 new_post_name 为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year-:month-:day-:title.md</span></span><br></pre></td></tr></table></figure>
<p>那么生成的文件名就会包含时间和标题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new <span class="string">&quot;Demo Post&quot;</span></span></span><br><span class="line">INFO  Created: ~/VScode/blog/source/_posts/2019-04-12-Demo-Post.md</span><br></pre></td></tr></table></figure>
<p>以下是 Hexo 的占位符：</p>
<table>
<thead>
<tr class="header">
<th>占位符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>:title</td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr class="even">
<td>:year</td>
<td>建立的年份，比如2015</td>
</tr>
<tr class="odd">
<td>:month</td>
<td>建立的月份（有前导零），比如04</td>
</tr>
<tr class="even">
<td>:i_month</td>
<td>建立的月份（无前导零），比如4</td>
</tr>
<tr class="odd">
<td>:day</td>
<td>建立的日期（有前导零），比如07</td>
</tr>
<tr class="even">
<td>:i_day</td>
<td>建立的日期（无前导零），比如7</td>
</tr>
</tbody>
</table>
<h1 id="自定义模板">自定义模板</h1>
<p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>
<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是可以在模版中使用的变量：</p>
<table>
<thead>
<tr class="header">
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>layout</td>
<td>布局</td>
</tr>
<tr class="even">
<td>title</td>
<td>标题</td>
</tr>
<tr class="odd">
<td>date</td>
<td>文件建立日期</td>
</tr>
</tbody>
</table>
<p>可以在 scaffolds 文件夹下创建自定义的模板，如新建文件 <code>photo.md</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: &#123;&#123; layout &#125;&#125;</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line"><span class="section">date: &#123;&#123; date &#125;&#125;</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">Photo Collection</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_config.yml 中默认的文件命名和布局配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>
<p>使用自定义模板新建文章：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new photo <span class="string">&quot;Custom Layout Demo&quot;</span></span></span><br><span class="line">INFO  Created: ~/VScode/blog/source/_posts/Custom-Layout-Demo.md</span><br></pre></td></tr></table></figure>
<p>新建文章的内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: photo</span><br><span class="line">title: Custom Layout Demo</span><br><span class="line"><span class="section">date: 2019-04-12 12:28:23</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">Photo Collection</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成的文件使用了布局模板 photo.md，填充了相应的的标题、布局以及创建时间，同时将其放置在默认布局 post 的路径下。</p>
<h1 id="草稿">草稿</h1>
<p>使用 draft 布局创建的文件会被保存到 source/_drafts 文件夹，可以通过 publish 命令将草稿移动到 source/_posts 文件夹，同样支持指定布局。</p>
<h2 id="创建草稿">创建草稿</h2>
<p>创建草稿需要使用 draft 布局，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new draft <span class="string">&quot;Draft Demo&quot;</span></span></span><br><span class="line">INFO  Created: ~/VScode/blog/source/_drafts/Draft-Demo.md</span><br></pre></td></tr></table></figure>
<h2 id="预览草稿">预览草稿</h2>
<p>默认情况下，草稿不会显示在页面中，如果想要显示可以在站点配置文件 _config.yml 中把 render_drafts 参数设为 true 来预览草稿。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>或者在启动服务器时加上 <code>--draft</code> 参数来预览草稿</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure>
<h2 id="发布草稿">发布草稿</h2>
<p>将草稿文件发布到 _posts 文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo publish post Draft-Demo</span></span><br><span class="line">INFO  Published: ~/VScode/blog/source/_posts/Draft-Demo.md</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo简介与安装</title>
    <url>/posts/2f3b53dc/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wylu/img/83cdf53a81b3d24be21494b114966bdc.jpg" alt="hexo" /></p>
<span id="more"></span>
<p><strong>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo</a></strong></p>
<h1 id="hexo简介">Hexo简介</h1>
<p><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架，基于 <a href="https://nodejs.org/zh-cn/docs/guides/">Node.js</a> 实现。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装">安装</h1>
<h2 id="安装前提">安装前提</h2>
<p>安装 Hexo 前需要安装 <a href="https://git-scm.com/">Git</a> 和 <a href="https://nodejs.org/en/">Node.js</a></p>
<h2 id="安装git">安装Git</h2>
<ul>
<li>Linux (Ubuntu, Debian)： <code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)： <code>sudo yum install git-core</code></li>
</ul>
<h2 id="安装node.js">安装Node.js</h2>
<p>安装 Node.js 的最佳方式是使用 node版本管理器 <a href="https://github.com/creationix/nvm">nvm</a> 安装</p>
<ul>
<li><p>curl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></li>
<li><p>wget</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></li>
</ul>
<p>确保安装后，你的终端配置文件（如<code>~/.bashrc</code>，<code>~/.zshrc</code>）包含如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>
<p>安装完成后，重启终端使配置生效。</p>
<ul>
<li><p>安装 node.js 最新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install node # &quot;node&quot; is an alias for the latest version</span><br></pre></td></tr></table></figure></li>
<li><p>安装指定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install 6.14.4 # or 10.10.0, 8.9.1, etc</span><br></pre></td></tr></table></figure></li>
<li><p>安装稳定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="安装hexo">安装Hexo</h2>
<p>安装完 Git 和 Node.js 后，即可使用 <a href="https://docs.npmjs.com/">npm</a> 安装 Hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo --version</span></span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-47-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.15.3</span><br><span class="line">v8: 6.8.275.32-node.51</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0j</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
