<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wylu</title>
  
  <subtitle>Keep It Simple, Stupid</subtitle>
  <link href="https://wylu.me/atom.xml" rel="self"/>
  
  <link href="https://wylu.me/"/>
  <updated>2023-04-06T16:40:22.949Z</updated>
  <id>https://wylu.me/</id>
  
  <author>
    <name>lu wenye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二进制部署 k8s 集群 1.23.6 版本</title>
    <link href="https://wylu.me/posts/b4d8958f/"/>
    <id>https://wylu.me/posts/b4d8958f/</id>
    <published>2023-04-06T16:30:31.000Z</published>
    <updated>2023-04-06T16:40:22.949Z</updated>
    
    <content type="html"><![CDATA[<p>通过本文的指导，读者可以了解如何通过二进制的方式部署 Kubernetes 1.23.6 版本集群。二进制部署可以加深对 Kubernetes 各组件的理解，可以灵活地将各个组件部署到不同的机器，以满足自身的要求。但是需要注意的是，二进制部署需要手动配置各个组件，需要一定的技术水平和经验。</p><span id="more"></span><h1 id="二进制部署-k8s-集群-1.23.6-版本">二进制部署 k8s 集群 1.23.6 版本</h1><h2 id="环境介绍">1. 环境介绍</h2><p>虽然 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/">kubeadm</a>, <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kops/">kops</a>, <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubespray/">kubespray</a> 以及 <a href="https://docs.rancher.cn/rke/">rke</a>, <a href="https://kubesphere.io/zh/docs/">kubesphere</a> 等工具可以快速部署 K8s 集群，但是依然会有很多人热衷与使用二进制部署 K8s 集群。</p><p>二进制部署可以加深对 K8s 各组件的理解，可以灵活地将各个组件部署到不同的机器，以满足自身的要求。还可以生成一个超长时间自签证书，比如 99 年，免去忘记更新证书过期带来的生产事故。</p><h3 id="书写约定">1.1 书写约定</h3><ul><li>命令行输入，均以 <code>➜</code> 符号表示</li><li>注释使用 <code>#</code> 或 <code>//</code> 表示</li><li>执行命令输出结果，以空行分隔</li></ul><h3 id="规划">1.2 规划</h3><table><colgroup><col style="width: 4%" /><col style="width: 4%" /><col style="width: 4%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>角色</th><th>主机名</th><th>IP</th><th>组件</th></tr></thead><tbody><tr class="odd"><td>master</td><td>cnode0</td><td>10.128.170.20</td><td>etcd, kube-apiserver, kube-controller-manager, kube-scheduler, kube-proxy, kubelet</td></tr><tr class="even"><td>node1</td><td>cnode1</td><td>10.128.170.21</td><td>kubelet, kube-proxy</td></tr></tbody></table><h3 id="环境配置">1.3 环境配置</h3><ul><li><p>关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl stop firewalld</span><br><span class="line">➜ systemctl disable firewalld</span><br></pre></td></tr></table></figure></li><li><p>关闭 selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ setenforce 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure></li><li><p>关闭 swap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><p>使用 <code>-r</code> 选项可以使用扩展正则表达式，这提供了一种更强大和灵活的方式来匹配文本中的模式。</p><p>使用正则表达式 <code>.*swap.*</code> 匹配包含 swap 字符串的行，并在行首添加 # 符号，&amp; 表示匹配到的整个字符串。</p></li><li><p>设置主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.20 主机</span></span><br><span class="line">➜ hostnamectl set-hostname cnode0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.21 主机</span></span><br><span class="line">➜ hostnamectl set-hostname cnode1</span><br></pre></td></tr></table></figure></li><li><p>时间同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">➜ timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装时间同步服务</span></span><br><span class="line">➜ yum install chrony -y</span><br><span class="line">➜ systemctl enable --now chronyd</span><br></pre></td></tr></table></figure></li><li><p>主机名解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">10.128.170.20 cnode0 cnode0.com</span><br><span class="line">10.128.170.21 cnode1 cnode1.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>将桥接的 IPv4 流量传递到 iptables 的链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">➜ sysctl --system</span><br></pre></td></tr></table></figure></li><li><p>设置文件描述符限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时</span></span><br><span class="line">➜ ulimit -SHn 65535</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久</span></span><br><span class="line">➜ echo &quot;*      -      nofile   65535&quot; &gt;&gt;/etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>用于设置当前用户的最大文件描述符数限制。具体来说，它的作用是将当前用户的软限制和硬限制都设置为 65535。</p></li><li><p>更新 epel 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ yum install epel-release -y</span><br></pre></td></tr></table></figure><p>如需换源，请参考：<a href="https://developer.aliyun.com/mirror/epel" class="uri">https://developer.aliyun.com/mirror/epel</a></p></li><li><p>加载 ipvs 模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ yum install ipset ipvsadm -y</span><br><span class="line">➜ cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt; &quot;EOF&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">➜ chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">➜ /bin/bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">➜ lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><ul><li>modprobe -- ip_vs: 加载 ip_vs 内核模块，该模块提供了 Linux 内核中的 IP 负载均衡功能。</li><li>modprobe -- ip_vs_rr: 加载 ip_vs_rr 内核模块，该模块提供了基于轮询算法的 IP 负载均衡策略。</li><li>modprobe -- ip_vs_wrr: 加载 ip_vs_wrr 内核模块，该模块提供了基于加权轮询算法的 IP 负载均衡策略。</li><li>modprobe -- ip_vs_sh: 加载 ip_vs_sh 内核模块，该模块提供了基于哈希算法的 IP 负载均衡策略。</li><li>modprobe -- nf_conntrack_ipv4: 加载 nf_conntrack_ipv4 内核模块，该模块提供了 Linux 内核中的网络连接跟踪功能，用于跟踪网络连接的状态。</li></ul><p>这些命令通常用于配置 Linux 系统中的负载均衡和网络连接跟踪功能。在加载这些内核模块之后，就可以使用相应的工具和命令来配置和管理负载均衡和网络连接跟踪。例如，可以使用 ipvsadm 命令来配置 IP 负载均衡，使用 conntrack 命令来查看和管理网络连接跟踪表。</p><p>如果提示如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;modprobe: FATAL: Module nf_conntrack_ipv4 not found in directory /lib/modules/4.18.0-372.9.1.el8.x86_64&quot;</span><br></pre></td></tr></table></figure><p>则需要将 <code>nf_conntrack_ipv4</code> 修改为 <code>nf_conntrack</code>，然后重新执行命令，因为在高版本内核中已经把 nf_conntrack_ipv4 替换为 nf_conntrack。</p><p>nf_conntrack_ipv4 和 nf_conntrack 都是 Linux 内核中的网络连接跟踪模块，用于跟踪网络连接的状态。它们的区别在于：</p><ul><li>nf_conntrack_ipv4 模块只能跟踪 IPv4 协议的网络连接，而 nf_conntrack 模块可以跟踪 IPv4 和 IPv6 协议的网络连接。</li><li>nf_conntrack_ipv4 模块是 nf_conntrack 模块的一个子模块，它提供了 IPv4 协议的网络连接跟踪功能。因此，如果要使用 nf_conntrack_ipv4 模块，必须先加载 nf_conntrack 模块。</li></ul><p>这两个模块通常用于 Linux 系统中的网络安全和网络性能优化。它们可以被用于防火墙、负载均衡、网络流量分析等场景中，以便对网络连接进行跟踪、监控和控制。例如，可以使用 iptables 命令和 nf_conntrack 模块来实现基于连接状态的防火墙规则，或者使用 ipvsadm 命令和 nf_conntrack 模块来实现 IP 负载均衡。</p><ul><li><a href="https://www.cnblogs.com/xiangsikai/p/9525287.html">Linux 跟踪连接netfilter 调优</a></li><li><a href="https://clodfisher.github.io/2018/09/nf_conntrack/">Iptables之nf_conntrack模块</a></li></ul></li><li><p>免密登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了便捷操作,在 cnode0 上创建免密登录其他节点</span></span><br><span class="line">➜ ssh-keygen -t rsa</span><br><span class="line">➜ ssh-copy-id cnode1</span><br><span class="line">➜ ssh-copy-id cnode2</span><br><span class="line">➜ ssh-copy-id cnode3</span><br></pre></td></tr></table></figure></li><li><p>创建 kubernetes 证书存放目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ mkdir -p /etc/kubernetes/pki</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ reboot</span><br></pre></td></tr></table></figure></li></ul><h3 id="下载-k8s-二进制程序">1.4 下载 k8s 二进制程序</h3><p>从官方发布地址下载二进制包 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md">下载地址</a></p><p>下载 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md#server-binaries">Server Binaries</a> 即可，这个包含了所有所需的二进制文件。解压后，复制二进制 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-proxy</code>,<code>kubelet</code>, <code>kubectl</code> 到 master 节点 <code>/usr/local/bin</code> 目录下，复制二进制 <code>kube-proxy</code>,<code>kubelet</code> 到 worker 节点 <code>/usr/local/bin</code> 目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ ll /usr/local/bin/kube*</span><br><span class="line"></span><br><span class="line">-rwxr-xr-x 1 root root 128516096 Dec 29 14:59 /usr/local/bin/kube-apiserver</span><br><span class="line">-rwxr-xr-x 1 root root 118489088 Dec 29 14:59 /usr/local/bin/kube-controller-manager</span><br><span class="line">-rwxr-xr-x 1 root root  46202880 Dec 29 14:59 /usr/local/bin/kubectl</span><br><span class="line">-rwxr-xr-x 1 root root 122352824 Dec 29 14:59 /usr/local/bin/kubelet</span><br><span class="line">-rwxr-xr-x 1 root root  43581440 Dec 29 14:59 /usr/local/bin/kube-proxy</span><br><span class="line">-rwxr-xr-x 1 root root  49020928 Dec 29 14:59 /usr/local/bin/kube-scheduler</span><br></pre></td></tr></table></figure><h2 id="安装-docker">2. 安装 docker</h2><p>参考地址 <a href="https://docs.docker.com/engine/install/centos/">安装docker</a>，Docker 需要在各个节点上安装</p><ul><li><p>切换镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>查看当前镜像源中支持的 docker 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates</span><br></pre></td></tr></table></figure></li><li><p>安装特定版本的 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --setopt=obsoletes=0 docker-ce-20.10.14 -y</span><br></pre></td></tr></table></figure><p><code>--setopt=obsoletes=0</code> 是 yum 包管理器的一个选项，它的作用是禁用软件包依赖关系中的版本升级。</p></li><li><p>添加配置文件</p><p>Docker 在默认情况下使用的 Cgroup Driver 为 cgroupfs，而 Kubernetes 推荐使用 systemd 来替代 cgroupfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>启动 dokcer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建-ca-证书">3. 创建 ca 证书</h2><h3 id="安装-cfssl">3.1 安装 cfssl</h3><p>cfssl 是一款证书签署工具，使用 cfssl 工具可以很简化证书签署过程，方便颁发自签证书。</p><p>CloudFlare's distributes <a href="https://github.com/cloudflare/cfssl">cfssl</a> source code on github page and binaries on <a href="https://pkg.cfssl.org/">cfssl website</a>.</p><p>Our documentation assumes that you will run <a href="https://github.com/cloudflare/cfssl">cfssl</a> on your local x86_64 Linux host.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L -o /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">curl -s -L -o /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">chmod +x /usr/local/bin/&#123;cfssl,cfssljson&#125;</span><br></pre></td></tr></table></figure><p>离线安装的情况，直接把两个文件下载下来重命名即可</p><h3 id="创建-ca-证书-1">3.2 创建 ca 证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建的证书统一放到 /etc/kubernetes/ssl 目录，创建后复制到 /etc/kubernetes/pki 目录</span></span><br><span class="line">➜ mkdir /etc/kubernetes/ssl</span><br><span class="line"></span><br><span class="line">➜ cd /etc/kubernetes/ssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca 证书创建申请</span></span><br><span class="line">➜ cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ca&quot;: &#123;</span><br><span class="line">        &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 ca 证书</span></span><br><span class="line">➜ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll ca*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:32 ca-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1314 Dec 30 11:32 ca.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 ca 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp ca*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><p>ca-csr.json 这个文件是 Kubernetes 集群中使用的证书颁发机构 (CA) 证书签名请求 (CSR) 配置文件，用于定义 CA 的证书签名请求配置。</p><p>在这个配置文件中，CN 字段指定了证书的通用名称为 kubernetes，key 字段指定了证书的密钥算法为 RSA，密钥长度为 2048 位。names 字段定义了证书的其他信息，如国家、省份、城市、组织和组织单位等。ca 字段指定了证书的过期时间为 87600 小时（即 10 年）。</p><p>这个配置文件用于创建 Kubernetes 集群中的 CA 证书，以便对集群中的其他证书进行签名和认证。</p><ul><li>CN(Common Name): kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)</li><li>names[].O(Organization): kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)</li></ul><p>由于这里是 CA 证书，是签发其它证书的根证书，这个证书密钥不会分发出去作为 client 证书，所有组件使用的 client 证书都是由 CA 证书签发而来，所以 CA 证书的 CN 和 O 的名称并不重要，后续其它签发出来的证书的 CN 和 O 的名称才是有用的。</p><h3 id="创建签发配置文件">3.3 创建签发配置文件</h3><p>由于各个组件都需要配置证书，并且依赖 CA 证书来签发证书，所以我们首先要生成好 CA 证书以及后续的签发配置文件。</p><p>创建用于签发其它证书的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">证书签发配置文件</span></span><br><span class="line">➜ cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;signing&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &#123;</span><br><span class="line">            &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;kubernetes&quot;: &#123;</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">                    &quot;signing&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;server auth&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>ca-config.json 这个文件是签发其它证书的配置文件，用于定义签名配置和证书配置。其中，signing 字段定义了签名配置，profiles 字段定义了不同场景下的证书配置。</p><p>在这个配置文件中，default 配置指定了默认的证书过期时间为 87600 小时（即 10 年），profiles 配置定义了一个名为 kubernetes 的证书配置，它指定了证书的用途（签名、密钥加密、服务器认证和客户端认证）和过期时间。</p><p>这个配置文件用于创建 Kubernetes 集群中的证书和密钥，以便对集群进行安全认证和加密通信。</p><ul><li>signing：定义了签名配置，包括默认的签名过期时间和各个证书配置的签名过期时间。</li><li>profiles：定义了不同场景下的证书配置，包括证书的用途、过期时间和其他属性。</li></ul><p>在使用 cfssl gencert 命令生成证书时，可以使用 <code>-config</code> 参数指定配置文件，以便根据配置文件中的规则生成符合要求的证书。如果不指定 <code>-config</code> 参数，则 cfssl gencert 命令将使用默认的配置文件。</p><h2 id="部署-etcd">4. 部署 etcd</h2><p>etcd 版本选择的是最新版本 3.5.1，下载二进制 <a href="https://github.com/etcd-io/etcd/releases/tag/v3.5.1">etcd下载链接</a></p><h3 id="颁发证书">4.1 颁发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">etcd 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有 etcd 集群节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。</span></span><br><span class="line">➜ cat &gt; etcd-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 etcd 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll etcd*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 11:32 etcd-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1440 Dec 30 11:32 etcd.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 etcd 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp etcd*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><h3 id="部署-etcd-1">4.2 部署 etcd</h3><p>下载二进制 <a href="https://github.com/etcd-io/etcd/releases/tag/v3.5.1">etcd下载链接</a>并解压，将二进制程序 <code>etcd</code> <code>etcdctl</code> 复制到 <code>/usr/local/bin</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ ll /usr/local/bin/etcd*</span><br><span class="line"></span><br><span class="line">-rwxrwxr-x 1 root root 21823488 Dec 29 14:13 /usr/local/bin/etcd</span><br><span class="line">-rwxrwxr-x 1 root root 16711680 Dec 29 14:13 /usr/local/bin/etcdctl</span><br></pre></td></tr></table></figure><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ mkdir /etc/etcd</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/etcd/etcd.conf &lt;&lt; EOF</span><br><span class="line">ETCD_NAME=&quot;etcd1&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://10.128.170.20:2379&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://10.128.170.20:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd1=https://10.128.170.20:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件解释</span></span><br><span class="line">ETCD_NAME：节点名称，集群中唯一</span><br><span class="line">ETCD_DATA_DIR： 数据保存目录</span><br><span class="line">ETCD_LISTEN_PEER_URLS：集群内部通信监听地址</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</span><br><span class="line">ETCD_INITIAL_CLUSTER：集群节点地址列表</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN：集群通信token</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群</span><br></pre></td></tr></table></figure><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据目录</span></span><br><span class="line">➜ mkdir -p /var/lib/etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建系统服务</span></span><br><span class="line">➜ cat &gt; /lib/systemd/system/etcd.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=etcd server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/etc/etcd/etcd.conf</span><br><span class="line">WorkingDirectory=/var/lib/etcd</span><br><span class="line">ExecStart=/usr/local/bin/etcd \</span><br><span class="line">  --cert-file=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --key-file=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --trusted-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --peer-cert-file=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --peer-key-file=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --peer-trusted-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --peer-client-cert-auth \</span><br><span class="line">  --client-cert-auth</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 etcd 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status etcd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u etcd</span><br></pre></td></tr></table></figure><h2 id="部署-kube-apiserver">5. 部署 kube-apiserver</h2><h3 id="颁发证书-1">5.1 颁发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-apiserver 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有 kube-apiserver 节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.128.170.20 10.128.170.21 10.128.170.22 10.128.170.23 10.128.170.24 10.128.170.25</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.96.0.1 是 service 网段的第一个 IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes.default.svc.cluster.local 这一串是 kube-apiserver 的 service 域名</span></span><br><span class="line">➜ cat &gt; kube-apiserver-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;,</span><br><span class="line">        &quot;10.96.0.1&quot;,</span><br><span class="line">        &quot;kubernetes&quot;,</span><br><span class="line">        &quot;kubernetes.default&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">        &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-apiserver 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-apiserver-csr.json | cfssljson -bare kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-apiserver*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:33 kube-apiserver-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1590 Dec 30 11:33 kube-apiserver.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-apiserver 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-apiserver*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><h3 id="部署-kube-apiserver-1">5.2 部署 kube-apiserver</h3><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-apiserver.conf &lt;&lt; EOF</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \</span><br><span class="line">  --anonymous-auth=false \</span><br><span class="line">  --bind-address=0.0.0.0 \</span><br><span class="line">  --secure-port=6443 \</span><br><span class="line">  --insecure-port=0 \</span><br><span class="line">  --authorization-mode=Node,RBAC \</span><br><span class="line">  --runtime-config=api/all=true \</span><br><span class="line">  --enable-bootstrap-token-auth \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --token-auth-file=/etc/kubernetes/token.csv \</span><br><span class="line">  --service-node-port-range=30000-32767 \</span><br><span class="line">  --tls-cert-file=/etc/kubernetes/pki/kube-apiserver.pem \</span><br><span class="line">  --tls-private-key-file=/etc/kubernetes/pki/kube-apiserver-key.pem \</span><br><span class="line">  --client-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --kubelet-client-certificate=/etc/kubernetes/pki/kube-apiserver.pem \</span><br><span class="line">  --kubelet-client-key=/etc/kubernetes/pki/kube-apiserver-key.pem \</span><br><span class="line">  --service-account-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --service-account-signing-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --service-account-issuer=https://kubernetes.default.svc.cluster.local \</span><br><span class="line">  --etcd-cafile=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --etcd-certfile=/etc/kubernetes/pki/etcd.pem \</span><br><span class="line">  --etcd-keyfile=/etc/kubernetes/pki/etcd-key.pem \</span><br><span class="line">  --etcd-servers=https://10.128.170.21:2379 \</span><br><span class="line">  --enable-swagger-ui=true \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --apiserver-count=1 \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/var/log/kube-apiserver-audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --alsologtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>如果 etcd 是一个集群，则 <code>--etcd-servers</code> 可以添加多个，例如：<code>--etcd-servers=https://10.128.170.21:2379,https://10.128.170.22:2379,https://10.128.170.23:2379</code></p></blockquote><p>生成 token 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/token.csv &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">head</span> -c 16 /dev/urandom | <span class="built_in">od</span> -An -t x | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>),kubelet-bootstrap,10001,<span class="string">&quot;system:node-bootstrapper&quot;</span></span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>在这个命令中，<code>head -c 16 /dev/urandom | od -An -t x | tr -d ' '</code> 生成了一个 16 字节的随机字符串，并将其转换为十六进制格式。这个字符串将作为令牌的值。</p><ul><li>kubelet-bootstrap 是令牌的用户名</li><li>10001 是令牌的 UID，</li><li>system:node-bootstrapper 是令牌的组名。</li></ul><p>这些值将用于 kubelet 节点的身份验证和授权。</p></blockquote><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-apiserver.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-apiserver $KUBE_APISERVER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 kube-apiserver 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-apiserver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-apiserver</span><br></pre></td></tr></table></figure><h2 id="部署-kubectl">6. 部署 kubectl</h2><p>部署完 kube-apiserver 后，就可以部署 kubectl 了，因为 kubectl 可以验证 kube-apiserver 是否已经正常工作了。</p><h3 id="颁发证书-2">6.1 颁发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">O 参数的值必须为 system:masters，因为这是 kube-apiserver 一个内置好的角色，拥有集群管理的权限</span></span><br><span class="line">➜ cat &gt; kubectl-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;clusteradmin&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:masters&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kubectl 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubectl-csr.json | cfssljson -bare kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kubectl*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1675 Dec 30 11:34 kubectl-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1415 Dec 30 11:34 kubectl.pem</span><br></pre></td></tr></table></figure><h3 id="生成配置文件">6.2 生成配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials clusteradmin --client-certificate=kubectl.pem --client-key=kubectl-key.pem --embed-certs=true --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context kubernetes --cluster=kubernetes --user=clusteradmin --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context kubernetes --kubeconfig=kube.config</span><br><span class="line"></span><br><span class="line">➜ mkdir -p ~/.kube</span><br><span class="line"></span><br><span class="line">➜ cp kube.config ~/.kube/config</span><br></pre></td></tr></table></figure><p>以上命令用于在本地创建一个 Kubernetes 配置文件 kube.config，并将其复制到 ~/.kube/config 文件中，以便使用 kubectl 命令与 Kubernetes 集群进行交互。</p><blockquote><p>kubectl config set-cluster 命令设置了一个名为 kubernetes 的集群，指定了以下参数：</p><ul><li>--certificate-authority=ca.pem：指定 CA 证书文件的路径。</li><li>--embed-certs=true：将 CA 证书嵌入到配置文件中。</li><li>--server=https://10.128.170.20:6443：指定 API Server 的地址和端口。</li><li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li></ul><p>这些参数将用于创建一个名为 kubernetes 的集群配置，并将其写入到 kube.config 文件中。</p><p>kubectl config set-credentials 命令设置了一个名为 clusteradmin 的用户，指定了以下参数：</p><ul><li>--client-certificate=kubectl.pem：指定客户端证书文件的路径。</li><li>--client-key=kubectl-key.pem：指定客户端私钥文件的路径。</li><li>--embed-certs=true：将客户端证书和私钥嵌入到配置文件中。</li><li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li></ul><p>这些参数将用于创建一个名为 clusteradmin 的用户配置，并将其写入到 kube.config 文件中。</p><p>kubectl config set-context 命令设置了一个名为 kubernetes 的上下文，指定了以下参数：</p><ul><li>--cluster=kubernetes：指定要使用的集群。</li><li>--user=clusteradmin：指定要使用的用户。</li><li>--kubeconfig=kube.config：指定要写入的配置文件路径。</li></ul><p>这些参数将用于创建一个名为 kubernetes 的上下文配置，并将其写入到 kube.config 文件中。</p><p>kubectl config use-context 命令将当前上下文设置为 kubernetes，指定了以下参数：</p><ul><li>--kubeconfig=kube.config：指定要使用的配置文件路径。</li></ul><p>这个命令将当前上下文设置为 kubernetes，以便 kubectl 命令可以使用 kube.config 文件与 Kubernetes 集群进行交互。</p></blockquote><h3 id="获取集群信息">6.3 获取集群信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl cluster-info</span><br><span class="line"></span><br><span class="line">Kubernetes control plane is running at https://10.128.170.20:6443</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br><span class="line"></span><br><span class="line">➜ kubectl get all -A</span><br><span class="line"></span><br><span class="line">NAMESPACE   NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">default     service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   22m</span><br><span class="line"></span><br><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                        ERROR</span><br><span class="line">scheduler            Unhealthy   Get &quot;https://127.0.0.1:10259/healthz&quot;: dial tcp 127.0.0.1:10259: connect: connection refused</span><br><span class="line">controller-manager   Unhealthy   Get &quot;https://127.0.0.1:10257/healthz&quot;: dial tcp 127.0.0.1:10257: connect: connection refused</span><br><span class="line">etcd-0               Healthy     &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="设置-kubectl-自动补全">6.4 设置 kubectl 自动补全</h3><p>查看 kubectl 命令自动补全帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl completion --help</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">安装 bash-completion：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">yum install bash-completion -y</span><br></pre></td></tr></table></figure><p>设置 kubectl 自动补全配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">````</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 7. 部署 kube-controller-manager</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 7.1 颁发证书</span></span></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-controller-manager 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line">➜ cat &gt; kube-controller-manager-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-controller-manager 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-controller-manager*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 12:13 kube-controller-manager-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1513 Dec 30 12:13 kube-controller-manager.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-controler-manager 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-controller-manager*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><p>system:kube-controller-manager 是 Kubernetes 中的一个预定义 RBAC 角色，用于授权 kube-controller-manager 组件对 Kubernetes API 的访问。详细介绍请参考官方文档：<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings" class="uri">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings</a></p><h3 id="部署-kube-controller-manager">7.2 部署 kube-controller-manager</h3><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-controller-manager.conf &lt;&lt; EOF</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--port=0 \</span><br><span class="line">  --secure-port=10257 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \</span><br><span class="line">  --service-cluster-ip-range=10.96.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --cluster-signing-duration=87600h \</span><br><span class="line">  --tls-cert-file=/etc/kubernetes/pki/kube-controller-manager.pem \</span><br><span class="line">  --tls-private-key-file=/etc/kubernetes/pki/kube-controller-manager-key.pem \</span><br><span class="line">  --service-account-private-key-file=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="line">  --root-ca-file=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --controllers=*,bootstrapsigner,tokencleaner \</span><br><span class="line">  --use-service-account-credentials=true \</span><br><span class="line">  --horizontal-pod-autoscaler-sync-period=10s \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line">  --cluster-cidr=10.240.0.0/12 \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成 kubeconfig</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-controller-manager --client-certificate=kube-controller-manager.pem --client-key=kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-controller-manager.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes controller manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-controller-manager.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 kube-controller-manager 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-controller-manager</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-controller-manager</span><br></pre></td></tr></table></figure><p>查看组件状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                        ERROR</span><br><span class="line">scheduler            Unhealthy   Get &quot;https://127.0.0.1:10259/healthz&quot;: dial tcp 127.0.0.1:10259: connect: connection refused</span><br><span class="line">controller-manager   Healthy     ok</span><br><span class="line">etcd-0               Healthy     &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="部署-kube-scheduler">8. 部署 kube-scheduler</h2><h3 id="颁发证书-3">8.1 颁发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-scheduler 证书签署申请</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts 字段中，IP 为所有节点地址，这里可以做好规划，预留几个 IP，以备以后扩容。我这里写 6 个 IP</span></span><br><span class="line">➜ cat &gt; kube-scheduler-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">        &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;10.128.170.20&quot;,</span><br><span class="line">        &quot;10.128.170.21&quot;,</span><br><span class="line">        &quot;10.128.170.22&quot;,</span><br><span class="line">        &quot;10.128.170.23&quot;,</span><br><span class="line">        &quot;10.128.170.24&quot;,</span><br><span class="line">        &quot;10.128.170.25&quot;,</span><br><span class="line">        &quot;cnode0&quot;,</span><br><span class="line">        &quot;cnode1&quot;,</span><br><span class="line">        &quot;cnode2&quot;,</span><br><span class="line">        &quot;cnode3&quot;,</span><br><span class="line">        &quot;cnode4&quot;,</span><br><span class="line">        &quot;cnode5&quot;,</span><br><span class="line">        &quot;cnode0.com&quot;,</span><br><span class="line">        &quot;cnode1.com&quot;,</span><br><span class="line">        &quot;cnode2.com&quot;,</span><br><span class="line">        &quot;cnode3.com&quot;,</span><br><span class="line">        &quot;cnode4.com&quot;,</span><br><span class="line">        &quot;cnode5.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-scheduler 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-scheduler*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 30 13:19 kube-scheduler-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1489 Dec 30 13:19 kube-scheduler.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-scheduler 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-scheduler*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><h3 id="部署-kube-scheduler-1">8.2 部署 kube-scheduler</h3><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-scheduler.conf &lt;&lt; EOF</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --alsologtostderr=true \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --v=4&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成 kubeconfig</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-scheduler --client-certificate=kube-scheduler.pem --client-key=kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-scheduler --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-scheduler.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kube-scheduler.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-scheduler $KUBE_SCHEDULER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 kube-scheduler 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-scheduler</span><br></pre></td></tr></table></figure><p>查看组件状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get cs</span><br><span class="line"></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="部署-kubelet">9. 部署 kubelet</h2><p>master 节点上部署 kubelet 是可选的，一旦部署 kubelet，master 节点也可以运行 Pod，如果不希望 master 节点上运行 Pod，则可以给 master 节点打上污点。</p><p>master 节点部署 kubelet 是有好处的，一是可以通过诸如 <code>kubectl get node</code> 等命令查看节点信息，二是可以在上面部署监控系统，日志采集系统等。</p><h3 id="授权-kubelet-允许请求证书">9.1 授权 kubelet 允许请求证书</h3><p>授权 kubelet-bootstrap 用户允许请求证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br><span class="line"></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubelet-bootstrap created</span><br></pre></td></tr></table></figure><h3 id="部署-kubelet-1">9.2 部署 kubelet</h3><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kubelet.conf &lt;&lt; EOF</span><br><span class="line">KUBELET_OPTS=&quot;--bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \</span><br><span class="line">  --config=/etc/kubernetes/kubelet.yaml \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \</span><br><span class="line">  --cert-dir=/etc/kubernetes/pki \</span><br><span class="line">  --network-plugin=cni \</span><br><span class="line">  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6 \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --v=4 \</span><br><span class="line">  --log-dir=/var/log/kubernetes \</span><br><span class="line">  --fail-swap-on=false&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/kubelet.yaml &lt;&lt; EOF</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10250</span><br><span class="line">readOnlyPort: 0</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 2m0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /etc/kubernetes/pki/ca.pem</span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 5m0s</span><br><span class="line">    cacheUnauthorizedTTL: 30s</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.96.0.10</span><br><span class="line">clusterDomain: cluster.local</span><br><span class="line">healthzBindAddress: 127.0.0.1</span><br><span class="line">healthzPort: 10248</span><br><span class="line">rotateCertificates: true</span><br><span class="line">evictionHard:</span><br><span class="line">  imagefs.available: 15%</span><br><span class="line">  memory.available: 100Mi</span><br><span class="line">  nodefs.available: 10%</span><br><span class="line">  nodefs.inodesFree: 5%</span><br><span class="line">maxOpenFiles: 1000000</span><br><span class="line">maxPods: 110</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成 kubeconfig</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kubelet-bootstrap --token=$(awk -F, &#x27;&#123;print $1&#125;&#x27; /etc/kubernetes/token.csv) --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kubelet-bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kubelet-bootstrap.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes kubelet</span><br><span class="line">After=network.target network-online.targer docker.service</span><br><span class="line">Wants=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/kubernetes/kubelet.conf</span><br><span class="line">ExecStart=/usr/local/bin/kubelet $KUBELET_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 kubelet 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kubelet</span><br></pre></td></tr></table></figure><p>批准节点加入集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-dtprn   11s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Pending</span><br><span class="line"></span><br><span class="line">➜ kubectl certificate approve csr-dtprn</span><br><span class="line"></span><br><span class="line">certificatesigningrequest.certificates.k8s.io/csr-dtprn approved</span><br><span class="line"></span><br><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE    SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-dtprn   113s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Approved,Issued</span><br></pre></td></tr></table></figure><p>查看节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS     ROLES    AGE   VERSION</span><br><span class="line">cnode0   NotReady   &lt;none&gt;   57s   v1.23.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时节点状态还是 NotReady，因为还没有安装网络插件，正确安装网络插件后，状态会变为 Ready.</span></span><br></pre></td></tr></table></figure><h2 id="部署-kube-proxy">10. 部署 kube-proxy</h2><h3 id="颁发证书-4">10.1 颁发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-proxy 证书签署申请</span></span><br><span class="line">➜ cat &gt; kube-proxy-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;GuangDong&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;ShenZhen&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;system&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签署 kube-proxy 证书</span></span><br><span class="line">➜ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果，会生成两个证书文件</span></span><br><span class="line">➜ ll kube-proxy*pem</span><br><span class="line"></span><br><span class="line">-rw------- 1 haxi haxi 1679 Dec 31 10:26 kube-proxy-key.pem</span><br><span class="line">-rw-rw-r-- 1 haxi haxi 1407 Dec 31 10:26 kube-proxy.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 kube-proxy 证书到 /etc/kubernetes/pki</span></span><br><span class="line">➜ cp kube-proxy*pem /etc/kubernetes/pki</span><br></pre></td></tr></table></figure><h3 id="部署-kube-proxy-1">10.2 部署 kube-proxy</h3><p>编写服务配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/kube-proxy.conf &lt;&lt; EOF</span><br><span class="line">KUBE_PROXY_OPTS=&quot;--config=/etc/kubernetes/kube-proxy.yaml \</span><br><span class="line">  --logtostderr=false \</span><br><span class="line">  --v=4 \</span><br><span class="line">  --log-dir=/var/log/kubernetes&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/kube-proxy.yaml &lt;&lt; EOF</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig</span><br><span class="line">bindAddress: 0.0.0.0</span><br><span class="line">clusterCIDR: 10.240.0.0/12</span><br><span class="line">healthzBindAddress: 0.0.0.0:10256</span><br><span class="line">metricsBindAddress: 0.0.0.0:10249</span><br><span class="line">mode: ipvs</span><br><span class="line">ipvs:</span><br><span class="line">  scheduler: &quot;rr&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成 kubeconfig</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.128.170.20:6443 --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config set-context default --cluster=kubernetes --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line">➜ cp kube-proxy.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><p>编写服务启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; &quot;EOF&quot;</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Proxy</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/kubernetes/kube-proxy.conf</span><br><span class="line">ExecStart=/usr/local/bin/kube-proxy $KUBE_PROXY_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动 kube-proxy 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-proxy</span><br></pre></td></tr></table></figure><h2 id="部署网络">11. 部署网络</h2><h3 id="部署-calico">11.1 部署 calico</h3><p>参考地址 <a href="https://projectcalico.docs.tigera.io/getting-started/kubernetes/self-managed-onprem/onpremises">calico</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">➜ curl https://projectcalico.docs.tigera.io/v3.23/manifests/calico.yaml -O</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Pod IP 地址段，找到 CALICO_IPV4POOL_CIDR 变量，取消注释并修改如下</span></span><br><span class="line">            - name: CALICO_IPV4POOL_CIDR</span><br><span class="line">              value: &quot;10.240.0.0/12&quot;</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f calico.yaml</span><br><span class="line"></span><br><span class="line">configmap/calico-config created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/caliconodestatuses.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipreservations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/kubecontrollersconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">daemonset.apps/calico-node created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">deployment.apps/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br><span class="line">poddisruptionbudget.policy/calico-kube-controllers created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络 pod</span></span><br><span class="line">➜ kubectl get deploy,pod -n kube-system</span><br><span class="line"></span><br><span class="line">NAME                                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/calico-kube-controllers   1/1     1            1           24m</span><br><span class="line"></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/calico-kube-controllers-6b77fff45-mxxkg   1/1     Running   0          24m</span><br><span class="line">pod/calico-node-ld4sg                         1/1     Running   0          24m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 node 状态</span></span><br><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">cnode0   Ready    &lt;none&gt;   38m   v1.23.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 ipvs 模式</span></span><br><span class="line">➜ ipvsadm -Ln</span><br><span class="line"></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  10.96.0.1:443 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.128.170.20:6443           Masq    1      5          0</span></span><br></pre></td></tr></table></figure><p><strong>如果 node 状态仍然是 NotReady，基本上是镜像未拉取完成或拉取失败导致的，如果一段时间后仍拉取失败，则尝试手动拉取镜像。</strong></p><h3 id="授权-kube-apiserver-访问-kubelet">11.2 授权 kube-apiserver 访问 kubelet</h3><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization</a></p><p>应用场景：例如 kubectl exec/run/logs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; apiserver-to-kubelet-rbac.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - nodes/proxy</span><br><span class="line">      - nodes/stats</span><br><span class="line">      - nodes/log</span><br><span class="line">      - nodes/spec</span><br><span class="line">      - nodes/metrics</span><br><span class="line">      - pods/log</span><br><span class="line">    verbs:</span><br><span class="line">      - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-apiserver</span><br><span class="line">  namespace: &quot;&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">subjects:</span><br><span class="line">  - apiGroup: rbac.authorization.k8s.io</span><br><span class="line">    kind: User</span><br><span class="line">    name: kubernetes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f apiserver-to-kubelet-rbac.yaml</span><br><span class="line"></span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:kube-apiserver-to-kubelet created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/system:kube-apiserver created</span><br><span class="line"></span><br><span class="line">➜ kubectl logs calico-kube-controllers-6b77fff45-mxxkg -n kube-system</span><br></pre></td></tr></table></figure><h3 id="部署-coredns">11.3 部署 coredns</h3><p>参考地址 <a href="https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed">coredns</a></p><p><strong>coredns.yaml.sed 原始文件见附录章节 "16.1 coredns.yaml.sed"，该 yaml 指定使用的 coredns 的版本是 1.9.2。</strong></p><p>下载 yaml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ curl https://raw.githubusercontent.com/coredns/deployment/master/kubernetes/coredns.yaml.sed -o coredns.yaml</span><br></pre></td></tr></table></figure><p>对 yaml 文件做如下修改：</p><ul><li>CLUSTER_DOMAIN 改为 cluster.local</li><li>REVERSE_CIDRS 改为 in-addr.arpa ip6.arpa</li><li>UPSTREAMNAMESERVER 改为 /etc/resolv.conf，如果报错，则改成当前网络所使用的 DNS 地址</li><li>删除 STUBDOMAINS</li><li>CLUSTER_DNS_IP 改为 10.96.0.10（应与 /etc/kubernetes/kubelet.yaml 中配置的 clusterDNS 保持一致）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f coredns.yaml</span><br></pre></td></tr></table></figure><p>验证<strong>（如果 calico 的 pod 未就绪，请检查是否是镜像拉取未完成或镜像拉取失败）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get deploy,pod,svc -n kube-system</span><br><span class="line">NAME                                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/calico-kube-controllers   1/1     1            1           43m</span><br><span class="line">deployment.apps/coredns                   1/1     1            1           3m8s</span><br><span class="line"></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/calico-kube-controllers-6b77fff45-mxxkg   1/1     Running   0          43m</span><br><span class="line">pod/calico-node-ld4sg                         1/1     Running   0          43m</span><br><span class="line">pod/coredns-799bc9dbc6-qqh7h                  1/1     Running   0          3m8s</span><br><span class="line"></span><br><span class="line">NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">service/kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   3m8s</span><br></pre></td></tr></table></figure><p>dig 测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ yum install bind-utils -y</span><br><span class="line"></span><br><span class="line">➜ dig -t A www.baidu.com @10.96.0.10 +short</span><br><span class="line"></span><br><span class="line">www.a.shifen.com.</span><br><span class="line">182.61.200.6</span><br><span class="line">182.61.200.7</span><br></pre></td></tr></table></figure><p>pod 测试</p><p><a href="https://www.cnblogs.com/vincenshen/p/9751193.html">Kubernetes busybox nslookup问题</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl run -it --rm --image=busybox:1.28.3 -- sh</span><br><span class="line"></span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # cat /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br><span class="line">/ # nslookup kubernetes.default</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br><span class="line">/ # ping -c 4 www.baidu.com</span><br><span class="line">PING www.baidu.com (182.61.200.6): 56 data bytes</span><br><span class="line">64 bytes from 182.61.200.6: seq=0 ttl=52 time=6.860 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=1 ttl=52 time=6.592 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=2 ttl=52 time=6.488 ms</span><br><span class="line">64 bytes from 182.61.200.6: seq=3 ttl=52 time=7.288 ms</span><br><span class="line"></span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 6.488/6.807/7.288 ms</span><br></pre></td></tr></table></figure><h2 id="添加-worker-节点">12. 添加 worker 节点</h2><p>worker 节点需要部署两个组件 <code>kubelet</code>, <code>kube-proxy</code>.</p><p>（master 节点执行）从 master 节点上复制以下文件到 worker 节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ scp /etc/kubernetes/pki/ca.pem \</span><br><span class="line">       /etc/kubernetes/pki/kube-proxy.pem \</span><br><span class="line">       /etc/kubernetes/pki/kube-proxy-key.pem \</span><br><span class="line">       root@cnode1:/etc/kubernetes/pki/</span><br><span class="line"></span><br><span class="line">➜ scp /etc/kubernetes/kubelet.conf \</span><br><span class="line">       /etc/kubernetes/kubelet.yaml \</span><br><span class="line">       /etc/kubernetes/kubelet-bootstrap.kubeconfig \</span><br><span class="line">       /etc/kubernetes/kube-proxy.conf \</span><br><span class="line">       /etc/kubernetes/kube-proxy.yaml \</span><br><span class="line">       /etc/kubernetes/kube-proxy.kubeconfig \</span><br><span class="line">       root@cnode1:/etc/kubernetes/</span><br><span class="line"></span><br><span class="line">➜ scp /usr/lib/systemd/system/kubelet.service \</span><br><span class="line">       /usr/lib/systemd/system/kube-proxy.service \</span><br><span class="line">       root@cnode1:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure><p>（master 节点执行）复制 <code>kubelet</code>, <code>kube-proxy</code> 二进制程序到 /usr/local/bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ scp /usr/local/bin/kubelet \</span><br><span class="line">       /usr/local/bin/kube-proxy \</span><br><span class="line">       root@cnode1:/usr/local/bin/</span><br></pre></td></tr></table></figure><p>（worker 节点执行）worker 节点启动 kube-proxy 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kube-proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kube-proxy</span><br></pre></td></tr></table></figure><p>（worker 节点执行）worker 节点启动 kubelet 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">➜ systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证结果</span></span><br><span class="line">➜ systemctl status kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">➜ journalctl -u kubelet</span><br></pre></td></tr></table></figure><p>（master 节点执行）批准 worker 节点加入集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-9mvtn   23s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Pending</span><br><span class="line"></span><br><span class="line">➜ kubectl certificate approve csr-9mvtn</span><br><span class="line"></span><br><span class="line">certificatesigningrequest.certificates.k8s.io/csr-9mvtn approved</span><br><span class="line"></span><br><span class="line">➜ kubectl get csr</span><br><span class="line"></span><br><span class="line">NAME        AGE     SIGNERNAME                                    REQUESTOR           REQUESTEDDURATION   CONDITION</span><br><span class="line">csr-9mvtn   3m16s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   &lt;none&gt;              Approved,Issued</span><br></pre></td></tr></table></figure><p>（master 节点执行）查看节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get node</span><br><span class="line"></span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION</span><br><span class="line">cnode0   Ready    &lt;none&gt;   4h31m   v1.23.6</span><br><span class="line">cnode1   Ready    &lt;none&gt;   105m    v1.23.6</span><br></pre></td></tr></table></figure><p><strong>如果 cnode1 的状态仍是 NotReady，请检查是否是镜像拉取未完成或镜像拉取失败。</strong></p><h2 id="禁止-master-节点运行-pod">13. 禁止 master 节点运行 pod</h2><p>至此 1 master 1 worker 的 k8s 二进制集群已搭建完毕。</p><p>此外，还可以给节点打上角色标签，使得查看节点信息更加直观</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给 master 节点打上 controlplane,etcd 角色标签</span></span><br><span class="line">➜ kubectl label node cnode0 node-role.kubernetes.io/controlplane=true node-role.kubernetes.io/etcd=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给 worker 节点打上 worker 角色标签</span></span><br><span class="line">➜ kubectl label node cnode1 node-role.kubernetes.io/worker=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看节点标签</span></span><br><span class="line">➜ kubectl get node --show-labels</span><br></pre></td></tr></table></figure><p>如果不希望 master 节点运行 Pod，则给 master 打上污点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl taint node cnode0 node-role.kubernetes.io/controlplane=true:NoSchedule</span><br></pre></td></tr></table></figure><p>后续可以新增 2 个 etcd 节点组成 etcd 集群，新增 2 个控制平面，避免单点故障。</p><h2 id="测试应用服务部署">14. 测试应用服务部署</h2><p>创建 namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl create namespace dev</span><br><span class="line"></span><br><span class="line">namespace/dev created</span><br><span class="line"></span><br><span class="line">➜ kubectl get namespace</span><br><span class="line"></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   15h</span><br><span class="line">dev               Active   15s</span><br><span class="line">kube-node-lease   Active   15h</span><br><span class="line">kube-public       Active   15h</span><br><span class="line">kube-system       Active   15h</span><br></pre></td></tr></table></figure><p>创建 deployment</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜ mkdir -p /etc/kubernetes/resources</span><br><span class="line"></span><br><span class="line">➜ cat &gt; /etc/kubernetes/resources/nginx-deployment.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f /etc/kubernetes/resources/nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line">deployment.apps/nginx-deployment created</span><br><span class="line"></span><br><span class="line">➜ kubectl get pod -n dev</span><br><span class="line"></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-7d4578b56c-cndrb   1/1     Running   0          48s</span><br></pre></td></tr></table></figure><p>创建 service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ cat &gt; /etc/kubernetes/resources/nginx-service.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 30001</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">➜ kubectl apply -f /etc/kubernetes/resources/nginx-service.yaml</span><br><span class="line"></span><br><span class="line">service/nginx-service created</span><br><span class="line"></span><br><span class="line">➜ kubectl get svc -n dev</span><br><span class="line"></span><br><span class="line">NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-service   NodePort   10.96.221.226   &lt;none&gt;        80:30001/TCP   17s</span><br></pre></td></tr></table></figure><p>测试服务访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ curl 10.128.170.20:30001 -I</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.21.5</span><br><span class="line">Date: Sat, 21 May 2022 08:06:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 615</span><br><span class="line">Last-Modified: Tue, 28 Dec 2021 15:28:38 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;61cb2d26-267&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="部署-dashboard">15. 部署 Dashboard</h2><p>在 Kubernetes 社区中，有一个很受欢迎的 Dashboard 项目，它可以给用户提供一个可视化的 Web 界面来查看当前集群的各种信息。用户可以用 Kubernetes Dashboard 部署容器化的应用、监控应用的状态、执行故障排查任务以及管理 Kubernetes 各种资源。</p><p>官方参考文档：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>使用 nodeport 方式将 dashboard 服务暴露在集群外，指定使用 30443 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载相关 yaml 文件</span></span><br><span class="line">➜ curl https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.0/aio/deploy/recommended.yaml -O</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Service 部分</span></span><br><span class="line">➜ vim recommended.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 新增</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30443  # 新增</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署</span></span><br><span class="line">➜ kubectl apply -f recommended.yaml</span><br><span class="line"></span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 kubernetes-dashboard 下的资源</span></span><br><span class="line">➜ kubectl get deploy -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">dashboard-metrics-scraper   1/1     1            1           12m</span><br><span class="line">kubernetes-dashboard        1/1     1            1           12m</span><br><span class="line"></span><br><span class="line">➜ kubectl get pod -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-799d786dbf-xpvcc   1/1     Running   0          13m</span><br><span class="line">kubernetes-dashboard-546cbc58cd-hzvhr        1/1     Running   0          13m</span><br><span class="line"></span><br><span class="line">➜ kubectl get svc -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.96.73.62     &lt;none&gt;        8000/TCP        13m</span><br><span class="line">kubernetes-dashboard        NodePort    10.96.148.106   &lt;none&gt;        443:30443/TCP   13m</span><br></pre></td></tr></table></figure><p><strong>如果 kubernetes-dashboard 下的资源一直未就绪，请检查是否是正在拉取镜像或者镜像一直拉取失败。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl describe pod kubernetes-dashboard-546cbc58cd-hzvhr -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  6m20s  default-scheduler  Successfully assigned kubernetes-dashboard/kubernetes-dashboard-546cbc58cd-hzvhr to cnode1</span><br><span class="line">  Normal  Pulling    6m20s  kubelet            Pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line"></span><br><span class="line">➜ kubectl describe pod kubernetes-dashboard-546cbc58cd-hzvhr -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason          Age                 From               Message</span><br><span class="line">  ----     ------          ----                ----               -------</span><br><span class="line">  Normal   Scheduled       10m                 default-scheduler  Successfully assigned kubernetes-dashboard/kubernetes-dashboard-546cbc58cd-hzvhr to cnode1</span><br><span class="line">  Warning  Failed          2m1s                kubelet            Failed to pull image &quot;kubernetesui/dashboard:v2.5.0&quot;: rpc error: code = Unknown desc = dial tcp 104.18.124.25:443: i/o timeout</span><br><span class="line">  Warning  Failed          2m1s                kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   SandboxChanged  2m                  kubelet            Pod sandbox changed, it will be killed and re-created.</span><br><span class="line">  Normal   BackOff         118s (x3 over 2m)   kubelet            Back-off pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line">  Warning  Failed          118s (x3 over 2m)   kubelet            Error: ImagePullBackOff</span><br><span class="line">  Normal   Pulling         106s (x2 over 10m)  kubelet            Pulling image &quot;kubernetesui/dashboard:v2.5.0&quot;</span><br><span class="line">  Normal   Pulled          25s                 kubelet            Successfully pulled image &quot;kubernetesui/dashboard:v2.5.0&quot; in 1m21.608630166s</span><br><span class="line">  Normal   Created         22s                 kubelet            Created container kubernetes-dashboard</span><br><span class="line">  Normal   Started         21s                 kubelet            Started container kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>创建 service account 并绑定默认 cluster-admin 管理员集群角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面创建了一个叫 admin-user 的服务账号，放在 kubernetes-dashboard 命名空间下，并将 cluster-admin 角色绑定到 admin-user 账户，这样 admin-user 账户就有了管理员的权限。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，kubeadm 创建集群时已经创建了 cluster-admin 角色，我们直接绑定即可。</span></span><br><span class="line">➜ cat &gt; dashboard-admin-user.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用资源配置清单</span></span><br><span class="line">➜ kubectl apply -f dashboard-admin-user.yaml</span><br><span class="line"></span><br><span class="line">serviceaccount/admin-user created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/admin-user created</span><br></pre></td></tr></table></figure><p>查看 admin-user 账户的 token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">Name:         admin-user-token-vmbfm</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: admin-user</span><br><span class="line">              kubernetes.io/service-account.uid: bc3c111d-947e-4444-8fc0-2ff69abada00</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1367 bytes</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6Ikd6alY4Rm1QWFRiRk9VUDlta1U1QnFVM2VyUXpXSkUwRzRKek9QX2pxbUkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXZtYmZtIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiYzNjMTExZC05NDdlLTQ0NDQtOGZjMC0yZmY2OWFiYWRhMDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.e-fkl4gBppWnwMy5b1PvHNf5RiBL_uAT0o_QFTy4YWwkcBSnn9JqlCBJzy6Vblw2mIekkMwuOGux-vU8V9nPuAHczsKr1Kq2leZKR0rnNrFwqge-IO-U4pkY8sfWYWPo7j5Oop1dNAKt9q33WyenjpA6T_IF-TmdtsX4AhLeZp67RrDotq80dpSjmSBzDU2rZ6gwknCfCwum_Crn1uruNiGGP4dkFifIK78RfDyCIMdMvYuwoa9hYPTFVNPZQcTRecmdtOmfXyVHpS7FfKf3YTCm9vbyqrBLyzHinYf-dBBr5ivktJKOepuqbKSoQ68Q1KnxjeG9ouWaYa3jiukArw</span><br></pre></td></tr></table></figure><p>使用输出的 token 登录 Dashboard</p><h2 id="附录">16. 附录</h2><h3 id="coredns.yaml.sed">16.1 coredns.yaml.sed</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/bootstrapping:</span> <span class="string">rbac-defaults</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">discovery.k8s.io</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">endpointslices</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/bootstrapping:</span> <span class="string">rbac-defaults</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:coredns</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    .:53 &#123;</span></span><br><span class="line"><span class="string">        errors</span></span><br><span class="line"><span class="string">        health &#123;</span></span><br><span class="line"><span class="string">          lameduck 5s</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        ready</span></span><br><span class="line"><span class="string">        kubernetes CLUSTER_DOMAIN REVERSE_CIDRS &#123;</span></span><br><span class="line"><span class="string">          fallthrough in-addr.arpa ip6.arpa</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        prometheus :9153</span></span><br><span class="line"><span class="string">        forward . UPSTREAMNAMESERVER &#123;</span></span><br><span class="line"><span class="string">          max_concurrent 1000</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        cache 30</span></span><br><span class="line"><span class="string">        loop</span></span><br><span class="line"><span class="string">        reload</span></span><br><span class="line"><span class="string">        loadbalance</span></span><br><span class="line"><span class="string">    &#125;STUBDOMAINS</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">&quot;CoreDNS&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># replicas: not specified here:</span></span><br><span class="line">  <span class="comment"># 1. Default is 1.</span></span><br><span class="line">  <span class="comment"># 2. Will be tuned in real time if DNS horizontal auto-scaling is turned on.</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">coredns</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;CriticalAddonsOnly&quot;</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">         <span class="attr">podAntiAffinity:</span></span><br><span class="line">           <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">               <span class="attr">matchExpressions:</span></span><br><span class="line">               <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">k8s-app</span></span><br><span class="line">                 <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                 <span class="attr">values:</span> [<span class="string">&quot;kube-dns&quot;</span>]</span><br><span class="line">             <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">coredns/coredns:1.9.2</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">170Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">70Mi</span></span><br><span class="line">        <span class="attr">args:</span> [ <span class="string">&quot;-conf&quot;</span>, <span class="string">&quot;/etc/coredns/Corefile&quot;</span> ]</span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/coredns</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9153</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="attr">drop:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">all</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">Corefile</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">Corefile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;9153&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">&quot;CoreDNS&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">CLUSTER_DNS_IP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9153</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h2 id="references">References</h2><p><a href="https://www.haxi.cc/archives/setup-k8s-1-23-1-cluster-using-binary.html">二进制部署 K8s 集群 1.23.1 版本</a></p><p><a href="https://hebye.com/docs/k8s/k8s-1ct8ioki6h2qk#2nop09">部署一套完整的企业级K8s集群</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过本文的指导，读者可以了解如何通过二进制的方式部署 Kubernetes 1.23.6 版本集群。二进制部署可以加深对 Kubernetes 各组件的理解，可以灵活地将各个组件部署到不同的机器，以满足自身的要求。但是需要注意的是，二进制部署需要手动配置各个组件，需要一定的技术水平和经验。&lt;/p&gt;</summary>
    
    
    
    <category term="cloud" scheme="https://wylu.me/categories/cloud/"/>
    
    <category term="kubernetes" scheme="https://wylu.me/categories/cloud/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="https://wylu.me/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用GNU-make管理项目</title>
    <link href="https://wylu.me/posts/cec71891/"/>
    <id>https://wylu.me/posts/cec71891/</id>
    <published>2020-10-25T09:40:46.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中读者会看到有关 make 的介绍，make 是一种控制编译或者重复编译软件的工具。make 可以自动管理软件编译的内容、方式和时机，从而使程序员能够把精力集中在编写代码上。</p><span id="more"></span><h1 id="使用-gnu-make-管理项目">使用 GNU make 管理项目</h1><div class="note info"><p><strong>第 4 章 使用 GNU make 管理项目</strong> 原文出处：《GNU/Linux编程指南》第二版 原文作者： Kurt Wall 等著</p></div><h2 id="为何使用-make">1 为何使用 make</h2><p>除了最简单的软件项目，make 对于其他所有项目而言都很必要。首先，包含多个源代码文件的项月在编译时都有长而且复杂的命令行。而且，编程项目经常需要使用那些很少用到且难以记忆的特殊编译选项。make 可以通过把这些复杂而难记的命令行保存在 makefle 文件中来解决上述两个问题，makefile 将在下一小节讨论。</p><p>make 还能减少重复编译所需要的时间，因为它很聪明，能够判断哪些文件被修改过。进而只重新编译程序被修改过的部分。makefile 为项目构建了一个依赖信息数据库，因而可以让 make 在每次编译前检查是否可以找到所有需要的文件。make 还可以让你建立一个稳定的编译环境。最后，make 可以让编译过程自动执行，因为从 shell 脚本或者 cron (定时)作业调用 make 非常容易。</p><h2 id="编写-makefile">2 编写 makefile</h2><p>make 是怎样完成这些神奇工作的呢？是通过使用 makefile 文件做到的。</p><p>makefile 是一个文本形式的数据库文件，其中包含一些规则告诉 make 编译哪些文件、怎样编译以及在什么条件下去编译。每条规则包含以下内容：</p><ul><li>一个 "目标体" (target)，即 make 最终需要创建的东西。</li><li>包含一个或多个 "依赖体" (dependency)的列表，依赖体通常是编泽目标体需要 的其他文件。</li><li>为了从指定的依赖体创建出目标体所需执行的 "命令" (command) 的列表。</li></ul><p>虽然目标体通常都是程序，但它们可以是诸如文本文件、手册页面等任何东西。目标体甚至能测试和设置环境变量。类似地，也可以定义依赖体以确保编译开始前存在某个特殊的环境变量。最后，makefile 中的命令可以是编译器的命令或 shell 命令，它们能设置环境变量、删除文件,或者任何俞令行所能完成的功能,如从 FTP 站点下载文件等。GNU make 被调用后会顺序查找名为 GNUmakefile、makefile 或 Makefile 的文件。出于某种原因，可能只是习惯和长期形成的约定吧，大多数 Linux 程序员使用最后一种形式 Makefile。</p><p>Makefile 规则有下列通用形式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: dependency [dependency [...]</span></span><br><span class="line">command</span><br><span class="line">command</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p><strong>警告:</strong></p><p><strong>每一个命令的第一个字符必须是制表符</strong>，仗使用 8 个空格是不够的。这一点经常不被人们注意， 并且当所使用的编辑器友好的将制表符转换成 8 个空格时，会产生问题；因为如果用空格代替制表符，make 会在执行过程中显示 Missing Separator (缺少分隔符)并停止。</p><p>target 是需要创建的二进制文件或目标文件。dependency 是在创建 target 时需要输入的一个或多个文件的列表。命令序列是创建 target 文件所需要的步骤，如编译命令。此外，除非特别指定，否则 make 的工作目录就是当前目录。</p><h2 id="编写-makefile-的规则">3 编写 makefile 的规则</h2><p>如果上一节的内容对你来说太抽象， 那么本节使用程序清单 4.1 再具体讨论。这是用于编译第 3 章中出现的程序 howdy 和 hello 的 makefile 文件。</p><p>程序清单 4.1 演示目标体、依赖体和命令的简单 makefile 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">howdy: howdy.o helper.o helper.h</span></span><br><span class="line">gcc howdy.o helper.o -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c helper.h</span></span><br><span class="line">gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm howdy hello *.o</span><br></pre></td></tr></table></figure><p>要编译 howdy，只需在 makefile 所在目录下输入 make 即可。就这么简单。</p><p>这个 makefile 文件包含 6 条规则。第一个目标体 howdy 称为默认(default) 目标体，这是 make 要创建的文件。howdy 有 3 个依赖体，分别为 howdy.o、helper.o 和 helper.h，要编译生成 howdy，必须要有这 3 个文件。第二行调用编译器的命令供 make 执行来创建 howdy。由对第 3 章内容的回忆可知，这条命令从两个目标文件创建名为 howdy 的可执行文件。把头文件 helper.h 作为一个依赖体列入是为了避免编译器调用未声明的函数产生出错信息。接下来的两条规则告诉 make 怎样生成单个目标文件，helper.o 和 howdy.o。这些规则使用了 gcc 的 <code>-c</code> 选项，只创建目标文件但跳过链接。如果只想生成两个目标文件而不生成 howdy 本身，可以使用下面两条命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make helper.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make howdy.o</span></span><br></pre></td></tr></table></figure><p>更简洁一点，只需使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make helper.o howdy.o</span></span><br></pre></td></tr></table></figure><p>正如你所看到的那样，make 允许把多个目标作为参数。这两种方法都能使用相应的规则和命令生成目标文件。图 4.1 给出了这个过程的图示。</p><p>图4.1 把生成 howdy 的步骤归结到第 3 章讨论的一般性的 预处理/编译/链接 过程上。howdy.c 和 helper.c 这两个源代码文件经预处理后编译成目标文件。然后链接器把来自文件 howdy.o 和 helper.o 的目标代码和标准库以及 C 启动代码链接到一起生成二进制文件 hello。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9fdf0734b6ed1ac256008456d12d2187.png" alt="compile" /></p><p>现在，make 的价值就体现出来了：通常情况下，如果试图在依赖体 helper.o 和 howdy.o 不存在的情况下使用所示的命令编译 howdy，则 gcc 会报错井退出。另一方面，在看到 howdy 需要这两个文件（和 helper.c）后，make 先确认它们是否存在，如果不存在则首先执行命令生成它们，然后再返回到第一条规则创建可执行文件 howdy。当然，如果 helper.h 不存在，make 也会放弃执行，因为它没有创建 helper.h 的规则。</p><p>"一切都很好"，也许你会这么想，"但是 make 怎样知道什么时候需要重新编译一个文件呢？" 答案极其简单：如果指定的目标文件 make 找不到，make 就会生成它。如果目标体存在，make 会对目标体文件和依赖体文件的时间戳进行比较。如果有一个或多个依赖体比目标体新，make 就重新编译生成目标体，因为 make 认为新的依赖体意味着对代码做过修改，必须把改动融入到目标体中去。</p><p>第四条规则相当简单。它定义了如何编译生成第 3 章介绍的简单程序 hello。第五条是创建 hello 和 howdy 的笼统规则，它还表明甚至二进制文件都能作依赖体。下一小节将讨论第六条规则，即伪目标。</p><h3 id="伪目标">3.1 伪目标</h3><p>除了一般的文件目标体， 比如 howdy 和 hello 之外，make 也允许指定伪目标。称其为伪目标是因为它们并不对应于实际的文件。程序清单 4.1 中最后一个目标体 clean 就是伪目标。伪目标体规定了 make 应该执行的命令。但是，因为 clean 没有依赖体，所以它的命令不会被自动执行。下面解释 make 是如何工作的：当遇到目标体 clean 时，make 先查看其是否有依赖体，因为 clean 没有依赖体，所以 make 认为目标体是最新的而不执行任何操作。为了编译这个目标体，必须输入make clean。在本例中，clean 删除了可执行文件 hello 和 howdy 以及构成 howdy 的目标文件。在创建和发行仅包含源代码的压缩包或者需要彻底重新编译时可能会用到这样一个目标体。</p><p>然而，如果恰巧有一个名为 clean 的文件存在，make 就会发现它。然后和前面一样，因为 clean 没有依赖体文件，make 就认为这个文件是最新的而不会执行相关命令。为了处理这类情况，需要使用特殊的 make 目标体 <code>.PH0NY</code>。 <code>.PHONY</code> 的依赖体文件的含义和通常一样， 但是 make 不检查是否存在有文件名和依赖体中的一个名字相匹配的文件，而是直接执行与之相关的命令。在使用了 <code>.PHONY</code> 之后，前面的例子如下：</p><p>程序清单 4.2 带有 PHONY 目标的 Makefile 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">howdy: howdy.o helper.o helper.h</span></span><br><span class="line">gcc howdy.o helper.o -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c helper.h</span></span><br><span class="line">gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm howdy hello *.o</span><br></pre></td></tr></table></figure><h3 id="变量">3.2 变量</h3><p>为了简化编辑和维护 makefile，make 允许在 makefile 中创建和使用变量。所谓的变量其实是用指定文本串在 makefile 中定义的一个名字，这个文本串就是变量的值。下面是定义变量的一般方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARNAME=some_text [...]</span><br></pre></td></tr></table></figure><p>把变量用括号括起来，井在前面加上 "$" 符号，就可以引用变量的值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(VARNAME)</span></span><br></pre></td></tr></table></figure><p>此时，VARNAME 在等式右端展开为它所代表的文本。变量一般都在 makefle 的头部定义，并且，按照惯例，所有的 makefle 变量都应该是大写( 虽然这不是必须的)。这样，如果变量的值发生变化，就只需要在一个地方修改，从而简化了 makefile 的维护。现在，继续现在修改程序清单 4.1，加入两个变量，结果如程序清单 4.3 所示。</p><p>程序清单 4.3 在 makefle 中使用变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OBJS = howdy.o helper.o</span><br><span class="line">HDRS = helper.h</span><br><span class="line"></span><br><span class="line"><span class="section">howdy: <span class="variable">$(OBJS)</span> <span class="variable">$(HDRS)</span></span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o howdy</span><br><span class="line"></span><br><span class="line"><span class="section">helper.o: helper.c <span class="variable">$(HDRS)</span></span></span><br><span class="line">gcc -c helper.c</span><br><span class="line"></span><br><span class="line"><span class="section">howdy.o: howdy.c</span></span><br><span class="line">gcc -c howdy.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">all: howdy hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm howdy hello *.o</span><br></pre></td></tr></table></figure><p>OBJS 和 HDRS 在被引用的每个地方都展开成它的取值。编译时也是如此。</p><p>实际上，make 使用两种变量：<strong>递归展开变量和简单展开变量</strong>。递归展开变量在引用时逐层展开，即如果在展开式中包含了对其他变量的引用，则这些变量也将被展开，直到没有需要展开的变量为止，这就是所谓的递归展开。下面的例子有助于弄清这个概念。</p><p>假设变量 TOPDIR 和 SRCDIR 如下定义:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TOPDIR = /home/kwall/myproject</span><br><span class="line">SRCDIR = <span class="variable">$(TOPDIR)</span>/src</span><br></pre></td></tr></table></figure><p>这样，SRCDIR 的值是 /home/kwall/myproject/src，则工作正常。但是，考虑下面的变量定义:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CC = <span class="variable">$(CC)</span> -o</span><br></pre></td></tr></table></figure><p>很清楚，定义者想要得到的结果是 "CC=gcc -o"。但是实际并非如此；CC 在被引用时递归展开，从而陷入一个无限循环中；CC 将扩展为 <code>$(CC)</code> 的值，从而永远也读不到 <code>-o</code> 选项。幸运的是，make 能够检测到这个问题并报告错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Recursive variable &#x27;CC&#x27; references itself (eventually). Stop</span><br></pre></td></tr></table></figure><p>为了避免这个问题，可以使用<strong>简单展开变量</strong>。与<strong>递归展开变量</strong>在引用时展开不同，简单展开变量在定义处展开，并且只展开一次，从而消除了变量的嵌套引用。在定义时,其语法与递归展开变量有细微的不同：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC := gcc -o</span><br><span class="line">CC += -O2</span><br></pre></td></tr></table></figure><p>第一个定义使用 <code>:=</code> 设置 CC 的值为 <code>gcc -o</code>，第二个定义使用 "+=" 在前面定义的 CC 后附加了 <code>-O2</code>，从而 CC 最终的值是 <code>gcc -o -O2</code>。如果在使用 make 变量时遇到 "VARNAME references itself" 这类错误信息，就可以使用简单展开变量来解决。一些程序员仅使用简单展开变量，以避免出现意想不到的问题；但既然现在是在 Linux 上，你可以自由选择使用的方式。</p><p>除用户定义变量外, make 也允许使用环境变量、自动变量和预定义变量。使用环境变量非常简单。在启动时，make 读取己定义的环境变量，并且创建与之同名同值的变量。但是，如果 makefile 中有同名的变量，则这个变量将取代与之相应的环境变量，所以应当注意这一点。</p><p>此外，make 也提供一长串预定义变量和自动变量，但是它们看起来有些神秘。之所以称为自动变量是因为 make 自动用特定的、熟知的值替换它们。表 4.1 给出了部分自动变量。</p><h4 id="表-4.1-自动变量">表 4.1 自动变量</h4><table><thead><tr class="header"><th>变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$@</td><td>规则的目标所对应的文件名</td></tr><tr class="even"><td>$&lt;</td><td>规则中的第一个相关文件名</td></tr><tr class="odd"><td>$^</td><td>规则中所有相关文件的列表，以空格为分隔符</td></tr><tr class="even"><td>$?</td><td>规则中日期新于目标的所有相关文件的列表，以空格为分隔符</td></tr><tr class="odd"><td>$(<span class="citation" data-cites="D">@D</span>)</td><td>目标文件的目录部分(如果目标在子目录中)</td></tr><tr class="even"><td>$(<span class="citation" data-cites="F">@F</span>)</td><td>目标文件的文件名部分(如果目标在子目录中)</td></tr></tbody></table><p>除了表 4.1 列出的自动变量外，make 还预定义了许多其他变量，用于定义程序名或给这些程序传递标志和参数。这些预定义的变量看上去更像常规的 make 变量而不是像字符名称的自动变量。表 4.2 给出了一些有用的预定义变量。</p><h4 id="表4.2-用于程序名和标志的预定义变量">表4.2 用于程序名和标志的预定义变量</h4><table><thead><tr class="header"><th>变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>AR</td><td>归档维护程序，默认值=ar</td></tr><tr class="even"><td>AS</td><td>汇编程序，默认值=as</td></tr><tr class="odd"><td>CC</td><td>C 编译程序，默认值=cc</td></tr><tr class="even"><td>CPP</td><td>C 预处理程序，默认值=cpp</td></tr><tr class="odd"><td>RM</td><td>文件删除程序，默认值="rm -f"</td></tr><tr class="even"><td>ARFLAGS</td><td>传给归档维护程序的标志，默认值=rv</td></tr><tr class="odd"><td>ASFLAGS</td><td>传给汇编程序的标志，没有默认值</td></tr><tr class="even"><td>CFLAGS</td><td>传给 C 编译器的标志，没有默认值</td></tr><tr class="odd"><td>CPPFLAGS</td><td>传给 C 预处理程序的标志，没有默认值</td></tr><tr class="even"><td>LDFLAGS</td><td>传给链接程序（Id）的标志，没有默认值</td></tr></tbody></table><p>如果需要，可以在 makefile 中重新定义这些变量，但是在大多数情况下，这些默认值都是合理的。</p><h3 id="隐式规则">3.3 隐式规则</h3><p>除了在 makefile 文件中显式指定的规则（称为显式规则）外，make 还有一整套隐式规则，或称为预定义规则。这些规则多数有特殊目的而且用途有限，所以在这里只介绍几种最常用的隐式规则。隐式规则简化了 makefile 的编写和维护。</p><p>假设有下面这样的一个 makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OBJS = editor.o screen.o keyboard.o</span><br><span class="line"></span><br><span class="line"><span class="section">editor: <span class="variable">$(OBJS)</span></span></span><br><span class="line">cc -o editor <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm editor <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure><p>默认目标 editor 所对应的命令提及了 editor.o，screen.o 和 keyboard.o，但是 makefile 中没有怎样编译生成这些目标的规则。此时，make 就使用所谓的隐式规则，实际上，对每一个名为 somefile.o 的目标（object）文件，make 首先找到与之相应的源代码 somefile.c，并且用 <code>gcc -c somefile.c -o somefile.o</code> 编译生成这个目标文件。所以，在本例中 make 先查找名 为 editor.c，screen.c 和 keyboard.c 的文件并将它们编译为目标文件（editor.o，screen.o 和 keyboard.o），然后，编译生成默认目标 editor。</p><p>实际的机制比这里所描述的要全面。目标文件（.o） 可以从 C、Pascal 和 Fortran 等源代码中生成，所以 make 也应去查找符合实际情况的相关文件。所以，如果在工作目录下有 editor.p，screen.p 和 keyboard.p 三个 Pascal 文件（p 通常被认为是 Pascal 源代码的扩展名），make 就会激活 Pascal 编译器来编译它们，而不用 C 编译器。因此，如果出于某种原因而在项目中需要使用多种语言时，就不能依靠隐式规则，因为此时使用该规则所得到的结果可能会与期望的有所不同。</p><h3 id="模式规则">3.4 模式规则</h3><p>通过定义用户自己的隐式规则，模式规则提供了扩展 make 的隐式规则的一种方法。模式规则类似于普通规则，但是它的目标必定含有符号 "%"，这个符号可以与任何非空字符串匹配；为与目标中的 "%" 匹配，这个规则的相关文件部分也必须使用 "%"。例如，下面的规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br></pre></td></tr></table></figure><p>告诉 make 所有形为 somename.o 的目标（object）文件都应从源文件 somename.c 编译而来。</p><p>与隐式规则一样， make 预定义了一些模式规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>与前面的例子相同，make 定义了一条规则，即任何 x.o 的文件都从 x.c 编译而来。每次使用该规则时，该规则用自动变量 <code>$&lt;</code> 和 <code>$@</code> 来代替第一个依赖体和目标体。此外，变量 <code>$(CC)</code>，<code>$(CFLAGS)</code> 和 <code>$(CPPFLAGS)</code> 的默认值如表 4.2 所示。</p><h3 id="注释">3.5 注释</h3><p>在 makefile 中插入注释时，必须在注释前加上符号 "#"。make 读到 "#" 后，它忽略该符号以及这一行余下的字母。注释可以出现在 makefile 的所有地方。但是，因为多数 shell 把 "#" 看作是元符号（通常也是注释符），所以在命令中加入注释时要特别小心。此外，实际上就 make 本身而言，一个只含注释的行就是一个空行。</p><h2 id="命令行选项和参数">4 命令行选项和参数</h2><p>同多数 GNU 程序一样，make 也有丰富的命令行选项。表 4.3 列出了最常用的部分。</p><p>表 4.3 常用的 make 俞令行选项</p><table><thead><tr class="header"><th>选项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>-f file</code></td><td>指定 makefile 的文件名</td></tr><tr class="even"><td><code>-n</code></td><td>打印将需要执行的命令，但实际上并不执行这些命令</td></tr><tr class="odd"><td><code>-Idirname</code></td><td>指定被包含的 makefile 所在的目录</td></tr><tr class="even"><td><code>-s</code></td><td>在执行时不打印命令名</td></tr><tr class="odd"><td><code>-w</code></td><td>如果 make 在执行时改变目录，打印当前目录名</td></tr><tr class="even"><td><code>-Wfile</code></td><td>如果文件己修改，则使用 <code>-n</code> 来显示 make 将要执行的命令</td></tr><tr class="odd"><td><code>-r</code></td><td>禁止使用所有 make 的内置规则</td></tr><tr class="even"><td><code>-d</code></td><td>打印调试信息</td></tr><tr class="odd"><td><code>-i</code></td><td>忽略 makefile 规则中的命令执行后返回的非零错误码。此时，即使某个命令返回非零的退出状态值，make 仍将继续执行</td></tr><tr class="even"><td><code>-k</code></td><td>如果某个目标编译失败，继续编译其他目标。通常，make 在一个目标编译失败后终止</td></tr><tr class="odd"><td><code>jN</code></td><td>每次运行 N 条命令，这里 N 是非零整数</td></tr></tbody></table><h2 id="调试-make">5 调试 make</h2><p>如果在使用 make 时遇到问题，<code>-d</code> 选项能够使 make 在执行命令时打印大量的额外调试信息。此时，因为需要显示 make 内部所做的每一件事以及为什么做这些事的调试信息，将会产生大量的输出。其中包括如下信息：</p><ul><li>在重新编译时 make 需要检查的文件</li><li>被比较的文件以及比较的结果</li><li>需要被重新生成的文件</li><li>make 想要使用的隐式规则</li><li>make 实际使用的隐式规则以及所执行的命令</li></ul><h2 id="常见的-make-出错信息">6 常见的 make 出错信息</h2><p>这里列出使用 make 时可能遇到的最常用的出错信息，完整文档诮参见 make 使用手册或其信息页。</p><ul><li>No rule to make target 'target'. Stop makefile 中没有包含创建指定的 target 所需要的规则，而且也没有合适的默认规则可用。</li><li>'target' is up to date 指定 target 的相关文件没有变化。</li><li>Target 'target' not remade because of errors 在编译 target 时出错，这一消息仅在使用make的 -k 选项时才会出现。</li><li>command: Command not found make 找不到命令。递常是因为命令被拼写错误或者不在路径 <code>$PATH</code> 下。</li><li>Illegal option -option 在调用 make 时包含了不能被 make 识别的选项。</li></ul><h2 id="有用的-makefile-目标">7 有用的 makefile 目标</h2><p>除了前面提及的 clean，编写 makefile 时还有一些常用的目标。名为 install 的目标把最终的二进制文件，所支持的库文件或 shell 脚本，以及相关的文档移动到文件系统中与之相应的最终位置，并适当设置文件的权限和属主。此外，install 通常也编译程序，以及运行简单的测试以确认程序已正确编译。uninstall 目标则删除由 install 目标所安装的那些文件。如果需要，在设置 install 目标前存储系统当前的设置。</p><p>dist 目标可以用来生成准备发布的软件包。最低限度，dist 目标将删除编译工作目录中旧的二进制文件和目标文件并创建一个归档文件（如普通的压缩包），以便上传到万维网页或FTP站点。</p><p>为了方便其他开发者，可以用一个 tags 目标来创建或更新程序的标记表。如果程序的验证过程比较复杂，也可以创建一个 单独的 test 或 check 目标来执行这一过程并显示适当的诊断信息。与之类似，installtest 或 installcheck 目标，通常被用来验证安装过程。当然，在此之前，install 目标必须已经成功地编译和安装了所需的程序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在本文中读者会看到有关 make 的介绍，make 是一种控制编译或者重复编译软件的工具。make 可以自动管理软件编译的内容、方式和时机，从而使程序员能够把精力集中在编写代码上。&lt;/p&gt;</summary>
    
    
    
    <category term="programming-language" scheme="https://wylu.me/categories/programming-language/"/>
    
    <category term="c" scheme="https://wylu.me/categories/programming-language/c/"/>
    
    
    <category term="make" scheme="https://wylu.me/tags/make/"/>
    
    <category term="makefile" scheme="https://wylu.me/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>差分序列</title>
    <link href="https://wylu.me/posts/eaa75cf0/"/>
    <id>https://wylu.me/posts/eaa75cf0/</id>
    <published>2020-09-20T14:02:20.000Z</published>
    <updated>2022-11-23T17:04:10.533Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍差分序列的定义及其应用。</p><span id="more"></span><h1 id="差分序列数组">差分序列（数组）</h1><h2 id="差分序列的定义">差分序列的定义</h2><p>给定一个序列 a, a[i] 表示序列的第 i 个元素（编号从 0 开始），则其差分序列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d[0] = a[0]  (i == 0)</span><br><span class="line">d[i] = a[i] - a[i-1]  (i &gt; 0)</span><br></pre></td></tr></table></figure><h2 id="差分序列示例">差分序列示例</h2><table><thead><tr class="header"><th>索引 i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>原始序列 a[i]</td><td>0</td><td>2</td><td>5</td><td>4</td><td>9</td><td>7</td><td>10</td><td>0</td></tr><tr class="even"><td>差分序列 d[i]</td><td>0</td><td>2</td><td>3</td><td>-1</td><td>5</td><td>-2</td><td>3</td><td>-10</td></tr></tbody></table><p>现在假设将区间 a[1, 4] 所有的数都加上 3，则：</p><table><thead><tr class="header"><th>索引 i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>原始序列 a[i]</td><td>0</td><td>2+3=5</td><td>5+3=8</td><td>4+3=7</td><td>9+3=12</td><td>7</td><td>10</td><td>0</td></tr><tr class="even"><td>差分序列 d[i]</td><td>0</td><td>2+3=5</td><td>3</td><td>-1</td><td>5</td><td>-2-3=-5</td><td>3</td><td>-10</td></tr></tbody></table><p>然后将区间 a[3, 5] 所有的数都减去 5，则：</p><table><thead><tr class="header"><th>索引 i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>原始序列 a[i]</td><td>0</td><td>2+3=5</td><td>5+3=8</td><td>4+3=7-5=2</td><td>9+3=12-5=7</td><td>7-5=2</td><td>10</td><td>0</td></tr><tr class="even"><td>差分序列 d[i]</td><td>0</td><td>2+3=5</td><td>3</td><td>-1-5=-6</td><td>5</td><td>-2-3=-5</td><td>3+5=8</td><td>-10</td></tr></tbody></table><h2 id="差分序列的性质">差分序列的性质</h2><p>仔细观察上面的示例，可以发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[2] = d[2] + a[1]</span><br><span class="line">     = d[2] + d[1] + a[0]</span><br><span class="line">     = d[2] + d[1] + d[0]</span><br></pre></td></tr></table></figure><p>根据定义，对原序列区间操作后，原序列最终各项值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0] = d[0]  (i == 0)</span><br><span class="line">a[i] = d[i] + a[i-1]  (i &gt; 0)</span><br></pre></td></tr></table></figure><p>也即 a[i] 为 d[i] 的前缀和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = d[0] + ... + d[i]</span><br></pre></td></tr></table></figure><h2 id="差分序列的应用">差分序列的应用</h2><p><strong>基于差分序列的性质，它主要用于快速处理区间加减操作和单点查询</strong></p><h3 id="快速处理区间加减操作">快速处理区间加减操作</h3><p>假如现在对 a[L, R] 区间上所有的数加上 delta，由以上的性质可知，第一个受影响的差分数组中的元素为 d[L]，即令 d[L] += delta，那么后面数列元素在计算过程中都会加上 delta；最后一个受影响的差分数组中的元素为d[R]，所以令 d[R+1] -= delta，即可保证不会影响到 R 以后数列元素的计算。这样我们不必对区间内每一个数进行处理，只需处理两个差分后的数即可。</p><p>简单来说，当对 a[L, R] 区间所有数进行加 delta 操作时，只需:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d[L] += delta</span><br><span class="line">d[R+1] -= delta</span><br></pre></td></tr></table></figure><p>那么此时计算 a[L] ... a[R] 都会加上 delta，这里用 (d[L] + delta) 表示归约后的 d[L]，则有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[L] = (d[L] + delta) + a[L-1]</span><br><span class="line">a[L+1] = d[L+1] + a[L] = d[L+1] + (d[L] + delta) + a[L-1]</span><br><span class="line">...</span><br><span class="line">a[R] = d[R] + a[R-1] = d[R] + ... + (d[L] + delta) + a[L-1]</span><br></pre></td></tr></table></figure><h3 id="单点查询求差分序列前缀和">单点查询（求差分序列前缀和）</h3><h4 id="改变-d-数组">改变 d 数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    d[i] += d[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="改变-a-数组">改变 a 数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = d[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    a[i] = d[i] + a[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html">https://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍差分序列的定义及其应用。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="math" scheme="https://wylu.me/categories/algorithm/math/"/>
    
    
    <category term="math" scheme="https://wylu.me/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://wylu.me/posts/c517589e/"/>
    <id>https://wylu.me/posts/c517589e/</id>
    <published>2020-09-20T08:22:34.000Z</published>
    <updated>2022-11-23T17:04:10.533Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作：</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><p>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。</p><span id="more"></span><h1 id="并查集">并查集</h1><h2 id="并查集是什么">并查集是什么</h2><p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。不过需要注意并查集虽然可以进行合并操作，但是却无法进行分割操作。</p><ul><li>查询元素 a 和元素 b 是否属于同一组。</li><li>合并元素 a 和元素 b 所在的组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1e24844edcc38ebe52397ba94cf382d.png" alt="uf-func" /></p><h2 id="并查集的结构">并查集的结构</h2><p>并查集也是树形结构实现的。不过，不是二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d695760169a280d25e7442f96d7afdbf.png" alt="uf-struct" /></p><p>每个元素对应一个节点，每个组对应一棵树。在并查集中，哪个节点是哪个节点的父亲以及树的形状等信息无需多加关注，整体组成一个树形结构才是重要的。</p><p>（1）初始化</p><p>我们准备 n 个节点来表示 n 个元素。最开始时没有边。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b61b4b34b1278c478fadf7ceddef0a17.png" alt="uf-initial-state" /></p><p>（2）合并</p><p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树，也就把两个组合并为一个组了。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c1fa7ad7ca0c1a199c4e1ef16edac35a.png" alt="uf-union" /></p><p>（3）查询</p><p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p><p>在下图中，元素 2 和元素 5 都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2 或元素 5 属于不同组。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/81241fe164c49bca00235dffb8269cb7.png" alt="uf-find" /></p><h2 id="并查集实现中的注意点">并查集实现中的注意点</h2><p>在树形数据结构里，如果发生了退化的情况，那么复杂度就会变得很高。因此，有必要想办法避免退化的发生。在并查集中，只需按照如下方法就可以避免退化。</p><ul><li>对于每棵树，记录这棵树的高度(rank)。</li><li>合并时如果两棵树的 rank 不同，那么从 rank 小的向 rank 大的连边。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4844beffb80851e3db14bdf1e095e8e7.png" alt="uf-union-based-rank" /></p><p>此外，通过路径压缩，可以使得并查集更加高效。对于每个节点，一旦向上走到了一次根节点，就把这个点到父亲的边改为直接连向根。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3f76bfcaad7e4c16ee1e14035a15a234.png" alt="uf-path-compress-1" /></p><p>在此之上，不仅仅是所查询的节点，在查询过程中向上经过的所有的节点，都改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/0946c0e632dac3e08e1581769f85708a.png" alt="uf-path-compress-2" /></p><p>在使用这种简化的方法时，为了简单起见，即使树的高度发生了变化，我们也不修改 rank 的值。</p><h2 id="并查集的复杂度">并查集的复杂度</h2><p>加入了这两个优化之后的并查集效率非常高。对 n 个元素的并查集进行一次操作的复杂度是 <span class="math inline">\(O(\alpha(n))\)</span>。在这里，<span class="math inline">\(\alpha(n)\)</span> 是阿克曼( Ackermann )函数的反函数。这比 <span class="math inline">\(O(log(n))\)</span> 还要快。</p><p>不过，这是“均摊复杂度”。也就是说，并不是每一次操作都满足这个复杂度，而是多次操作之后平均每一次操作的复杂度是 <span class="math inline">\(O(\alpha(n))\)</span> 的意思。</p><h2 id="并查集的实现">并查集的实现</h2><p>下面是并查集的实现的例子。在例子中，我们用编号代表每个元素。数组 par 表示的是父亲的编号，par[x] = x 时, x 是所在的树的根。</p><h3 id="路径压缩">路径压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        self.par = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br></pre></td></tr></table></figure><h3 id="路径压缩-按秩rank合并">路径压缩 + 按秩（rank）合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 初始化 n 个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        self.par = <span class="built_in">list</span>(<span class="built_in">range</span>(n))  <span class="comment"># 祖先结点</span></span><br><span class="line">        self.rank = [<span class="number">0</span>] * n  <span class="comment"># 树的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询树的根</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并 x 和 y 所属的集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x = self.find(x)</span><br><span class="line">        y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.rank[x] &lt; self.rank[y]:</span><br><span class="line">            self.par[x] = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[y] = x</span><br><span class="line">            <span class="keyword">if</span> self.rank[x] == self.rank[y]:</span><br><span class="line">                self.rank[x] += <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a></p><p>&lt;&lt;挑战程序设计竞赛(第2版)&gt;&gt; 巫泽俊 2.4 并查集 p84-88</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。&lt;/li&gt;
&lt;li&gt;Union：将两个子集合并成同一个集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="data-structure" scheme="https://wylu.me/categories/algorithm/data-structure/"/>
    
    
    <category term="并查集" scheme="https://wylu.me/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ高可用集群搭建</title>
    <link href="https://wylu.me/posts/85807abd/"/>
    <id>https://wylu.me/posts/85807abd/</id>
    <published>2020-07-16T14:28:26.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ + HAProxy 高可用镜像模式集群部署</p><ul><li>为什么搭建 RabbitMQ 集群？</li><li>RabbitMQ 集群模式有哪些？</li><li>如何搭建 RabbitMQ 集群？</li><li>RabbitMQ 镜像模式的策略如何配置？</li></ul><span id="more"></span><h1 id="部署说明">部署说明</h1><p>下面将以一个示例说明多机部署一个高可用 RabbitMQ 集群的流程。</p><h2 id="前提">前提</h2><p>在部署集群前，必须在将成为集群成员的每个节点上安装 RabbitMQ，并确保每个节点之间能相互访问。</p><h2 id="rabbitmq-集群模式">RabbitMQ 集群模式</h2><ul><li><p>普通模式（默认的集群模式）</p><p>以两个节点 node1、node2 为例来进行说明。</p><p>对于 queue 来说，消息实体只存在于其中一个节点（node1 或 node2），node1 和 node2 两个节点仅有相同的元数据，即队列的结构。当消息进入 node1 节点的 queue 后，consumer 从 node2 节点消费时，RabbitMQ 会临时在 node1、node2 间进行消息传输，把 node1 中的消息实体取出并经过 node2 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 queue。否则无论 consumer 连接 node1 或 node2，出口总在 node1，会产生瓶颈。</p><p>当 node1 节点故障后，node2 节点无法取到 node1 节点中还未消费的消息实体。如果做了消息持久化，那么得等 node1 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</p></li><li><p>镜像模式</p><p>把需要的队列做成镜像队列，存在于多个节点，属于 RabbiMQ 的 HA 方案，在对业务可靠性要求较高的场合中比较适用。</p><p>该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。</p><p>要实现镜像模式，需要先搭建一个普通集群模式，在这个模式的基础上再配置策略以实现高可用。</p></li></ul><h2 id="集群节点类型">集群节点类型</h2><ul><li>内存（ram）节点</li><li>磁盘（disk）节点</li></ul><p>RAM 节点仅将内部数据库表存储在 RAM 中。这不包括消息，消息存储索引，队列索引和其他节点状态。</p><p>在大多数情况下，您希望所有节点都是磁盘节点。 RAM 节点是一种特殊情况，可用于提高 queue、exchange 或 binding 流失率较高的群集的性能。 RAM 节点不提供更高的消息速率。如有疑问，请仅使用磁盘节点。</p><p>由于 RAM 节点仅将内部数据库表存储在RAM中，因此它们必须在启动时从对等节点同步它们。这意味着一个群集必须至少包含一个磁盘节点。因此，不可能手动删除集群中最后剩余的磁盘节点。</p><p>在 RabbitMQ 集群中，当磁盘节点宕掉且集群中无其他可用的磁盘节点时，集群将无法写入新的队列元数据信息。</p><h2 id="环境准备">环境准备</h2><ul><li><p>系统系统：CentOS7 64位</p></li><li><p>三台服务器：192.168.0.231/232/233</p></li><li><p>服务器规划</p><table><thead><tr class="header"><th>服务器</th><th>用途</th><th>主机名</th><th>节点类型</th></tr></thead><tbody><tr class="odd"><td>192.168.0.231</td><td>RabbitMQ 集群节点 1</td><td>node231</td><td>磁盘节点</td></tr><tr class="even"><td>192.168.0.232</td><td>RabbitMQ 集群节点 2</td><td>node232</td><td>磁盘节点</td></tr><tr class="odd"><td>192.168.0.233</td><td>RabbitMQ 集群节点 3</td><td>node233</td><td>磁盘节点</td></tr></tbody></table></li></ul><h1 id="集群搭建">集群搭建</h1><h2 id="普通模式">普通模式</h2><h3 id="配置-hosts">配置 hosts</h3><p><code>vim /etc/hosts</code> 编辑三个节点的 hosts 文件，在文件末尾添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.231 node231</span><br><span class="line">192.168.0.232 node232</span><br><span class="line">192.168.0.233 node233</span><br></pre></td></tr></table></figure><h3 id="配置-hostname">配置 hostname</h3><ul><li><p>node231</p><p><code>vim /etc/hostname</code> 编辑主机名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node231</span><br></pre></td></tr></table></figure><p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node231</span><br></pre></td></tr></table></figure><p>重启 network</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li><li><p>node232</p><p><code>vim /etc/hostname</code> 编辑主机名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node232</span><br></pre></td></tr></table></figure><p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node232</span><br></pre></td></tr></table></figure><p>重启 network</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li><li><p>node233</p><p><code>vim /etc/hostname</code> 编辑主机名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node233</span><br></pre></td></tr></table></figure><p><code>vim /etc/sysconfig/network</code> 编辑网络配置文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node233</span><br></pre></td></tr></table></figure><p>重启 network</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置-erlang-cookie">配置 erlang cookie</h3><p>RabbitMQ 集群是基于 erlang 进行同步的，在 erlang 的集群中各节点同步需要一个相同的 cookie，所以必须保证各节点 cookie 一致，不然节点之间就无法通信。这个 cookie 默认存放在 <code>/var/lib/rabbitmq/.erlang.cookie</code> 中。</p><p>在任意一个节点中 copy <code>.erlang.cookie</code> 文件到其它所有节点，如在 node1 上进行 copy :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.0.232:/var/lib/rabbitmq/</span><br><span class="line">[root@node231 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.0.233:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure><h3 id="重启节点">重启节点</h3><p><strong>如果后面执行 <code>rabbitmqctl stop_app</code> 失败，需要重启 node231、node232、node233 使配置生效。</strong></p><h3 id="启动-rabbitmq-server">启动 rabbitmq-server</h3><p>分别启动 node231、node232、node233 的 rabbitmq-server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# systemctl start rabbitmq-server</span><br><span class="line">[root@node232 ~]# systemctl start rabbitmq-server</span><br><span class="line">[root@node233 ~]# systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><h3 id="将节点加入集群">将节点加入集群</h3><p>将 node232、node233 节点加入 node231 节点集群中，<strong>在 node232、node233 中分别执行以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl join_cluster rabbit@node231</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><ul><li><p>默认 RabbitMQ 启动后是磁盘节点，在这个 cluster 下，node231、node232 和 node233 都是是磁盘节点。</p></li><li><p>如果要使 node232、node233 都是内存节点，加上 <code>--ram</code> 参数即可，如 <code>rabbitmqctl join_cluster --ram rabbit@node232</code>。</p></li><li><p>如果想要更改节点类型，可以使用命令 <code>rabbitmqctl change_cluster_node_type disc(ram)</code>，修改节点类型前需要先 <code>rabbitmqctl stop_app</code>。</p><p>(Note: disk and disc are used interchangeably)</p></li></ul><h3 id="查看集群状态">查看集群状态</h3><p>任意节点执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure><h3 id="创建管理用户">创建管理用户</h3><p>如果在主机名变更前就已经创建过用户的，仍需要重新重新创建，因为主机名的变更，之前创建的用户无法登录 web 管理系统。</p><p>以下操作在 node231 下执行：</p><ul><li><p>创建 vhost（可选，默认使用 "/" vhost）</p><p>这里创建一个 vhost 用于测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# rabbitmqctl add_vhost testvhost</span><br></pre></td></tr></table></figure></li><li><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# add_user admin password</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li><li><p>设置用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# set_permissions -p testvhost admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="启用-rabbitmq-management">启用 rabbitmq management</h3><p>在 node231 上启用 rabbitmq management</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node231 ~]# rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>在浏览器中访问 http://192.168.0.231:15672，使用 "admin/password" 即可登录。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/aa2b806e6f5fe277c99c51f62c909671.png" alt="web-management" /></p><h2 id="镜像模式">镜像模式</h2><p>上面已经完成 RabbitMQ 默认集群模式，但并不保证队列的高可用性，尽管 Exchanges、Bindings 这些可以复制到集群里的任何一个节点，但是队列内容不会复制。所以集群中的节点宕机后将直接导致队列无法应用或消息丢失，要想队列在节点宕机或故障时也能正常应用，需要复制队列内容到集群中的每个节点，这就要使用镜像队列了。</p><h3 id="镜像队列">镜像队列</h3><p>默认情况下，RabbitMQ 集群中 queue 的内容位于单个节点（声明该 queue 的节点）上。这与 exchanges 和 bindings 相反，exchanges 和 bindings 始终可以被视为在所有节点上。可以选择使 queue 跨多个节点进行镜像。</p><p>每个镜像队列由一个 master 和一个或多个镜像（mirrors）组成。master 托管在一个通常称为主节点的节点上。每个队列都有其自己的主节点。给定队列的所有操作都首先应用于队列的主节点，然后传播到镜像节点。这涉及排队发布，向消费者传递消息，跟踪来自消费者的确认等。</p><p>队列镜像意味着节点的集群。发布到队列的消息将复制到所有镜像。无论消费者连接到哪个节点，最终都会被连接到主节点，镜像节点都会丢弃已在主节点上确认的消息。因此，队列镜像可提高可用性，但不会在节点之间分配负载（所有参与的节点均完成所有工作）。</p><p>如果承载队列主节点发生故障，则最早的镜像将在同步后提升为新的主节点。根据队列镜像参数，也可以升级不同步的镜像。</p><h3 id="配置镜像策略">配置镜像策略</h3><p>使用策略（policiy）配置镜像参数。 一个策略按名称（使用正则表达式模式）匹配一个或多个队列，并且包含一个定义（可选参数的映射），该定义被添加到匹配队列的全部属性中。</p><h4 id="通过控制台添加策略">通过控制台添加策略</h4><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f690c8e9ed28c2bc2c120bdd360d6db9.png" alt="add-policy" /></p><p>如果其他节点也启用了 <code>rabbitmq_management</code>，此时其他节点的控制台，可以看到上面添加的这个策略，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/9f8d54c88f312999ebda6a3563895be5.png" alt="show-policies" /></p><p>参数说明：</p><ul><li><p>Virtual host：策略应用的 vhost。</p></li><li><p>Name：为策略名称，可以是任何东西，但建议使用不带空格的基于ASCII的名称。</p></li><li><p>Pattern：与一个或多个 queue（exchange） 名称匹配的正则表达式，可以使用任何正则表达式。只有一个 <code>^</code> 代表匹配所有，<code>^test</code> 为匹配名称为 "test" 的 exchanges 或者 queue。</p></li><li><p>Apply to：Pattern 应用对象。</p></li><li><p>Priority：配置了多个策略时候的优先级，值越大，优先级越高。</p><p>（没有指定优先级的消息会以0优先级对待。对于超过队列所定最大优先级的消息，优先级以最大优先级对待）</p></li><li><p>Definition：一组键/值对（例如 JSON 文档），将被插入匹配 queues and exchanges 的可选参数映射中</p><p><code>ha-mode</code>：策略键，分为3种模式</p><ul><li><code>all</code> - 所有（所有的 queue）</li><li><code>exctly</code> - 部分（需配置 <code>ha-params</code> 参数，此参数为 int 类型。比如 3，众多集群中的随机 3 台机器）</li><li><code>nodes</code> - 指定（需配置 <code>ha-params</code> 参数，此参数为数组类型。比如 ["rabbit@node2", "rabbit@node3"] 这样指定为 node2 与 node3 这两台机器）</li></ul><p><code>ha-sync-mode</code>：队列同步</p><ul><li><code>manual</code>：手动（默认模式）。新的队列镜像将不会收到现有的消息，它只会接收新的消息</li><li><code>automatic</code>：自动同步。当一个新镜像加入时，队列会自动同步。队列同步是一个阻塞操作。</li></ul></li></ul><h4 id="通过命令行添加策略">通过命令行添加策略</h4><ul><li><p>设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br></pre></td></tr></table></figure></li><li><p>清除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_policy [-p &lt;vhost&gt;] &lt;name&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_policies [-p &lt;vhost&gt;]</span><br></pre></td></tr></table></figure></li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl set_policy -p testvhost testha <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span></span><br><span class="line">Setting policy &quot;testha&quot; for pattern &quot;^&quot; to &quot;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&quot; with priority &quot;0&quot; for vhost &quot;testvhost&quot; ...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_policies -p testvhost</span></span><br><span class="line">Listing policies for vhost &quot;testvhost&quot; ...</span><br><span class="line">vhost   name    pattern apply-to        definition      priority</span><br><span class="line">testvhost       testha  ^       all     &#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;    0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl clear_policy -p testvhost testha</span></span><br><span class="line">Clearing policy &quot;testha&quot; on vhost &quot;testvhost&quot; ...</span><br></pre></td></tr></table></figure><h3 id="测试策略是否生效">测试策略是否生效</h3><p>在控制台的队列页面上，镜像队列将展示策略名称和其他副本（镜像）数量。以下是一个名为 three_replicas 的队列的示例，该队列具有一个 master（主节点）和两个镜像节点。</p><p>添加队列：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f87d9375a9966279b88a875b17f7a0f6.png" alt="add-queue" /></p><p>查看队列：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/68f6f3b13a8ac482762e9ebc18bcb15c.png" alt="show-queues" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a898790949e41995ed079ca741392e54.png" alt="queue-detail" /></p><h1 id="haproxy-负载均衡">HAProxy 负载均衡</h1><p>HAProxy 是由 C 语言编写的免费的开源软件，它快速而高效，可为基于TCP和HTTP的应用程序提供高可用、高性能的负载平衡器和代理服务器。</p><h2 id="环境准备-1">环境准备</h2><table><thead><tr class="header"><th>服务器</th><th>用途</th><th>系统</th><th>版本</th></tr></thead><tbody><tr class="odd"><td>192.168.0.235</td><td>负载均衡服务器</td><td>Ubuntu 20.04</td><td>haproxy 2.0</td></tr></tbody></table><h2 id="安装">安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install haproxy</span></span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p><code>vim /etc/haproxy/haproxy.cfg</code> 编辑 haproxy 配置文件，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    maxconn 512</span><br><span class="line">    stats socket /tmp/haproxy</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    mode http</span><br><span class="line">    option abortonclose</span><br><span class="line">    compression algo gzip</span><br><span class="line">    compression type text/html text/plain application/json</span><br><span class="line">    timeout connect 5000ms</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">    bind *:8888</span><br><span class="line">    mode http</span><br><span class="line">    log 127.0.0.1 local3 err</span><br><span class="line">    stats refresh 60s</span><br><span class="line">    stats uri /stats</span><br><span class="line">    stats realm Haproxy\ Manager</span><br><span class="line">    stats auth admin:password</span><br><span class="line">    stats hide-version</span><br><span class="line">    stats admin if TRUE</span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">    bind *:5672</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcpka</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server rabbit1 192.168.0.231:5672 check inter 1000 rise 2 fall 3 weight 1</span><br><span class="line">    server rabbit2 192.168.0.232:5672 check inter 1000 rise 2 fall 3 weight 1</span><br><span class="line">    server rabbit3 192.168.0.233:5672 check inter 1000 rise 2 fall 3 weight 1</span><br></pre></td></tr></table></figure><h2 id="验证-haproxy-配置">验证 HAProxy 配置</h2><p>修改配置后，在启动 HAProxy 前，应先运行以下命令验证配置文件语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">haproxy -f /etc/haproxy/haproxy.cfg -c -V</span></span><br><span class="line">Configuration file is valid</span><br></pre></td></tr></table></figure><p>如果收到错误消，请务必先修复，然后再继续。</p><h2 id="运行-haproxy">运行 HAProxy</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl restart haproxy</span></span><br></pre></td></tr></table></figure><p>查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status haproxy</span></span><br></pre></td></tr></table></figure><h2 id="haproxy-statistics">HAProxy Statistics</h2><p>浏览器访问 http://192.168.0.235:8888/stats，输入配置中的用户名和密码登录：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/610268fb2fd2c6b3c7e5d46182643a3a.png" alt="haproxy-statistics" /></p><h1 id="references">References</h1><p><a href="https://www.rabbitmq.com/clustering.html">https://www.rabbitmq.com/clustering.html</a></p><p><a href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html</a></p><p><a href="https://www.rabbitmq.com/parameters.html#policies">https://www.rabbitmq.com/parameters.html#policies</a></p><p><a href="http://www.haproxy.org/">http://www.haproxy.org/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ + HAProxy 高可用镜像模式集群部署&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么搭建 RabbitMQ 集群？&lt;/li&gt;
&lt;li&gt;RabbitMQ 集群模式有哪些？&lt;/li&gt;
&lt;li&gt;如何搭建 RabbitMQ 集群？&lt;/li&gt;
&lt;li&gt;RabbitMQ 镜像模式的策略如何配置？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="web" scheme="https://wylu.me/categories/web/"/>
    
    <category term="mq" scheme="https://wylu.me/categories/web/mq/"/>
    
    
    <category term="rabbitmq" scheme="https://wylu.me/tags/rabbitmq/"/>
    
    <category term="haproxy" scheme="https://wylu.me/tags/haproxy/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析</title>
    <link href="https://wylu.me/posts/3274548c/"/>
    <id>https://wylu.me/posts/3274548c/</id>
    <published>2020-05-17T10:18:26.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<ul><li>算法的特性</li><li>时间复杂度</li><li>递归</li><li>分治法</li><li>动态规划</li><li>贪心算法</li><li>哈夫曼编码</li><li>单源最短路径</li><li>最小生成树</li><li>并查集</li><li>优先队列</li><li>回溯法</li></ul><span id="more"></span><h1 id="算法的特性">算法的特性</h1><h2 id="定义">定义</h2><p>为了解决某类问题而规定的一个有限长的操作序列。</p><h2 id="算法的特性-1">算法的特性</h2><p>有穷性，确定性，可行性，输入，输出</p><h2 id="算法的性能标准">算法的性能标准</h2><p>正确性、可读性、健壮性、高效率和低存储需求</p><h1 id="时间复杂度">时间复杂度</h1><h2 id="常见算法时间复杂度">常见算法时间复杂度</h2><ul><li><span class="math inline">\(O(1)\)</span>: 表示算法的运行时间为常量</li><li><span class="math inline">\(O(n)\)</span>: 表示该算法是线性算法</li><li><span class="math inline">\(O(logn)\)</span>: 二分查找算法</li><li><span class="math inline">\(O(n^2)\)</span>: 对数组进行排序的简单算法，如直接插入排序。</li><li><span class="math inline">\(O(n^3)\)</span>: 做两个n阶矩阵的乘法运算</li><li><span class="math inline">\(O(2^n)\)</span>: 求具有n个元素集合的所有子集的算法</li><li><span class="math inline">\(O(n!)\)</span>: 求具有n个元素的全排列的算法</li></ul><h2 id="算法复杂性分析">算法复杂性分析</h2><p><span class="math display">\[f(n)=O(g(n)) \qquad f(n)的阶≤g(n)的阶\\f(n)=Ω(g(n)) \qquad f(n)的阶≥g(n)的阶\\f(n)=θ(g(n)) \qquad f(n)的阶＝g(n)的阶\\f(n)=o(g(n)) \qquad f(n)的阶＜g(n)的阶\\\]</span></p><h1 id="递归">递归</h1><h2 id="二分查找递归">二分查找（递归）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; target) <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">binary_search</span>(a, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找非递归">二分查找（非递归）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><ul><li>选择划分基准 a(p)</li><li>将数组 a 划分成两个子数组，使得 <code>a[l...p-1] &lt;= a(p)</code>，<code>a[p+1...r] &gt;= a(p)</code></li><li>递归调用快速排序算法，对 <code>a[l...p-1]</code> 和 <code>a[p+1...r]</code> 进行排序</li></ul><h3 id="递归-1">递归</h3><p>C参考实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right, base = a[left], tmp;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt;= base &amp;&amp; i &lt; j) j--;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= base &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) tmp = a[i], a[i] = a[j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[i], a[i] = base;</span><br><span class="line">    quickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java参考实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            sort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            sort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: arr) System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归">非递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[right]) swap(arr, i, ++j);</span><br><span class="line">        swap(arr, right, ++j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(left);</span><br><span class="line">        stack.push(right);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr, begin, end);</span><br><span class="line">                stack.push(begin);</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">                stack.push(end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e: arr) System.out.print(e + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分治法">分治法</h1><h2 id="基本思想">基本思想</h2><p>将求解的较大规模的问题分割成 k 个更小规模的子问题。对这 k 个子问题分别求解。如果子问题的规模仍然不够小，则再划分为 k 个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。</p><h2 id="适用条件">适用条件</h2><p>分治法所能解决的问题一般具有以下几个特征：</p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决；</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li><li>利用该问题分解出的子问题的解可以合并为该问题的解；</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ul><h2 id="归并排序">归并排序</h2><p>其基本思想是：将待排序元素分成大小大致相同的 2 个子集合，分别对 2 个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> mid, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = x, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= y) tmp[t++] = a[i] &lt;= a[j] ? a[i++] : a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= y) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= y) a[x++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (x + y) / <span class="number">2</span>;</span><br><span class="line">        sort(a, x, mid, tmp);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, y, tmp);</span><br><span class="line">        merge(a, x, mid, y, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆序对数">求逆序对数</h2><p>考虑 <span class="math inline">\(1,2,…,n\)</span> 的排列 <span class="math inline">\(i1，i2，…，in\)</span>，如果其中存在 <span class="math inline">\(j,k\)</span>，满足 <span class="math inline">\(j &lt; k\)</span> 且 <span class="math inline">\(i_j &gt; i_k\)</span>， 那么就称 <span class="math inline">\((i_j,i_k)\)</span> 是这个排列的一个逆序。</p><p>一个排列含有逆序的个数称为这个排列的逆序数。例如排列 263451 含有8个逆序 (2,1),(6,3),(6,4),(6,5),(6,1),(3,1),(4,1),(5,1)，因此该排列的逆序数就是 8。显然，由 1,2,…,n 构成的所有 n! 个排列中，最小的逆序数是 0，对应的排列就是 1,2,…,n；最大的逆序数是 n(n-1)/2，对应的排列就是 n,(n-1),…,2,1。逆序数越大的排列与原始排列的差异度就越大。</p><p>基本思路：</p><p>1.使用二分归并（分治法）进行求解； 2.将序列依此划分为两两相等的子序列； 3.对每个子序列进行排序（比较 <code>a[i] &gt; a[j]</code>，如果满足条件，则求该子序列的逆序数 <code>count = mid - i + 1</code>，其中 <code>mid = (left + right) / 2</code>） 4.接着合并子序列即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[t++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[t++] = a[j++];</span><br><span class="line">            count += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) tmp[t++] = a[j++];</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) a[left++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, left, mid, tmp);</span><br><span class="line">        mergeSort(a, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">        merge(a, left, mid, right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择算法">快速选择算法</h2><p>基本思想：</p><p>快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(nlogn)\)</span> 至 <span class="math inline">\(O(n)\)</span>，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;  <span class="comment">// 选择a[right]作为划分基准</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quick_select</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> a[left];</span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> quick_select(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_select(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性时间选择bfprt">线性时间选择（BFPRT）</h2><p>基本思路：</p><ul><li>首先把数组按 5 个数为一组进行分组，最后不足 5 个的忽略。对每组数进行排序（如插入排序）求取其中位数。</li><li>把上一步的所有中位数移到数组的前面，对这些中位数递归调用 BFPRT 算法求得他们的中位数。</li><li>将上一步得到的中位数作为划分的主元进行整个数组的划分。</li><li>判断第k个数在划分结果的左边、右边还是恰好是划分结果本身，前两者递归处理，后者直接返回答案。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = right; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) tmp = a[j], a[j] = a[j<span class="number">-1</span>], a[j<span class="number">-1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> baseIdx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = left - <span class="number">1</span>, tmp;</span><br><span class="line">    <span class="comment">// 将基准放于数组尾部</span></span><br><span class="line">    tmp = a[right], a[right] = a[baseIdx], a[baseIdx] = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[right]) tmp = a[i], a[i] = a[++j], a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a[right], a[right] = a[++j], a[j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfprt</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt;= <span class="number">5</span>)&#123;  <span class="comment">// 小于等于5个数，直接排序得到结果</span></span><br><span class="line">        bubble_sort(a, left, right);</span><br><span class="line">        <span class="keyword">return</span> a[left + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = left - <span class="number">1</span>, tmp;  <span class="comment">// t:当前替换到前面的中位数的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st = left, ed; (ed = st + <span class="number">4</span>) &lt;= right; st += <span class="number">5</span>)&#123;</span><br><span class="line">        bubble_sort(a, st, ed);</span><br><span class="line">        <span class="comment">// 将中位数替换到数组前面，便于递归求取中位数的中位数</span></span><br><span class="line">        tmp = a[++t], a[t] = a[st+<span class="number">2</span>], a[st+<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> baseIdx = (left + t) &gt;&gt; <span class="number">1</span>; <span class="comment">// left到t的中位数的下标，作为主元的下标</span></span><br><span class="line">    bfprt(a, left, t, baseIdx - left + <span class="number">1</span>); <span class="comment">// 不关心中位数的值，保证中位数在正确的位置</span></span><br><span class="line">    <span class="type">int</span> idx = partition(a, left, right, baseIdx), cur = idx - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == cur) <span class="keyword">return</span> a[idx];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; cur) <span class="keyword">return</span> bfprt(a, left, idx - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> bfprt(a, idx + <span class="number">1</span>, right, k - cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><h2 id="基本步骤">基本步骤</h2><ul><li>找出最优解的性质，并刻划其结构特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解。</li></ul><h2 id="矩阵连乘">矩阵连乘</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">matrixChain</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span>[][] m, <span class="type">int</span>[][] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + r - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最优子结构">最优子结构</h2><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p><p>例如，矩阵连乘计算次序问题的最优解包含着其子问题的最优解，这种性质称为最优子结构性质。</p><p><strong>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</strong></p><h2 id="重叠子问题">重叠子问题</h2><p>在递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。</p><p>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</p><h2 id="lis最长单调递增子序列">LIS最长单调递增子序列</h2><p>设序列为 a[0:n-1]，记 b[i]：以 a[i] 为结尾元素的最长递增子序列的长度。</p><p>则序列 a 的最长递增子序列长度为：<code>max&#123;b[i]&#125;, 0&lt;=i&lt;n</code></p><p>如何求 b[i] ?</p><p><code>b[0] = 1</code>，<code>b[i] = max&#123;b[k]&#125; + 1, (0&lt;=k&lt;i, a[k]&lt;=a[i])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">LIS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, b[<span class="number">0</span>] = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt;= a[i] &amp;&amp; k &lt; b[j]) k = b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] = k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lcs最长公共子序列">LCS最长公共子序列</h2><p>给定 2 个序列，<span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span>，找出 X 和 Y 的最长公共子序列。</p><p>设序列 <span class="math inline">\(X={x_1,x_2,…,x_m}\)</span> 和 <span class="math inline">\(Y={y_1,y_2,…,y_n}\)</span> 的最长公共子序列为 <span class="math inline">\(Z={z_1,z_2,…,z_k}\)</span>，则</p><p>1)若 <span class="math inline">\(x_m=y_n\)</span>，则 <span class="math inline">\(z_k=x_m=y_n\)</span>，且 <span class="math inline">\(Z_{k-1}\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列。</p><p>2)若 <span class="math inline">\(x_m≠y_n\)</span>，则 <span class="math inline">\(Z\)</span> 是 <span class="math inline">\(X_{m-1}\)</span> 和 <span class="math inline">\(Y\)</span> 的最长公共子序列，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y_{n-1}\)</span> 的最长公共子序列，中较长的序列。</p><p><strong>2 个序列的最长公共子序列包含了这 2 个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。</strong></p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用 <span class="math inline">\(c[i][j]\)</span> 记录序列的最长公共子序列的长度。其中，<span class="math inline">\(X_i={x_1,x_2,…,x_i}\)</span>；<span class="math inline">\(Y_j={y_1,y_2,…,y_j}\)</span>。当 <span class="math inline">\(i=0\)</span> 或 <span class="math inline">\(j=0\)</span> 时，空序列是 <span class="math inline">\(X_i\)</span> 和 <span class="math inline">\(Y_j\)</span> 的最长公共子序列。故此时 <span class="math inline">\(c[i][j]=0\)</span>。其他情况下，由最优子结构性质可建立递归关系如下：</p><ul><li><code>i=0,j=0</code>：<code>c[i][j]=0</code></li><li><code>i,j&gt;0; x[i]==y[i]</code>：<code>c[i][j]=c[i-1][j-1]+1</code></li><li><code>i,j&gt;0; x[i]!=y[i]</code>：<code>c[i][j]=max&#123;c[i][j-1],c[i-1][j]&#125;</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(b); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Algorithm <span class="title">lcsLength</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">    m = x.length - <span class="number">1</span>;</span><br><span class="line">    n = y.length - <span class="number">1</span>;</span><br><span class="line">    c[i][<span class="number">0</span>] = <span class="number">0</span>; c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Algorithm <span class="title">lcs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> [] x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == y[i])&#123;</span><br><span class="line">        <span class="built_in">lcs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, x);</span><br><span class="line">        <span class="built_in">print</span>(x[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]) <span class="built_in">lcs</span>(i<span class="number">-1</span>, j, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">lcs</span>(i, j<span class="number">-1</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治法与动态规划的区别">分治法与动态规划的区别</h2><ul><li>分治法与动态规划有何共同点？提示：从所适用问题的特点，解决问题的方式上阐述<ul><li>两者所解决的问题，都能划分为若干个规模较小的子问题</li><li>这些子问题具有最优子结构性质</li><li>能通过子问题的最优解自底向上地得到问题的最优解</li></ul></li><li>分治法与动态规划又有何不同？提示：从子问题的角度阐述<ul><li>分治法适用于子问题相互独立的情况，即子问题之间不存在公共子问题</li><li>动态规划适用于子问题存在重叠的情况，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果</li></ul></li></ul><h1 id="贪心算法">贪心算法</h1><h2 id="基本思想-1">基本思想</h2><p>贪心算法总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p><h2 id="活动安排问题">活动安排问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列</span></span><br><span class="line"><span class="comment"> * a数组记录是否安排相应活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">greedySelector</span><span class="params">(<span class="type">int</span> [] s, <span class="type">int</span> [] f, <span class="type">boolean</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">            a[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> a[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最优子结构性质">最优子结构性质</h2><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p><h2 id="贪心选择性质">贪心选择性质</h2><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择。然后再去解做出这个选择后产生的相应的子问题。</p><p><strong>贪心算法和动态规划算法都要求问题具有最优子结构性质，这是两类算法的一个共同点。</strong></p><p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。（即证明有解必有贪心解）</p><h2 id="贪心算法求解背包问题">贪心算法求解背包问题</h2><p>基本步骤：</p><ul><li>首先计算每种物品单位重量的价值 <span class="math inline">\(V_i/W_i\)</span></li><li>然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包</li><li>若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。</li><li>依此策略一直地进行下去，直到背包装满为止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">float</span>[] v,<span class="type">float</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], v[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i].w &gt; c) <span class="keyword">break</span>;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].v;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)&#123;</span><br><span class="line">        x[d[i].i] = c / d[i].w;</span><br><span class="line">        opt += x[d[i].i] * d[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 0-1 背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。</p><p>事实上，在考虑 0-1 背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。</p><h2 id="最优装载问题">最优装载问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">loading</span><span class="params">(<span class="type">float</span> c, <span class="type">float</span>[] w, <span class="type">int</span>[] x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">    Element [] d = <span class="keyword">new</span> <span class="title class_">Element</span> [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) d[i] = <span class="keyword">new</span> <span class="title class_">Element</span>(w[i], i);</span><br><span class="line">    MergeSort.mergeSort(d);</span><br><span class="line">    <span class="type">float</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; d[i].w &lt;= c; i++) &#123;</span><br><span class="line">        x[d[i].i] = <span class="number">1</span>;</span><br><span class="line">        opt += d[i].w;</span><br><span class="line">        c -= d[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼编码">哈夫曼编码</h1><h2 id="应用">应用</h2><p>哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p><h2 id="构造哈夫曼编码">构造哈夫曼编码</h2><ul><li>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树 T。</li><li>算法以 C 个叶结点开始，执行 C-1 次的“合并”运算后产生最终所要求的树 T。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/891129703366840b1bac668d27b5cd11.png" alt="huffman-1" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/af9941f332989278833bd160b2a58181.png" alt="huffman-2" /></p><h1 id="单源最短路径">单源最短路径</h1><h2 id="单源最短路问题">单源最短路问题</h2><p>给定带权有向图 G=(V,E)，其中每条边的权是非负实数。另外，还给定 V 中的一个顶点，称为源。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。</p><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>Dijkstra 算法是解单源最短路径问题的贪心算法。其基本思想是，设置顶点集合 S 并不断地作贪心选择来扩充这个集合。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。</p><p>基本步骤：</p><ul><li>初始时，S 中仅含有源。</li><li>设 u 是 G 的某一个顶点，把从源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路径，并用数组 dist 记录当前每个顶点所对应的最短特殊路径长度。</li><li>Dijkstra 算法每次从 V-S 中取出具有最短特殊路长度的顶点 u，将 u 添加到 S 中，同时对数组 dist 作必要的修改。</li><li>一旦 S 包含了所有 V 中顶点，dist 就记录了从源到所有其他顶点之间的最短路径长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> dist[MAX_V];  <span class="comment">// 顶点s出发的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 已经使用过的图</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求从起点s出发到各个顶点的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + V, INF);</span><br><span class="line">    <span class="built_in">fill</span>(used, used + V, <span class="literal">false</span>);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从尚未使用过的顶点中选择一个距离最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || dist[u] &lt; dist[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            dist[u] = <span class="built_in">min</span>(dist[u], dist[v] + cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树">最小生成树</h1><h2 id="定义-1">定义</h2><p>设 <span class="math inline">\(G =(V,E)\)</span> 是无向连通带权图，即一个网络。<span class="math inline">\(E\)</span> 中每条边 <span class="math inline">\((v,w)\)</span> 的权为 <span class="math inline">\(c[v][w]\)</span>。如果 <span class="math inline">\(G\)</span> 的子图 <span class="math inline">\(G’\)</span> 是一棵包含 <span class="math inline">\(G\)</span> 的所有顶点的树，则称 <span class="math inline">\(G’\)</span> 为 <span class="math inline">\(G\)</span> 的生成树。生成树上各边权的总和称为该生成树的耗费。在 <span class="math inline">\(G\)</span> 的所有生成树中，耗费最小的生成树称为 <span class="math inline">\(G\)</span> 的最小生成树。</p><h2 id="最小生成树性质">最小生成树性质</h2><p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的真子集。如果 <span class="math inline">\((u,v) \in E\)</span>，且 <span class="math inline">\(u \in U\)</span>，<span class="math inline">\(v \in V-U\)</span>，且在所有这样的边中，<span class="math inline">\((u,v)\)</span> 的权 <span class="math inline">\(c[u][v]\)</span> 最小，那么一定存在 <span class="math inline">\(G\)</span> 的一棵最小生成树，它以 <span class="math inline">\((u,v)\)</span> 为其中一条边。这个性质有时也称为 MST 性质。</p><h2 id="prim算法">Prim算法</h2><p>设 <span class="math inline">\(G=(V,E)\)</span> 是连通带权图，<span class="math inline">\(V={1,2,…,n}\)</span>。构造 <span class="math inline">\(G\)</span> 的最小生成树的 Prim 算法的基本思想是：</p><ul><li>首先置 <span class="math inline">\(S=\{1\}\)</span>，</li><li>然后，只要 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(V\)</span> 的真子集，就作如下的贪心选择</li><li>选取满足条件 <span class="math inline">\(i \in S\)</span>，<span class="math inline">\(j \in V-S\)</span>，且 <span class="math inline">\(c[i][j]\)</span> 最小的边，将顶点j添加到 <span class="math inline">\(S\)</span> 中。</li><li>这个过程一直进行到 <span class="math inline">\(S=V\)</span> 时为止。在这个过程中选取到的所有边恰好构成 G 的一棵最小生成树。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V];  <span class="comment">// cost[u][v]表示边e=(u,v)的权值（不存在这条边时设为INF）</span></span><br><span class="line"><span class="type">int</span> mistcost[MAX_V];  <span class="comment">// 从集合X出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];  <span class="comment">// 顶点i是否包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从不属于X的顶点中选取从X到其权值最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;  <span class="comment">// 把顶点v加入X</span></span><br><span class="line">        res += mincost[v];  <span class="comment">// 把边的长度加到结果里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line">            mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal-算法">Kruskal 算法</h2><p>Kruskal 算法构造 <span class="math inline">\(G\)</span> 的最小生成树的基本思想是：</p><ul><li>首先将 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(n\)</span> 个顶点看成 <span class="math inline">\(n\)</span> 个孤立的连通分支。</li><li>将所有的边按权从小到大排序。</li><li>然后从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接 2 个不同的连通分支</li><li>当查看到第 <span class="math inline">\(k\)</span> 条边 <span class="math inline">\((v,w)\)</span> 时，如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 分别是当前 2 个不同的连通分支 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 中的顶点时，就用边 <span class="math inline">\((v,w)\)</span> 将 <span class="math inline">\(T1\)</span> 和 <span class="math inline">\(T2\)</span> 连接成一个连通分支，然后继续查看第 <span class="math inline">\(k+1\)</span> 条边；</li><li>如果端点 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 在当前的同一个连通分支中，就直接再查看第 <span class="math inline">\(k+1\)</span> 条边。</li><li>这个过程一直进行到只剩下一个连通分支时为止。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge &amp;e1, <span class="type">const</span> edge &amp;e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V, E;  <span class="comment">// 顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">krustral</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(es, es + E, comp);  <span class="comment">// 按照edge.cost的顺序从小到大排列</span></span><br><span class="line">    <span class="built_in">init_union_find</span>(V);  <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">        edge e = es[i];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">same</span>(e.u, e.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集">并查集</h1><h2 id="主要操作">主要操作</h2><ul><li>初始化 集合中每个元素单独作为一个子集。</li><li>查找 查找元素 x 所在的子集序号。常用来判断元素 x 和 y 是否在同一子集中。</li><li>合并 将元素 x 和 y 分别所在的子集合并为一个子集。</li></ul><h2 id="算法实现">算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用编号代表每个元素，数组par表示父亲的编号，当par[x]=x时，x是所在树的树根</span></span><br><span class="line"><span class="type">int</span> par[MAX_N];  <span class="comment">// 父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N];  <span class="comment">// 树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列">优先队列</h1><h2 id="主要操作-1">主要操作</h2><ul><li>初始化 将给定多个元素初始化为优先队列。</li><li>出队 将优先权最大的元素x出队，并调整结构为优先队列。</li><li>入队 加入元素x，并调整结构为优先队列。</li></ul><h2 id="算法实现-1">算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点从0开始编号</span></span><br><span class="line"><span class="type">int</span> heap[MAX_N], sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己节点的编号</span></span><br><span class="line">    <span class="type">int</span> i = sz++;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父亲节点的编号</span></span><br><span class="line">        <span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把父亲节点的数组放下来，而把自己提上去</span></span><br><span class="line">        heap[i] = heap[p];</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    <span class="type">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 要提到根的数值</span></span><br><span class="line">    <span class="type">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">// 从根开始向下交换</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">// 比较儿子的值</span></span><br><span class="line">        <span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;</span><br><span class="line">        <span class="comment">// 如果已经没有大小颠倒则退出</span></span><br><span class="line">        <span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把儿子的数值提上来</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i = a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法">回溯法</h1><h2 id="定义-2">定义</h2><p>为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法。</p><h2 id="基本思想-2">基本思想</h2><ul><li>针对所给问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构；</li><li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li></ul><p><strong>常用剪枝函数：用约束函数在扩展结点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。</strong> 这种方法适用于解一些组合数相当大的问题。</p><h2 id="回溯法的特征">回溯法的特征</h2><p>用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为 <span class="math inline">\(h(n)\)</span>，则回溯法所需的计算空间通常为 <span class="math inline">\(O(h(n))\)</span>。</p><h2 id="递归回溯">递归回溯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">            x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代回溯">迭代回溯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterativeBacktrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(n,t) &lt;= <span class="built_in">g</span>(n,t))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">f</span>(n,t); i &lt;= <span class="built_in">g</span>(n,t); i++) &#123;</span><br><span class="line">                x[t] = <span class="built_in">h</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">constraint</span>(t) &amp;&amp; <span class="built_in">bound</span>(t)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">solution</span>(t)) <span class="built_in">output</span>(x);</span><br><span class="line">                    <span class="keyword">else</span> t++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s的所有元素个数小于4的子集">求S的所有元素个数小于4的子集</h2><p>已知集合 <span class="math inline">\(S=\{a,b,c,d,e,f,g\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素个数小于 4 的子集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;a,b,c,d,e,f,g&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(x, t) &lt; <span class="number">4</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s的所有元素和小于8的子集">求S的所有元素和小于8的子集</h2><p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有元素和小于 8 的子集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sum</span>(x, t) &lt; <span class="number">8</span>) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s满足元素奇偶性相同且和小于8的子集">求S满足元素奇偶性相同且和小于8的子集</h2><p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 <span class="math inline">\(S\)</span> 的所有满足下列条件的子集：元素奇偶性相同，且和小于 8。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_subset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t, <span class="type">int</span> sum, <span class="type">int</span> prior)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x[t] = <span class="number">0</span>, <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, prior);</span><br><span class="line">        x[t] = <span class="number">1</span>;</span><br><span class="line">        sum += s[t];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">8</span> &amp;&amp; (prior == <span class="number">-1</span> || (s[t] - s[prior]) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>, sum, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s的所有排列">求S的所有排列</h2><p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7\}\)</span>，请编程输出 S 的所有排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s的所有满足奇偶数相间出现的排列">求S的所有满足奇偶数相间出现的排列</h2><p>已知集合 <span class="math inline">\(S=\{1,2,3,4,5,6,7,8\}\)</span>，请编程输出 S 的所有满足下列条件的排列：奇偶数相间出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">char</span> s[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">all_permutation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">output</span>(s);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(s[t], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>) bRet &amp;&amp;= ((s[t - <span class="number">1</span>] - s[t]) % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题">0-1 背包问题</h2><p>重量 <span class="math inline">\(w=\{2,2,3,4,5,5,6\}\)</span>， 价值 <span class="math inline">\(v=\{3,4,3,4,5,8,7\}\)</span>，<span class="math inline">\(C=16\)</span>，求背包的最大价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> n 7</span></span><br><span class="line"><span class="type">int</span> C = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> w[n] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> v[n] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[n+<span class="number">1</span>], Max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span>* x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) <span class="built_in">process</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">legal</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        sum += x[i] * w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += x[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Max &lt; sum) Max = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装载问题">装载问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="comment">// 搜索第i层结点</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) &#123;  <span class="comment">//到达叶结点更新最优解bestx</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r -= w[i];</span><br><span class="line">    <span class="keyword">if</span> (cw + w[i] &lt;= c) &#123;  <span class="comment">// 搜索左子树</span></span><br><span class="line">        x[i] = <span class="number">1</span>;</span><br><span class="line">        cw += w[i];</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cw + r &gt; bestw)  &#123;  <span class="comment">// 搜索右子树</span></span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r += w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n皇后问题">n皇后问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">place</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(k - j) == <span class="built_in">abs</span>(x[j] - x[k])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="built_in">output</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">place</span>(t)) <span class="built_in">backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(x[t], x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;算法的特性&lt;/li&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;分治法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;li&gt;贪心算法&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;li&gt;单源最短路径&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;并查集&lt;/li&gt;
&lt;li&gt;优先队列&lt;/li&gt;
&lt;li&gt;回溯法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="cs" scheme="https://wylu.me/categories/cs/"/>
    
    <category term="data-structure" scheme="https://wylu.me/categories/cs/data-structure/"/>
    
    
    <category term="data-structure" scheme="https://wylu.me/tags/data-structure/"/>
    
    <category term="algorithm" scheme="https://wylu.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7下Firewall的设置与使用</title>
    <link href="https://wylu.me/posts/6a7a0bd6/"/>
    <id>https://wylu.me/posts/6a7a0bd6/</id>
    <published>2020-05-16T10:53:39.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>防火墙 firewalld 守护服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。</p><span id="more"></span><div class="note info"><p><strong>[译]CentOS7下Firewall的设置与使用</strong> 原文出处：<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a> 原本作者：Justin Ellingwood 译者：wylu</p></div><h1 id="如何在centos7上使用firewalld设置防火墙">如何在CentOS7上使用FirewallD设置防火墙</h1><h2 id="简介">简介</h2><p>Firewalld 是可用于许多 Linux 发行版的防火墙管理解决方案，它充当 Linux 内核提供的 iptables 数据包过滤系统的前端。在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用 <code>firewall-cmd</code> 管理工具管理防火墙的基本知识（如果您希望在 CentOS中 使用 <code>iptables</code>，请遵循<a href="https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7">本指南</a>）。</p><p>注意：有可能您正在使用比撰写本文时可用的新版本的 firewalld，或者您的服务器设置与本指南中使用的示例服务器略有不同。因此，本指南中说明的某些命令的行为可能会因您的特定配置而异。</p><h2 id="firewalld中的基本概念">Firewalld中的基本概念</h2><p>在开始讨论如何实际使用 <code>firewall-cmd</code> 实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。</p><h3 id="zones">Zones</h3><p><code>firewalld</code> 守护程序使用称为 "zones" 的实体管理规则组。区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。为网络接口分配了一个区域，以指示防火墙应允许的行为。</p><p>对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改（如果有的话）。</p><p>无论您的网络环境有多动态，熟悉防火墙的每个预定义区域背后的一般概念仍然很有用。按从 <strong>最不信任</strong> 到 <strong>最受信任</strong> 的顺序，<code>firewalld</code> 中的预定义区域为：</p><ul><li>drop：最低级别的信任。所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。</li><li>block：与上述类似，但不仅仅是丢弃连接，而是使用 <code>icmp-host-prohibited</code> 或 <code>icmp6-adm-prohibited</code> 消息拒绝传入的请求。</li><li>public：代表公共的，不受信任的网络。您不信任其他计算机，但可能会视情况允许选择的传入连接。</li><li>external：如果您使用防火墙作为网关，则为外部网络。将其配置为伪装NAT，以便您的内部网络保持私有但可访问。</li><li>internal：外部区域的另一侧，用于网关的内部。这些计算机相当值得信赖，并且可以使用一些其他服务。</li><li>dmz：用于DMZ中的计算机（将无法访问网络其余部分的隔离计算机）。仅允许某些传入连接。</li><li>work：用于工作机。信任网络中的大多数计算机。可能还允许其他一些服务。</li><li>home：家庭环境。通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。</li><li>trusted：信任网络中的所有计算机。可用选项中最开放的，应谨慎使用。</li></ul><p>要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口分配给最合适的区域。</p><h3 id="规则永久性">规则永久性</h3><p>在 firewalld 中，可以将规则指定为 <strong>永久规则</strong> 或 <strong>立即规则</strong>。如果添加或修改规则，则默认情况下，将修改当前运行的防火墙的行为。在下次启动时，旧规则将恢复。</p><p>大多数 <code>firewall-cmd</code> 操作都可以使用 <code>--permanent</code> 标志来指示应将非临时防火墙作为目标。这将影响在引导时重新加载的规则集。这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。您还可以使用 <code>--permanent</code> 标志随着时间的推移建立一套完整的规则，这些规则将在发出 reload 命令时立即应用。</p><h2 id="安装并启用防火墙以在启动时启动">安装并启用防火墙以在启动时启动</h2><p>默认情况下，firewalld 是在某些 Linux 发行版上安装的，包括许多 CentOS 7 映像。但是，您可能需要自己安装 firewalld：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install firewalld</span></span><br></pre></td></tr></table></figure><p>安装 firewalld 之后，您可以启用该服务并重新启动服务器。请记住，启用 firewalld 将导致该服务在服务器启动时启动。最佳实践是在配置此行为之前创建防火墙规则并借此机会对其进行测试，以避免潜在的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> firewalld</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo reboot</span></span><br></pre></td></tr></table></figure><p>服务器重新启动时，防火墙会随之启动，然后将网络接口放入配置的区域（或退回到配置的默认区域），并且与该区域关联的所有规则都将应用于关联的接口。</p><p>我们可以通过键入以下内容来验证该服务正在运行并且可以访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --state</span></span><br><span class="line">running</span><br></pre></td></tr></table></figure><p>这表明我们的防火墙已启动并以默认配置运行。</p><h2 id="熟悉当前的防火墙规则">熟悉当前的防火墙规则</h2><p>在开始进行修改之前，我们应该熟悉守护程序提供的默认环境和规则。</p><h3 id="探索默认值">探索默认值</h3><p>通过键入以下内容，可以看到当前选择哪个区域作为默认区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure><p>由于我们没有给 firewalld 提供任何偏离默认区域的命令，并且我们的接口都没有配置为绑定到另一个区域，因此该区域（public 区域）也将是唯一的“活动”（active）区域（该区域正在控制我们接口的流量）。我们可以通过输入以下内容进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">public</span><br><span class="line">  interfaces: eth0 eth1</span><br></pre></td></tr></table></figure><p>在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（ <code>eth0</code> 和 <code>eth1</code> ）。目前，它们都根据为 public 区域定义的规则进行管理。</p><p>我们如何知道与 public 区域相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --list-all</span></span><br><span class="line">public (default, active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0 eth1</span><br><span class="line">  sources:</span><br><span class="line">  services: ssh dhcpv6-client</span><br><span class="line">  ports:</span><br><span class="line">  protocols:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  source-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>从输出中可以看出，该区域既是默认区域（default zone）又是活动区域（active zone），并且 <code>eth0</code> 和 <code>eth1</code> 接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。但是，我们还可以看到，该区域允许与 DHCP 客户端（用于 IP 地址分配）和 SSH（用于远程管理）相关的正常操作。</p><h3 id="探索可选区域">探索可选区域</h3><p>现在，我们对默认区域和活动区域的配置有了一个好主意。我们还可以找到有关其他区域的信息。</p><p>要获取可用区域的列表，请输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure><p>通过在 <code>--list-all</code> 命令中指定 <code>--zone</code> 参数，可以看到与指定区域关联的特定配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=home --list-all</span></span><br><span class="line">home</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: dhcpv6-client ipp-client mdns samba-client ssh</span><br><span class="line">  ports:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>您可以使用 <code>--list-all-zones</code> 选项输出所有区域定义。您可能希望将输出通过管道传到 pager 中以便于查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --list-all-zones | less</span></span><br></pre></td></tr></table></figure><h2 id="为接口选定区域">为接口选定区域</h2><p>除非另外配置了网络接口，否则在启动防火墙时，每个接口都将置于默认区域中。</p><h3 id="更改接口区域">更改接口区域</h3><p>通过将 <code>--zone</code> 参数与 <code>--change-interface</code> 参数结合使用，可以在会话期间在区域之间转换接口。与所有修改防火墙的命令一样，您将需要使用 sudo。</p><p>例如，我们可以通过输入以下命令将 eth0 接口转换为 "home" 区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=home --change-interface=eth0</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>注意：每当将接口转换到新区域时，请注意您可能正在修改将要运行的服务。例如，在这里，我们将移至具有 SSH 可用的 "home" 区域。这意味着我们的连接不应断开。其他一些区域默认情况下未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。</p><p>我们可以通过再次请求活动区域来验证此操作是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">home</span><br><span class="line">  interfaces: eth0</span><br><span class="line">public</span><br><span class="line">  interfaces: eth1</span><br></pre></td></tr></table></figure><h3 id="调整默认区域">调整默认区域</h3><p>您最好用一个区域来处理所有接口，这样选择最佳的默认区域然后将其用于配置可能会更容易。</p><p>您可以使用 <code>--set-default-zone</code> 参数更改默认区域。这将立即将所有使用默认值的接口更改为新区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --set-default-zone=home</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="为您的应用程序设置规则">为您的应用程序设置规则</h2><p>为希望提供的服务定义防火墙例外的基本方法很容易。我们将在此处介绍基本概念。</p><h3 id="将服务添加到您的区域">将服务添加到您的区域</h3><p>最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用 <code>--get-services</code> 选项获取可用服务的列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-services</span></span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>注意：您可以通过查看 <code>/usr/lib/firewalld/services</code> 目录中与它们相关的 <code>.xml</code> 文件来获得有关每个服务的更多详细信息。例如，SSH 服务（/usr/lib/firewalld/services/ssh.xml）的定义如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>您可以使用 <code>--add-service</code> 参数为区域启用服务。该操作将针对默认区域或 <code>--zone</code> 参数指定的任何区域。默认情况下，这只会调整当前的防火墙会话。您可以通过包括 <code>--permanent</code> 标志来调整永久防火墙配置。</p><p>例如，如果我们运行的是提供常规 HTTP 流量的 Web 服务器，则可以通过键入以下内容在此会话的 "public" 区域中为接口允许此流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-service=http</span></span><br></pre></td></tr></table></figure><p>如果要修改默认区域，可以省略 <code>--zone</code>。我们可以使用 <code>--list-all</code> 或 <code>--list-services</code> 操作来验证操作是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --list-services</span></span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure><p>测试完所有功能后，您可能需要修改永久防火墙规则，以便重新启动后您的服务仍然可用。我们可以通过输入以下内容使 "public" 区域更改永久生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-service=http</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>您可以通过在 <code>--list-services</code> 操作中添加 <code>--permanent</code> 标志来验证此操作是否成功。您需要对任何 <code>--permanent</code> 操作使用sudo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --list-services</span></span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure><p>您的 "public" 区域现在将允许端口 80 上的 HTTP Web 通信。如果您的 Web 服务器配置为使用 SSL/TLS，则还需要添加 https 服务。我们可以通过输入以下内容将其添加到当前会话和永久规则集中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-service=https</span></span><br></pre></td></tr></table></figure><h3 id="如果没有适当的服务可用怎么办">如果没有适当的服务可用怎么办</h3><p>防火墙安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见要求。但是，在某些情况下，这些服务可能无法满足您的要求。</p><p>在这种情况下，您有两个选择。</p><h4 id="为您的区域打开端口">为您的区域打开端口</h4><p>为您的特定应用程序添加支持的最简单方法是打开它在相应区域中使用的端口。这就像指定端口或端口范围以及需要打开的端口的关联协议一样容易。</p><p>例如，如果我们的应用程序在端口 5000 上运行并使用 TCP，则可以使用 <code>--add-port</code> 参数将其添加到此会话的 "public" 区域中。协议可以是 tcp 或 udp：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-port=5000/tcp</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>--list-ports</code> 操作验证此操作是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --list-ports</span></span><br><span class="line">5000/tcp</span><br></pre></td></tr></table></figure><p>也可以通过用 <code>-</code> 分隔范围内的开始和结束端口来指定顺序的端口范围。例如，如果我们的应用程序使用 UDP 端口 4990 至 4999，则可以通过键入以下内容在 "public" 端口上打开这些端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --add-port=4990-4999/udp</span></span><br></pre></td></tr></table></figure><p>经过测试后，我们可能希望将它们添加到永久防火墙中。您可以通过键入以下内容进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-port=5000/tcp</span></span><br><span class="line">success</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --add-port=4990-4999/udp</span></span><br><span class="line">success</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=public --permanent --list-ports</span></span><br><span class="line">5000/tcp 4990-4999/udp</span><br></pre></td></tr></table></figure><h4 id="定义服务">定义服务</h4><p>为您的区域打开端口很容易，但是很难跟踪每个区域的用途。如果您曾经停用服务器上的服务，则可能很难记住仍需要打开哪些端口。为了避免这种情况，可以定义服务。</p><p>服务只是带有相关名称和描述的端口的简单集合。使用服务比端口更易于管理，但是需要一些前期工作。最简单的开始方法是将现有脚本（在 /usr/lib/firewalld/services 中找到）复制到 /etc/firewalld/services 目录中，防火墙在该目录中查找非标准定义。</p><p>例如，我们可以复制 SSH 服务定义以用于我们的 "example" 服务定义，如下所示。文件名减去 <code>.xml</code> 后缀将指示防火墙服务列表中的服务名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/example.xml</span></span><br></pre></td></tr></table></figure><p>现在，您可以调整在复制的文件中找到的定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vi /etc/firewalld/services/example.xml</span></span><br></pre></td></tr></table></figure><p>首先，文件将包含您复制的 SSH 定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该定义的大部分实际上是元数据。您将要在 <code>&lt;short&gt;</code> 标记内更改服务的简称。这是您的服务的易读名称。您还应该添加描述，以便在需要审核服务时获得更多信息。您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。可以多次指定。</p><p>对于我们的 "example" 服务，假设我们需要为 TCP 打开端口 7777，为 UDP 打开端口 8888。通过按 <code>i</code> 进入 INSERT 模式，我们可以使用以下内容修改现有定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>Example Service<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is just an example service.  It probably shouldn&#x27;t be used on a real system.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;udp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按 ESC，然后输入 <code>:x</code> 保存并关闭文件。</p><p>重新加载防火墙以访问新服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --reload</span></span><br></pre></td></tr></table></figure><p>您可以看到它现在在可用服务列表中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-services</span></span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>现在，您可以像往常一样在您的区域中使用此服务。</p><h2 id="创建自己的区域">创建自己的区域</h2><p>尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。</p><p>例如，您可能要为 Web 服务器创建一个名为 "publicweb" 的区域。或者，您可能希望为您在专用网络上提供的 DNS 服务配置另一个区域，您可能需要一个名为 "privateDNS" 的区域。</p><p>添加区域时，必须将其添加到永久防火墙配置中。然后，您可以重新加载以将配置带入正在运行的会话。例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --new-zone=publicweb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --new-zone=privateDNS</span></span><br></pre></td></tr></table></figure><p>您可以通过键入以下内容来验证这些内容是否存在于您的永久配置中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --permanent --get-zones</span></span><br><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure><p>如前所述，这些功能在当前的防火墙实例中尚不可用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure><p>重新加载防火墙以使这些新区域进入活动配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-zones</span></span><br><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure><p>现在，您可以开始为您的区域分配适当的服务和端口。通常，最好先调整活动实例，然后在测试后将这些更改转移到永久配置中。例如，对于 "publicweb" 区域，您可能想要添加 SSH，HTTP 和 HTTPS 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=http</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --list-all</span></span><br><span class="line">publicweb</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: ssh http https</span><br><span class="line">  ports:</span><br><span class="line">  protocols:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  source-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>同样地，我们可以将 DNS 服务添加到我们的 "privateDNS" 区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --add-service=dns</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --list-all</span></span><br><span class="line">privateDNS</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: dns</span><br><span class="line">  ports:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>然后，我们可以将网络接口更改为这些新区域以对其进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --change-interface=eth0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --change-interface=eth1</span></span><br></pre></td></tr></table></figure><p>此时，您将有机会测试您的配置。如果这些值对您有用，您将要向永久配置添加相同的规则。您可以通过使用 <code>--permanent</code> 标志重新应用规则来做到这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=http</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --permanent --add-service=https</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --permanent --add-service=dns</span></span><br></pre></td></tr></table></figure><p>在永久应用了这些规则之后，您可以重新启动网络并重新加载防火墙服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart network</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl reload firewalld</span></span><br></pre></td></tr></table></figure><p>验证是否分配了正确的区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">privateDNS</span><br><span class="line">  interfaces: eth1</span><br><span class="line">publicweb</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure><p>并验证相应的服务可用于两个区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=publicweb --list-services</span></span><br><span class="line">http https ssh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --zone=privateDNS --list-services</span></span><br><span class="line">dns</span><br></pre></td></tr></table></figure><p>您已经成功设置了自己的区域！ 如果要将这些区域之一设为其他接口的默认区域，请记住使用 <code>--set-default-zone</code> 参数配置该行为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo firewall-cmd --set-default-zone=publicweb</span></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>您现在应该对如何在 CentOS 系统上日常使用的防火墙服务进行充分的了解。</p><p>Firewalld 服务允许您配置考虑网络环境的可维护规则和规则集。它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;防火墙 firewalld 守护服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="https://wylu.me/categories/os/"/>
    
    <category term="centos" scheme="https://wylu.me/categories/os/centos/"/>
    
    
    <category term="centos" scheme="https://wylu.me/tags/centos/"/>
    
    <category term="firewall" scheme="https://wylu.me/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信机制</title>
    <link href="https://wylu.me/posts/9fb7f5b4/"/>
    <id>https://wylu.me/posts/9fb7f5b4/</id>
    <published>2020-05-10T14:51:26.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>进程通信（Inter-Process Communication, IPC）是指进程之间的信息交换。其所交换的信息量，少则是一个状态或数值，多则是成千上万个字节。多个进程为了协调完成一项工作，相互之间必须能够进行通信。进程的互斥和同步可归结为低级通信。进程的高级通信是指用户可直接利用系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节，即对用户来说是透明的。这样就大大简化了通信程序编程上的复杂性。</p><span id="more"></span><h1 id="进程间通信机制">进程间通信机制</h1><p>Linux 操作系统支持以下几种进程间通信机制：</p><ul><li>Unix IPC 机制<ul><li>信号（signal）</li><li>管道（pipe）和命名管道（named pipe）</li></ul></li><li>System V 的 IPC 机制<ul><li>信号量（semaphore）</li><li>消息队列（message queue）</li><li>共享内存（shared memory）</li></ul></li><li>网络通信的套接字机制<ul><li>套接字（socket）</li></ul></li><li>全双工管道机制</li></ul><p>以上各种通信机制都提供了相应的接口，IPC 结构图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e7555aebbcdae382572ddedda53516e8.png" alt="IPC" /></p><h2 id="信号">信号</h2><p>信号是用来向一个或多个进程发送异步事件的软件机制，它类似于硬件中断，所以也叫软中断。信号不仅可以从键盘中断中产生，进程对虚拟内存的非法存取等系统错误环境下也会有信号产生，此外信号还被 shell 程序用来向其子进程发送任务控制命令。</p><p>系统中有一组被详细定义的信号类型，使用 <code>man 7 signal</code> 可以看到详细介绍。除了 SIGSTOP（进程终止执行）和 SIGKILL（进程退出）两个信号外，进程可以忽略其余信号。信号没有相对优先级，如果在同一时刻对于一个进程产生了两个信号，则它们将可能以任意顺序到达进程并进行处理。同时 Linux 并不提供处理多个相同类型信号的方式。</p><p>信号个数受到处理器字长的限制。32 位字长的处理器最多可以有 32 个信号，而 64 位处理器可以有最多 64 个信号。Linux 通过存储在进程 task_struct 中的信息来实现信号。当前未处理的信号保存在 signal 域中，并带有保存在 blocked 中的被阻塞信号的屏蔽码。除了 SIGSTOP 和 SIGKILL 外，所有的信号都能被阻塞。</p><p>系统中只有核心和超级用户进程可以向其他所有进程发送信号，普通进程只能向具有相同 uid 和 gid 的进程或者在同一进程组中的进程发送信号。信号是通过设置 task_struct 结构中 signal 域里的某一位来产生的。如果进程没有阻塞信号并且处于可中断的等待状态，则可以将其状态改成 Running，同时如确认进程还处在运行队列中，就可以通过信号唤醒它。这样系统下次发生调度时，调度管理器将选择它运行。信号必须等待到进程再次运行时才交给它，每次进程从系统调用中退出前，它都会检查 signal 和 blocked 域，看是否有可以立刻发送的非阻塞信号。对当前不可阻塞信号的处理代码放置在 sigaction 结构中。</p><h2 id="管道">管道</h2><p>管道是一个先进先出、大小固定的缓冲区，容量为 1 页（4KB），用于两个进程之间的单向数据传递。当管道有空间时，写者进程把数据送入管道，否则将被阻塞；如果管道中没有数据或读者进程需要的数据多于其中的数据，读者进程会被阻塞，否则执行读者进程的请求。整个过程由操作系统监控完成，互斥地访问管道。当传送的数据量大于管道的容量时，可以通过同步机制分次传送数据。</p><h3 id="无名管道">无名管道</h3><p>例如：Linux shell 程序中的重定向操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | more</span></span><br></pre></td></tr></table></figure><p>在这个管道应用中，<code>ls</code> 列出当前目录的输出被作为标准输入送到 more 程序中按格式显示处理。无名管道是将两个相关联的进程联系在一起。shell 程序负责在进程间建立临时的管道。</p><p>在 Linux 中，管道是通过指向同一个临时 VFS（Virtual File System，虚拟文件系统）inode 的两个 file 数据结构来实现的，此 VFS inode 指向内存中的一个物理块。当写者进程向管道中写入数据时，字节被复制到共享数据页面中，当读者进程从管道中读时，字节从共享数据页面中复制出来。</p><p>Linux 必须同步对管道的访问。它必须保证读者和写者进程以确定的步骤执行，为此需要使用锁、等待队列和信号等同步机制。以写数据为例，如果没有足够的空间容纳对所有写入管道的数据，或者管道被读者进程加锁时，当前进程将在管道 inode 的等待队列中睡眠，同时调度管理器开始执行以选择其他进程来执行。当有足够的空间或者管道被解锁时，它将被读者唤醒，然后执行写操作。当两个进程对管道的使用结束时，管道 inode 和共享数据页面将同时被释放。</p><h3 id="命名管道">命名管道</h3><p>Linux 还支持命名管道（named pipe），即 FIFO 管道，为两个不相关的进程提供通信手动。命名管道不是临时对象，它们是文件系统中的实体并且可以通过 <code>mknod</code> 命令来创建。进程只要拥有适当的权限就可以自由使用 FIFO 管道。在写者进程使用之前，Linux 必须让读者进程先打开此 FIFO 管道；任何读者进程从中读取之前必须有写者进程向其写入数据。</p><h2 id="消息队列">消息队列</h2><p>Linux 系统也支持 System V 的进程间通信机制，包括消息序列、信号量和共享内存。所有的 IPC 对象在 Linux 中有一个公共的 ipc_perm 结构，它含有进程拥有者、创建者和组标志符，对此对象（拥有者，组及其他）的存取模式以及 IPC 对象键。</p><p>消息是按一定格式封装起来的消息。每个进程都有一个与之关联的消息队列，接收进程按时间顺序或消息类型从消息队列取走消息。如果进程向一个满队列发送消息或从一个空队列取走消息都会被阻塞。</p><p>Linux 系统维护着一个 msgque 消息队列链表，其中每个元素指向一个描述消息队列 msqid_ds 结构，该结构完整地描述一个消息队列。每个 msqid_ds 结构包含一个 ipc_perm 结构和指向已经进入此队列消息的指针。另外，Linux 保留有关队列修改时间信息，如上次系统向队列中写入的时间等。msqid_ds 包含两个等待队列：一个为队列写入进程使用而另一个由队列读取进程使用。</p><p>每次进程试图向写入队列写入消息时，系统将把其有效用户和组标志符与此队列的 ipc_perm 结构中的模式进行比较。如果允许写入操作，则把此消息从该进程的地址空间复制到 msg 数据结构中，并放置到此消息队列尾部。如果消息队列的长度已满，则该写入进程将被阻塞，并调度新进程运行。若有消息被取走时，该进程将被唤醒。读进程执行时将选择队列中第一个消息或者某特定类型的消息。如果没有消息可以满足此要求，读进程将被阻塞，并运行调度程序。当有新消息写入队列时，进程将被唤醒。</p><h2 id="信号量">信号量</h2><p>信号量是用一个整数表示系统当前资源的使用情况，当信号量大于或等于 0 时，其值表示可用资源的数量，当它小于 0 时，其值表示等待该资源的进程数。信号量是 wait 和 signal 原语的推广，可以通过它实现进程的同步与互斥。例如用信号量实现临界区（critical region）的互斥，即在某一时刻在此区域内的代码只能被一个进程执行。</p><h3 id="数据结构">数据结构</h3><p>信号量在 Linux 中使用以下几个数据结构来表示：</p><ul><li>sem：表示系统中的每个信号量</li><li>semid_ds：表示信号量的集合</li><li>sem_queue：表示由每个信号量集合所构成的队列</li></ul><p>semid_ds 结构的 sem_base 指向一个 sem 数组，进程可以使用系统调用来操作这些信号量数组。</p><h3 id="实现过程">实现过程</h3><p>在执行信号量操作时，Linux 首先将检查是否所有操作已经成功。如果操作值与信号量当前数组相加大于 0，或者操作值与信号量当前值都是 0，操作将会成功。如果所有信号量操作失败，Linux 仅仅会把那些操作标志没有要求系统调用为非阻塞类型的进程挂起。进程挂起后，Linux 必须保存信号量操作的执行状态并将当前进程放入等待队列。系统还堆栈上建立 sem_queue 结构并填充各个域。 这个 sem_queue 结构将被放到信号量对象等待队列的尾部。系统把当前进程置入 sem_queue 结构中的等待队列中，然后执行调度程序。</p><p>如果所有这些信号量操作都成功则无须挂起当前进程，Linux 将对信号量数组中的其他成员进行相同操作，然后检查那些处于等待或挂起状态的进程。首先，Linux 将依次检查挂起队列（sem_pending）中的每个成员，看信号量操作能否继续。如果可以则将其 sem_queue 结构从挂起链表中删除并对信号量数组发出信号灯操作。Linux 还将唤醒处于睡眠状态的进程并使之成为下一个运行的进程。如果在对挂起队列的遍历过程中有的信号量操作不能完成则 Linux 将一直重复此过程，直到所有信号量操作完成且没有进程需要继续睡眠。</p><h3 id="与信号量有关的系统调用">与信号量有关的系统调用</h3><ul><li><code>semget()</code>：创建新的信号量集合或存取一个已有的信号量集合。</li><li><code>semop()</code>： 当操作数和信号量的值相加大于或等于 0 时，即进程请求的资源能够满足，操作成功，返回 0；若相加后其中某个值小于 0，资源不能满足，将进程阻塞，操作不成功。</li><li><code>semctl()</code>：在信号量集合上完成指定的命令操作。</li></ul><h3 id="死锁">死锁</h3><p>死锁是信号量使用过程中可能产生的一个最严重的问题。当一个进程进入临界区时它修改了信号量的值，然后在离开临界区时由于运行失败或者被 kill 而没有改回信号量时，死锁将会发生。</p><p>Linux 为了避免死锁的发生，为每个进程维护至少一个对应于信号量数组的 sem_undo 结构，它保存了完成信号量操作之前的状态。当对信号量进行操作时，信号量变化的数值被放入进程的 sem_undo 结构的该信号的入口中。当进程被删除时，Linux 将遍历该进程的 sem_undo 集合对信号量数组使用调整值。如果信号量集合被删除而 sem_undo 数据结构还在进程的 task_struct 结构中，则此信号灯数组标志符将被置为无效。此时信号量清除代码只需丢弃 sem_undo 即可。</p><h2 id="共享存储区">共享存储区</h2><p>共享存储区是指被多个进程共享的虚存中的一个数据块，进程利用它来实现通信。此虚拟内存的页面出现在每个共享进程页表中，但位置可以不同。每个进程有相应的读或读写权限，对共享存储区的互斥访问必须依赖于其他机制，如信号量。</p><p>每个新创建的共享存储区由一个 shmid_ds 数据结构来表示，它描述共享存储区的大小，进程如何使用以及共享存储区映射到各自地址空间的方式。由共享存储区创建者控制对此内存的存取权限。</p><p>每个使用此共享内存的进程必须它能通过系统调用将其连接到虚拟内存上，但在连接时并没有创建共享存储区，只有进程访问它时才创建。当进程首次访问共享虚拟内存中的页面时将产生缺页中断。当取回此页面后，Linux 找到了描述此页面的数据结构。它包含指向使用此种类型虚拟内存的处理函数地址指针。当发生共享内存页面缺页错误时，错误处理代码将在此 shmid_ds 对应的页表入口链表中寻找此页面是否在内存。如果不在，则为其分配物理页面并创建页表入口。同时还将它放入当前进程的页表中，此入口被保存在 shmid_ds 结构中。下个访问此内存的进程就会连接到此页面上。这样，第一个访问虚拟内存页面的进程创建这块内存，随后的进程把此页面加入到各自的虚拟地址空间中。</p><p>不再使用共享存储区的进程将断开与之的连接，其对应的页面结构将从 shmid_ds 结构中删除并回收。当前进程对应此共享内存地址的页表入口也将被更新并置为无效。当最后一个进程断开与共享内存的连接时，当前位于物理内存中的共享内存页面将被释放，同时删除 shmid_ds 结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程通信（Inter-Process Communication, IPC）是指进程之间的信息交换。其所交换的信息量，少则是一个状态或数值，多则是成千上万个字节。多个进程为了协调完成一项工作，相互之间必须能够进行通信。进程的互斥和同步可归结为低级通信。进程的高级通信是指用户可直接利用系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节，即对用户来说是透明的。这样就大大简化了通信程序编程上的复杂性。&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="https://wylu.me/categories/os/"/>
    
    <category term="kernel" scheme="https://wylu.me/categories/os/kernel/"/>
    
    
    <category term="进程间通信" scheme="https://wylu.me/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
    <category term="IPC" scheme="https://wylu.me/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="https://wylu.me/posts/3a046ccf/"/>
    <id>https://wylu.me/posts/3a046ccf/</id>
    <published>2020-05-10T14:50:38.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统的重要任务之一是管理计算机的软、硬件资源。现代操作系统的主要特点在于程序的并发执行，由此引出系统的资源被共享和用户随机使用系统。因而操作系统最核心的概念就是进程：即正在运行的程序。操作系统借助于进程来管理计算机的软、硬件资源，支持多任务的并发。操作系统的其他内容都是围绕进程展开的。所以进程管理是 Linux 操作系统内核的主要内容之一，它对整个操作系统的执行效率至关重要。</p><span id="more"></span><div class="note info"><p><strong>Linux 进程管理</strong> 原文出处：《操作系统实验指导-基于Linux内核》第2版 原文作者：徐虹 何嘉 张钟澍</p></div><h1 id="linux-进程管理">Linux 进程管理</h1><p>进程是一个动态的实体，是一个可并发执行的程序在一个数据集合上的运行过程，它是一个正在执行的程序，是操作系统分片资源的基本单位。进程不仅包含指令和数据，也包含程序计数器和所有 CPU 寄存器的值，同时它的堆栈中存储着如子程序参数、返回地址以及变量之类的临时数据。</p><p>Linux 的进程具有独立的权限与职责。如果系统中某个进程崩溃，它不会影响到其余的进程。每个进程运行在其各自的虚拟地址空间中，进程之间发生联系只能通过核心控制下的可靠通信机制来完成。</p><p>进程在生命周期内将使用系统中的资源。它利用系统中的 CPU 来执行命令，在物理内存中放置指令和数据，使用文件系统提供的功能打开并使用文件，同时直接或间接地使用物理设备。Linux 必须跟踪系统中每个进程以及资源，以便在进程间实现资源的公平分配。</p><p>Linux 支持多种类型的可执行文件格式，如 ELF、Java 等。由于这些进程必须使用系统共享库，所以对它们的管理要具有透明性。</p><ul><li>描述进程的数据结构</li><li>进程调度</li><li>创建进程</li><li>进程通信机制</li></ul><h2 id="描述进程的数据结构">描述进程的数据结构</h2><p>Linux 用 task_struct 数据结构来表示每个进程，在 Linux 中任务与进程表示的意义是一样的。系统维护一个名为 task 的数组，task 包含指向系统中所有进程的 task_struct 结构的指针。这意味着系统中的最大进程数目受 task 数组大小的限制，默认值一般为 512。创建新进程时，Linux 将从系统内存中分配一个 task_struct 结构并将其加入 task 数组。当前运行进程的结构用 current 指针来指示。</p><p>Linux 还支持实时进程。这些进程必须对外部事件作出快速反应，系统将区分对待这些进程和其他进程。虽然 task_struct 数据结构庞大而复杂，但可以归纳为如下几类：</p><h3 id="进程的状态信息state">进程的状态信息（state）</h3><p>进程在执行过程中会根据环境来改变进程的状态，Linux 进程有以下状态。</p><ul><li><p>Running</p><p>进程处于运行（它是系统的当前进程）或者准备运行状态（它在等待系统将 CPU 分配给它）。</p></li><li><p>Waiting</p><p>进程在等待一个事件或者资源。Linux 将等待进程分成两类：可中断与不可中断。可中断等待进程可以被信号中断；不可中断等待进程是由于硬件原因而等待，例如进程打开某个设备文件，在得到设备的回应前处于等待状态，因此在任何情况下都不可中断。</p></li><li><p>Stopped</p><p>进程被停止，通常是通过接收一个信号。正在被调试的进程可以处于停止状态。</p></li><li><p>Zombie</p><p>这是因为某些原因而被终止的进程，但是在 task 数组中仍然保留其 task_struct 结构。它像一个已经死亡的进程。</p></li></ul><h3 id="调度信息scheduling-information">调度信息（scheduling information）</h3><p>Linux 调度进程所需要的信息，包括进程的类型（普通或实时）和优先级，计数器中记录允许进程执行的时间量。</p><h3 id="进程标识信息identifiers">进程标识信息（identifiers）</h3><p>系统中每个进程都有进程标志。进程标志并不是 task 数组的索引，它仅仅是个数字。每个进程还有一个用户与组标志，它们用来控制进程对系统中的文件和设备的存取权限。</p><h3 id="进程的通信信息inter-process-communication">进程的通信信息（inter-process communication）</h3><p>Linux 支持经典的 UNIX IPC 机制，如信号、管道和命名管道以及 System V 中 IPC 机制，包括共享内存、信号量和消息队列。</p><h3 id="链接信息links">链接信息（links）</h3><p>Linux 系统中所有进程都是相互联系的。除了初始化进程外，所有进程都有一个父进程。新进程不是被创建，而是被复制，都是从以前的进程克隆而来。每个进程对应的 task_struct 结构中包含有指向其父进程和兄弟进程（具有相同父进程的进程）以及子进程的指针。</p><p>系统中所有进程都用一个双向链表连接起来，而它们的根是 init 进程的 task_struct 数据结构。这个链表被 Linux 核心用来寻找系统中所有进程，它为 ps 或者 kill 命令提供了支持。</p><h3 id="时间和定时器信息times-and-timers">时间和定时器信息（times and timers）</h3><p>核心需要记录进程的创建时间以及在其生命期消耗的 CPU 时间。适中每跳动一次，核心就要更新保存在 jiffies 变量中，记录进程在系统和用户模式下消耗的时间量。Linux 支持与进程相关的 interval 定时器，进程可以通过系统调用来设定定时器以便在定时器到时后向它发送信号。这些定时器可以是一次性的或者周期性的。</p><h3 id="有关文件系统的信息file-system">有关文件系统的信息（file system）</h3><p>进程可以自由地打开或关闭文件，进程的 task_struct 结构中包含一个指向每个打开文件描述符的指针以及指向两个 VFS inode 的指针。每个 VFS inode 唯一地标记文件中的一个目录或者文件，同时还对底层文件系统提供统一的接口。这两个指针，一个指向进程的根目录，另一个指向其当前或者 pwd 目录。pwd 从 UNIX 命令 pwd 中派生出来，用来显示当前工作目录。这两个 VFS inode 包含一个 count 域，当多个进程引用它们时，它的值将增加。这就是为什么不能删除进程当前目录或者其子目录的原因。</p><h3 id="虚拟内存信息virtual-memory">虚拟内存信息（virtual memory）</h3><p>多数进程都有一些虚拟内存（核心线程和后台进程没有），Linux 核心必须跟踪虚拟内存与系统物理内存的映射关系。</p><h3 id="进程上下文信息processor-specific-context">进程上下文信息（processor specific context）</h3><p>进程可以认为是系统当前状态的总和。进程运行时，它将使用处理器的寄存器以及堆栈等。进程被挂起时，进程的上下文中所有与 CPU 相关的状态必须保存在它的 task_struct 结构内。当调度器重新调度该进程时，所有上下文被重新设定。</p><h3 id="其它信息">其它信息</h3><p>Linux 支持 SMP 多 CPU 结构，在 task_struct 中有相应的描述信息。此外还包括资源使用、进程终止信号、描述可执行的文件格式的信息等。</p><h2 id="进程调度">进程调度</h2><p>Linux 能让多个进程并发执行，由此必然会产生资源争夺的情况，而 CPU 是系统中最重要的资源。进程调度就是进程调度程序按照一定的策略，动态地把 CPU 分配给处于就绪队列中的某一个进程，使之执行。进程调度的目的是使处理机资源得到最高效的利用。进程调度的策略要考虑“高效”、“公平”、“周转时间”、“吞吐量”、“响应时间”等原则，并且在一定的调度时机，通过合适的调度算法来完成进程的调度。</p><h3 id="进程调度的时机">进程调度的时机</h3><p>在 Linux 中采用的是 <strong>非剥夺调度</strong> 的机制，进程一旦运行就不能被停止，当前进程必须等待某个系统事件时，它才释放 CPU。例如进程可能需要写数据到某个文件。一般等待发生在系统调用的过程中，此时进程处于系统模式；处于等待状态的进程将被挂起而其他的进程被调度管理器选出来执行。系统为进程设置相应的时间片，当这个时间用完之后，再选择另一个进程来运行。Linux 调度时机有以下几种。</p><p>（1）时间片完</p><p>（2）进程状态转换</p><p>（3）执行设备驱动程序</p><p>（4）进程从中断、异常或系统调用返回到用户态</p><h3 id="进程调度的功能">进程调度的功能</h3><p>（1）允许进程建立自己的新备份</p><p>（2）决定哪一个进程将占用 CPU，使得可运行进程之间进行有效的转移</p><p>（3）接收中断并把它们发送到合适的内核子系统</p><p>（4）发送信号给用户进程</p><p>（5）管理定时器硬件</p><p>（6）当进程结束后，释放进程所占用的资源</p><p>（7）支持动态装入模块，这些模块代表着内核启动以后所增加的内核功能，这种可装入的模块将由虚拟文件系统和网络接口使用。</p><h3 id="进程调度的数据结构">进程调度的数据结构</h3><p>Linux 使用基于优先级的简单调度算法来选择下一个运行进程。当选定新进程后，系统必须将当前进程的状态、处理器中的寄存器以及上下文状态保存到 task_struct 结构中。同时它将重新设置新进程的状态并将系统控制权交给此进程。为了将 CPU 时间合理地分配给系统中每个可执行进程，调度管理器必须将这些时间信息也保存在 task_struct 中。</p><p>（1）调度策略（policy）</p><p>Linux 系统中存在普遍与实时两种进程。实时进程的优先级要高于其他进程。根据调度策略，Linux 将进程分为以下三种类型。</p><ul><li><code>SCHED_FIFO</code>：先进先出实时进程。只有当前进程执行完毕再调度下一优先级最高的进程。</li><li><code>SCHED_RR</code>：循环实时进程。在此策略下，每个进程执行完一个时间片后，会被挂起，然后选择另一具有相同或更高优先级的进程执行。</li><li><code>SCHED_OTHER</code>：普通进程。</li></ul><p>（2）优先级（priority）</p><p>调度管理器分配给进程的优先级，同时也是进程允许运行的时间（jiffies）。系统调度 renice 可以改变进程的优先级。</p><p>（3）实时进程的优先级（rt_priority）</p><p>Linux 支持实时进程，且它们的优先级要高于非实时进程。调度器使用这个域给每个实时进程一个相对优先级。同样可以通过系统调用来改变实时进程的优先级。</p><p>（4）当前执行进程剩余的时间（counter）</p><p>进程首次运行时为进程优先级的数值，它随时间变化递减。普通进程的 counter 值是其优先级权值，而实时进程的则是 counter 加上 1000。</p><p>（5）当前进程（current process）</p><p>当调度其他进程占用 CPU 时，根据调度策略对当前进程进行一些处理，修改其状态，并插入相应的队列。</p><h3 id="进程调度的依据">进程调度的依据</h3><p>调度程序运行时，要在所有处于可运行状态的进程中选择最值得运行的进程投入运行。上面所介绍的 policy、priority、counter 和 rt_priority 4 项是调度程序选择的依据。</p><p>Linux 操作系统用函数 <code>goodness()</code> 来衡量一个处于可运行状态的进程值得运行的程度。该函数综合了上面4项依据，给每个处于可运行状态的进程赋予一个权值（weight），调度程序以这个权值作为选择进程的唯一依据。函数流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7a1b73c66d76b7082c7a94d38d352405.png" alt="goodnees-flowchart" /></p><h3 id="进程队列的组织方式">进程队列的组织方式</h3><p>（1）可运行队列（runnable queue）</p><p>操作系统中所有处于可运行状态的进程链成一个队列，该队列就称作可运行队列。调度程序直接的操作对象就是可运行队列。</p><p>可运行队列容纳了系统中所有可运行进程，它是一个双向循环队列，其结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/985ddc670db155defe7e30b3bcd952d8.png" alt="process-runnable-queue" /></p><p>该队列通过 task_struct 结构中的两个指针 next_run 和 prev_run 来维持。队列的标志有两个：一个是空进程 idle_task 即 task[0]，另一个是队列的长度（即系统中处于可运行状态的进程数目，用全局整形变量 nr_running 表示）。</p><p>（2）pidhash 表及链表 pidhash</p><p>为了快速根据进程的 pid 找到该进程的 task_struct 结构，系统使用链式结构的 Hash 表对进程的 task_struct 结构进行管理，Hash 表的默认长度为 128。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> PIDHASH_SZ (NR_TASKS&gt;&gt;2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pidhash(x) (((x)&gt;&gt;8)^(x))&amp;(PIDHASH_SZ-1)</span></span><br></pre></td></tr></table></figure><p>新创建进程时，系统根据其 pid 值将其结构插入到 pidhash 表中，具有相同 hash 值的进程构成一个双向链表。</p><p>（3）空闲 task_struct 双向循环链表 tarray_freelist</p><p>Linux 操作系统将所有的空闲 task_struct 通过双向循环链表进行链接，方便对新创建的进程快速分配 task_struct 结构，以及对撤销的进程回收 task_struct 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">tarray_freelist</span>;</span></span><br></pre></td></tr></table></figure><p>（4）等待队列</p><p>进程经常要等待某个系统资源。例如某个进程可能需要描述文件系统中某个目录的 VFS inode，但是此 inode 可能不在 buffer cache 中。此时这个进程必须等到该 inode 从包含次文件系统的物理介质中取出来才可以继续运行。Linux 核心使用一个非常简单的队列：等待队列。它包含一个指向进程 task_struct 结构的指针以及等待队列中下一个元素的指针。加入到等待队列中的进程既可以是可中断也可以是不可中断的。</p><h3 id="进程调度的工作流程">进程调度的工作流程</h3><p>进程调度的工作流程比较简单：遍历可运行队列，从中选择一个权值最大的进程；如果可运行队列中所有进程的时间片都用完了，则要给系统中所有进程的时间片重新赋值。Linux 操作系统中的调度程序比较简单，它可以分为如下 5 个部分。</p><ul><li>第一部分：看是否有中断在运行。当中断运行时，是不允许调度程序执行的。</li><li>第二部分：处理内核例程。</li><li>第三部分：对当前进程做相关处理，为选择下一个进程做好准备。</li><li>第四部分：选择下一个可运行进程，即进程调度。</li><li>第五部分：进程切换，使 current 指向选定的进程，并建立新进程的运行环境。</li></ul><h2 id="创建进程">创建进程</h2><p>Linux 启动后经过一系列的初始化操作，系统由 <code>init()</code> 函数创建系统的第一个进程 init，其标志符为 1。init 进程将完成系统的一些初始化设置任务（如打开系统控制台、安装根文件系统及启动系统的守护进程等），以及执行系统初始化程序，如 /etc/init，/bin/init 或者 /sbin/init。init 进程使用 /etc/inittab 作为脚本文件来创建系统中的新进程。这些新进程又创建各自的新进程。例如 getty 进程将在用户试图登录时创建一个 login 进程。系统中所有进程都是从 init 核心进程中派生出来。</p><p>新进程通过复制老进程或当前进程来创建。系统调用 fork 或 clone 可以创建新任务，复制发生在核心状态下的核心中。系统从物理内存中分配出来一个新的 task_struct 数据结构，同时还有一个或多个包含被复制进程堆栈（用户与核心）的物理页面。然后创建唯一的标记此新任务的进程标志符。新创建的 task_struct 将被放入 task 数组中，另外将被复制进程的 task_struct 中的内容页表拷入新的 task_struct 中。</p><p><strong>复制完成后，Linux 允许两个进程共享资源而不是复制各自的备份。这些资源包括文件、信号处理过程和虚拟内存。</strong> 进程对共享资源用各自的 count 来记数。在两个进程对资源的使用完毕之前，Linux 绝不会释放此资源。</p><h2 id="进程间通信机制">进程间通信机制</h2><p><a href="https://wylu.me/posts/9fb7f5b4">进程间通信机制</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;操作系统的重要任务之一是管理计算机的软、硬件资源。现代操作系统的主要特点在于程序的并发执行，由此引出系统的资源被共享和用户随机使用系统。因而操作系统最核心的概念就是进程：即正在运行的程序。操作系统借助于进程来管理计算机的软、硬件资源，支持多任务的并发。操作系统的其他内容都是围绕进程展开的。所以进程管理是 Linux 操作系统内核的主要内容之一，它对整个操作系统的执行效率至关重要。&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="https://wylu.me/categories/os/"/>
    
    <category term="kernel" scheme="https://wylu.me/categories/os/kernel/"/>
    
    
    <category term="进程管理" scheme="https://wylu.me/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Morris Traversal</title>
    <link href="https://wylu.me/posts/5e36b8b8/"/>
    <id>https://wylu.me/posts/5e36b8b8/</id>
    <published>2020-05-02T13:21:46.000Z</published>
    <updated>2022-11-23T17:04:10.533Z</updated>
    
    <content type="html"><![CDATA[<p>通常，实现二叉树的前序（preorder）、中序（inorder）、后序（postorder）遍历的迭代版本都需要 O(n) 的空间复杂度，那么有没有可能使用 O(1) 空间进行迭代遍历呢？答案是肯定的。</p><p>本文将介绍 Morris Traversal 遍历二叉树的方法，该算法能够做到 O(1) 空间复杂度的迭代遍历，并在遍历完成后二叉树依然保持原始状态（遍历过程中可能被修改）。</p><span id="more"></span><h1 id="morris-traversal">Morris Traversal</h1><p>要使用 O(1) 空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的 p 指针），由于不能用栈作为辅助空间。为了解决这个问题，Morris 方法用到了线索二叉树（threaded binary tree）的概念。在 Morris 方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。</p><h1 id="树结点定义">树结点定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历">中序遍历</h1><ul><li>1.设当前结点为cur</li><li>2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</li><li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。<ol type="a"><li>如果pre.right为空，则将pre.right指向当前结点，然后当前结点更新 为当前结点的左孩子。</li><li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 输出当前结点，然后当前结点更新为当前结点的右孩子。</li></ol></li><li>4.重复步骤2、3，直到当前结点为空。</li></ul><p>下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/fdfa082fd0a7a7a07440aa457f74421e.jpg" alt="morris-inorder-traversal" /></p><p>参考实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisInorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 18:43:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisInorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Inorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，然后当前结点更新</span></span><br><span class="line"><span class="comment">     *      为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      输出当前结点，然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找出左子树的最右结点，也即找出当前结点的前驱</span></span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromPreAndIn(pre, in);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisInorderTraversal</span>().inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(n)</li></ul><p>寻找左子树最右结点（也即当前结点的前驱）的时间复杂度为 O(n)，n 个节点的二叉树中一共有 n-1 条边，整个过程中每条边最多只走 2 次，一次是为了定位到某个节点，另一次是为了寻找某个结点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点，所以复杂度为O(n)。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8626f16d4c3cf499d5611e80f4f81da2.jpg" alt="search-predecessor" /></p><h1 id="前序遍历">前序遍历</h1><ul><li>1.设当前结点为cur</li><li>2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点</li><li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。<ol type="a"><li>如果pre.right为空，则将pre.right指向当前结点，输出当前结点， 然后当前结点更新为当前结点的左孩子。</li><li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 然后当前结点更新为当前结点的右孩子。</li></ol></li><li>4.重复步骤2、3，直到当前结点为空。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/faf43f911834341ec7d1cad8d5121fec.jpg" alt="morris-preorder-traversal" /></p><p>参考实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisPreorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 19:53:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisPreorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Preorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，输出当前结点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找出左子树的最右结点，也即找出当前结点的前驱</span></span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromPreAndIn(pre, in);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisPreorderTraversal</span>().preorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历">后序遍历</h1><ul><li>1.创建一个临时结点dump，令其左孩子是root，设当前结点为cur</li><li>2.如果当前结点的左孩子为空，则将其右孩子作为当前结点。</li><li>3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。<ol type="a"><li>如果pre.right为空，则将pre.right指向当前结点， 然后当前结点更新为当前结点的左孩子。</li><li>如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状）， 倒序输出从当前节点的左孩子到pre这条路径上的所有节点， 然后当前结点更新为当前结点的右孩子。</li></ol></li><li>4.重复步骤2、3，直到当前结点为空。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e1f5307fd830868204e48aa7a18e0001.jpg" alt="morris-postorder-traversal" /></p><p>参考实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.binarytree.traverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> common.TreeNode;</span><br><span class="line"><span class="keyword">import</span> common.TreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@File</span>    :   MorrisPostorderTraversal.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>    :   2020/05/02 20:16:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  :   wylu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisPostorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Morris Postorder Traversal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.创建一个临时结点dump，令其左孩子是root，设当前结点为cur</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左孩子为空，则将其右孩子作为当前结点。</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的左孩子不为空，则找出左子树的最右结点，记为pre。</span></span><br><span class="line"><span class="comment">     *   a) 如果pre.right为空，则将pre.right指向当前结点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的左孩子。</span></span><br><span class="line"><span class="comment">     *   b) 如果pre.right指向当前结点，则将pre.right重新设为空（恢复树的形状），</span></span><br><span class="line"><span class="comment">     *      倒序输出从当前节点的左孩子到pre这条路径上的所有节点，</span></span><br><span class="line"><span class="comment">     *      然后当前结点更新为当前结点的右孩子。</span></span><br><span class="line"><span class="comment">     * 4.重复步骤2、3，直到当前结点为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.left = root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump, pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="literal">null</span>;</span><br><span class="line">                    printReverse(cur.left);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printReverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> reverse(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反转后的链表头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">reverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.right;</span><br><span class="line">            cur.right = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] post = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> TreeNode.buildFromInAndPost(in, post);</span><br><span class="line">        TreePrinter.prtHorizontalStyle(root);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MorrisPostorderTraversal</span>().postorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html">https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html</a></p><p><a href="https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading">https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常，实现二叉树的前序（preorder）、中序（inorder）、后序（postorder）遍历的迭代版本都需要 O(n) 的空间复杂度，那么有没有可能使用 O(1) 空间进行迭代遍历呢？答案是肯定的。&lt;/p&gt;
&lt;p&gt;本文将介绍 Morris Traversal 遍历二叉树的方法，该算法能够做到 O(1) 空间复杂度的迭代遍历，并在遍历完成后二叉树依然保持原始状态（遍历过程中可能被修改）。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="tree" scheme="https://wylu.me/categories/algorithm/tree/"/>
    
    
    <category term="binary-tree" scheme="https://wylu.me/tags/binary-tree/"/>
    
    <category term="morris-traversal" scheme="https://wylu.me/tags/morris-traversal/"/>
    
  </entry>
  
  <entry>
    <title>二叉树练习</title>
    <link href="https://wylu.me/posts/cb350e7d/"/>
    <id>https://wylu.me/posts/cb350e7d/</id>
    <published>2020-05-02T09:33:59.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>一些经典的二叉树练习题，帮助理解掌握二叉树的各种遍历方法和递归地解决问题的思路。</p><span id="more"></span><h1 id="二叉树节点定义">二叉树节点定义</h1><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="利用中序和后序遍历序列重建二叉树">利用中序和后序遍历序列重建二叉树</h1><p>给定一棵树的中序和后序遍历结果，构造二叉树。</p><p>注意：您可以假定树中不存在重复项。</p><p>例如，给定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回以下二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="literal">null</span> || postorder == <span class="literal">null</span> || inorder.length != postorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(inorder.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> si, <span class="type">int</span>[] post, <span class="type">int</span> sp, <span class="type">int</span> ep, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp &gt; ep) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(post[ep]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> idx - si;</span><br><span class="line">        root.left = build(si, post, sp, sp + leftLen - <span class="number">1</span>, map);</span><br><span class="line">        root.right = build(idx + <span class="number">1</span>, post, sp + leftLen, ep - <span class="number">1</span>, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder <span class="keyword">or</span> <span class="built_in">len</span>(inorder) != <span class="built_in">len</span>(postorder):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        indices = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        <span class="keyword">return</span> self.build(<span class="number">0</span>, postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, si: <span class="built_in">int</span>, post: <span class="type">List</span>[<span class="built_in">int</span>], sp: <span class="built_in">int</span>, ep: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">              indices: <span class="built_in">dict</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> sp &gt; ep:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(post[ep])</span><br><span class="line">        idx = indices[root.val]</span><br><span class="line">        llen = idx - si</span><br><span class="line"></span><br><span class="line">        root.left = self.build(si, post, sp, sp + llen - <span class="number">1</span>, indices)</span><br><span class="line">        root.right = self.build(idx + <span class="number">1</span>, post, sp + llen, ep - <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="利用前序和中序遍历序列重建二叉树">利用前序和中序遍历序列重建二叉树</h1><p>给定一棵树的前序和中序遍历结果，构造二叉树。</p><p>注意：您可以假定树中不存在重复项。</p><p>例如，给定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回以下二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || inorder == <span class="literal">null</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(inorder.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> si, <span class="type">int</span>[] pre, <span class="type">int</span> sp, <span class="type">int</span> ep,</span></span><br><span class="line"><span class="params">                           HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp &gt; ep) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[sp]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> idx - si;</span><br><span class="line">        root.left = build(si, pre, sp + <span class="number">1</span>, sp + leftLen, map);</span><br><span class="line">        root.right = build(idx + <span class="number">1</span>, pre, sp + leftLen + <span class="number">1</span>, ep, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="built_in">len</span>(preorder) != <span class="built_in">len</span>(inorder):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        indices = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        <span class="keyword">return</span> self.build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, pre: <span class="type">List</span>[<span class="built_in">int</span>], sp: <span class="built_in">int</span>, ep: <span class="built_in">int</span>, si: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">              indices: <span class="built_in">dict</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> sp &gt; ep:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(pre[sp])</span><br><span class="line">        idx = indices[root.val]</span><br><span class="line">        llen = idx - si</span><br><span class="line"></span><br><span class="line">        root.left = self.build(pre, sp + <span class="number">1</span>, sp + llen, si, indices)</span><br><span class="line">        root.right = self.build(pre, sp + llen + <span class="number">1</span>, ep, idx + <span class="number">1</span>, indices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h1><p>您会得到一棵完美的二叉树，其中所有叶子都在同一水平上，每个父级都有两个孩子。二叉树定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充每个 next 指针以指向其下一个右节点。如果没有下一个右节点，则 next 指针应设置为 NULL。</p><p>最初，所有 next 指针都设置为 NULL。</p><p>Follow up:</p><ul><li>您只能使用常量的额外空间。</li><li>递归方法很好，您可以假定隐式堆栈空间不算作此问题的额外空间。</li></ul><p>Example 1:</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d4af01ea9ac3ca3193f50caa8b6a7b8b.png" alt="116-sample" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: 给定上面完美的二叉树（图A），您的函数应该填充每个下一个指针，</span><br><span class="line">以指向其下一个右节点，如图B所示。序列化的输出按层次顺序排列，与下一个指针相连，</span><br><span class="line">并带有 &#x27;＃&#x27; 表示每个层次的结束。</span><br></pre></td></tr></table></figure><p>限制条件：</p><ul><li>给定树中的节点数少于4096。</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * class Node &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public Node left;</span></span><br><span class="line"><span class="comment"> *     public Node right;</span></span><br><span class="line"><span class="comment"> *     public Node next;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment"> *         val = _val;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Node(int _val, Node _left, Node _right, Node  * _next) &#123;</span></span><br><span class="line"><span class="comment"> *         val = _val;</span></span><br><span class="line"><span class="comment"> *         left = _left;</span></span><br><span class="line"><span class="comment"> *         right = _right;</span></span><br><span class="line"><span class="comment"> *         next = _next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">levelStart</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (levelStart != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> levelStart;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.left.next = cur.right;</span><br><span class="line">                    <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cur.right.next = cur.next.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            levelStart = levelStart.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="comment"># class Node:</span></span><br><span class="line"><span class="comment">#     def __init__(self,</span></span><br><span class="line"><span class="comment">#                  val: int = 0,</span></span><br><span class="line"><span class="comment">#                  left: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  right: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            head = cur.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.<span class="built_in">next</span> = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                    cur.right.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.left</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针ii">填充每个节点的下一个右侧节点指针II</h1><p>给定一棵二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充每个 next 指针以指向其下一个右节点。如果没有下一个右节点，则 next 指针应设置为 NULL。</p><p>最初，所有 next 指针都设置为 NULL。</p><p>Follow up:</p><ul><li>您只能使用常量的额外空间。</li><li>递归方法很好，您可以假定隐式堆栈空间不算作此问题的额外空间。</li></ul><p>Example 1:</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/099321a3abf9e1118186bb2b101338c9.png" alt="117-sample" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: 给定上面的二叉树（图A），您的函数应该填充每个下一个指针，</span><br><span class="line">以指向其下一个右节点，如图B所示。序列化的输出按层次顺序排列，与下一个指针相连，</span><br><span class="line">并用 &#x27;＃&#x27; 表示 每个层次的结尾。</span><br></pre></td></tr></table></figure><p>限制条件：</p><ul><li>给定树中的节点数少于6000。</li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nextHeadDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nextLevelCur</span> <span class="operator">=</span> nextHeadDummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextLevelCur.next = cur.left;</span><br><span class="line">                    nextLevelCur = nextLevelCur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextLevelCur.next = cur.right;</span><br><span class="line">                    nextLevelCur = nextLevelCur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nextHeadDummy.next;</span><br><span class="line">            nextHeadDummy.next = <span class="literal">null</span>;</span><br><span class="line">            nextLevelCur = nextHeadDummy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="comment"># class Node:</span></span><br><span class="line"><span class="comment">#     def __init__(self,</span></span><br><span class="line"><span class="comment">#                  val: int = 0,</span></span><br><span class="line"><span class="comment">#                  left: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  right: &#x27;Node&#x27; = None,</span></span><br><span class="line"><span class="comment">#                  next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            head, pre = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    <span class="keyword">if</span> pre:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur.left</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        head = cur.left</span><br><span class="line">                    pre = cur.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    <span class="keyword">if</span> pre:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur.right</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        head = cur.right</span><br><span class="line">                    pre = cur.right</span><br><span class="line"></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="二叉树的最低共同祖先">二叉树的最低共同祖先</h1><p>给定二叉树，在树中找到两个给定节点的最低公共祖先（LCA）。</p><p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia上LCA的定义</a>：“最低的共同祖先被定义为两个节点p和q之间的关系，这是T中同时具有p和q作为后代的最低节点（我们允许一个节点成为其自身的后代）。 ”</p><p>给定以下二叉树：<code>root = [3,5,1,6,2,0,8,null,null,7,4]</code></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f2660bc712bf0a802e26ae97e1677ed6.png" alt="binarytree" /></p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be</span><br><span class="line">a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>所有节点的值都是唯一的。</li><li>p和q不同，并且两个值都将存在于二叉树中。</li></ul><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure><h1 id="二叉树的序列化与反序列化">二叉树的序列化与反序列化</h1><p>序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接进行传输，以便稍后在相同或另一个计算机环境中进行重构。</p><p>设计一种用于对二叉树进行序列化和反序列化的算法。序列化/反序列化算法的工作方式没有任何限制。您只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。</p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><p>说明：上面的格式与 LeetCode 序列化二叉树的方式相同。您不一定需要遵循这种格式，因此请发挥创造力并自己提出不同的方法。</p><p>注意：不要使用类成员/全局/静态变量来存储状态。您的序列化和反序列化算法应该是无状态的。</p><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELIMITER</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PADDING</span> <span class="operator">=</span> <span class="string">&quot;$&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(PADDING).append(DELIMITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(DELIMITER);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(data.split(DELIMITER)));</span><br><span class="line">        <span class="keyword">return</span> deserialize(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (PADDING.equals(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(val));</span><br><span class="line">        root.left = deserialize(queue);</span><br><span class="line">        root.right = deserialize(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): the root of tree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: a serial str of binary tree</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        self._serial(root, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_serial</span>(<span class="params">self, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        self._serial(root.left, res)</span><br><span class="line">        self._serial(root.right, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            data (str): a serial str of binary tree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            TreeNode: the root of tree</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        data.reverse()</span><br><span class="line">        <span class="keyword">return</span> self._deserial(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deserial</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        val = data.pop()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">        root.left = self._deserial(data)</span><br><span class="line">        root.right = self._deserial(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/942/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/942/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/943/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/943/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/932/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/932/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些经典的二叉树练习题，帮助理解掌握二叉树的各种遍历方法和递归地解决问题的思路。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="tree" scheme="https://wylu.me/categories/algorithm/tree/"/>
    
    
    <category term="二叉树" scheme="https://wylu.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="binary-tree" scheme="https://wylu.me/tags/binary-tree/"/>
    
    <category term="练习" scheme="https://wylu.me/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>递归地解决树问题</title>
    <link href="https://wylu.me/posts/657c0b00/"/>
    <id>https://wylu.me/posts/657c0b00/</id>
    <published>2020-05-02T08:38:48.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的部分中，我们介绍了如何递归解决<a href="https://wylu.me/posts/e85d694a">树遍历</a>问题。<strong>递归</strong>是解决树问题的最强大，最常用的技术之一。</p><p>众所周知，树可以递归定义为一个节点（根节点），该节点包含一个值和对子节点的引用列表。递归是树的自然特征之一。因此，许多树问题可以递归解决。对于每个递归函数调用，我们仅关注当前节点的问题，然后递归调用函数以解决其子级。</p><p>通常，我们可以使用 <strong>自上而下</strong> 的方法或 <strong>自下而上</strong> 的方法递归地解决树问题。</p><span id="more"></span><h1 id="自上而下的解决方案">自上而下的解决方案</h1><p>“自顶向下”表示在每个递归调用中，我们将首先访问该节点以提供一些值，并在递归调用该函数时将这些值传递给其子级。因此，“自上而下”的解决方案可以看作是一种前序遍历（preorder traversal）。具体来说，递归函数 <code>top_down(root, params)</code> 的工作方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. return specific value for null node</span><br><span class="line">2. update the answer if needed                      // answer &lt;-- params</span><br><span class="line">3. left_ans = top_down(root.left, left_params)      // left_params &lt;-- root.val, params</span><br><span class="line">4. right_ans = top_down(root.right, right_params)   // right_params &lt;-- root.val, params</span><br><span class="line">5. return the answer if needed                      // answer &lt;-- left_ans, right_ans</span><br></pre></td></tr></table></figure><p>例如，考虑以下问题：给定一棵二叉树，找到其最大深度。</p><p>我们知道根节点的深度为1。对于每个节点，如果我们知道其深度，我们将知道其子节点的深度。因此，如果在递归调用函数时将节点的深度作为参数传递，则所有节点都将知道其深度。对于叶节点，我们可以使用深度来更新最终答案。这是递归函数 <code>maximum_depth(root, depth)</code> 的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. return if root is null</span><br><span class="line">2. if root is a leaf node:</span><br><span class="line">3.      answer = max(answer, depth)         // update the answer if needed</span><br><span class="line">4. maximum_depth(root.left, depth + 1)      // call the function recursively for left child</span><br><span class="line">5. maximum_depth(root.right, depth + 1)     // call the function recursively for right child</span><br></pre></td></tr></table></figure><p>以下示例可帮助您了解其工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/abb8f5a44b799f9a77f817c9ddeffcf7.gif" alt="top-down-solution" /></p><p>Java 参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> answer;  <span class="comment">// don&#x27;t forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自下而上的解决方案">自下而上的解决方案</h1><p>“自底而上”是另一种递归解决方案。在每个递归调用中，我们将首先对所有子节点递归调用该函数，然后根据返回的值和当前节点本身的值得出答案。此过程可以视为一种后序遍历（postorder traversal）。通常，“自下而上”的递归函数 <code>bottom_up(root)</code> 将是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. return specific value for null node</span><br><span class="line">2. left_ans = bottom_up(root.left)          // call function recursively for left child</span><br><span class="line">3. right_ans = bottom_up(root.right)        // call function recursively for right child</span><br><span class="line">4. return answers                           // answer &lt;-- left_ans, right_ans, root.val</span><br></pre></td></tr></table></figure><p>让我们继续讨论有关最大深度的问题，但使用另一种思考方式：对于树的单个节点，以自身为根的子树的最大深度 <code>x</code> 将是多少？</p><p>如果我们知道以其左孩子为根的子树的最大深度 <code>l</code> 和以其右孩子为根的子树的最大深度 <code>r</code>，我们可以回答前面的问题吗？当然可以，我们可以选择它们之间的最大值，然后加1以获取根于当前节点的子树的最大深度。即 <code>x = max(l, r) + 1</code>。</p><p>这意味着对于每个节点，我们都可以在为其子节点解决问题后得到答案。因此，我们可以使用“自下而上”的解决方案来解决此问题。这是递归函数 <code>maximum_depth(root)</code> 的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. return 0 if root is null                 // return 0 for null node</span><br><span class="line">2. left_depth = maximum_depth(root.left)</span><br><span class="line">3. right_depth = maximum_depth(root.right)</span><br><span class="line">4. return max(left_depth, right_depth) + 1  // return depth of the subtree rooted at root</span><br></pre></td></tr></table></figure><p>以下示例可帮助您了解其工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d6ab88624ed4fe88ff2021306861e38a.gif" alt="bottom-up-solution" /></p><p>Java 参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// return 0 for null node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left_depth</span> <span class="operator">=</span> maximum_depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right_depth</span> <span class="operator">=</span> maximum_depth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;  <span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>理解递归并找到该问题的递归解决方案并不容易。它需要练习。</p><p>遇到树型问题时，请问自己两个问题：是否可以确定一些参数来帮助节点知道其答案？您可以使用这些参数和节点本身的值来确定将什么参数传递给它的子节点吗？如果答案都是肯定的，请尝试使用“自顶向下”递归解决方案来解决此问题。</p><p>或者，您可以通过这种方式思考问题：对于树中的某个节点，如果您知道其子节点的答案，可以计算该节点的答案吗？如果答案是肯定的，那么使用自下而上的方法递归解决问题可能是一个好主意。</p><p>在下面，我们为您提供了几个经典问题，以帮助您更好地理解树的结构和递归。</p><h1 id="二叉树节点定义">二叉树节点定义</h1><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="二叉树递归练习">二叉树递归练习</h1><h2 id="二叉树的最大深度">二叉树的最大深度</h2><p>给定二叉树，找到其最大深度。</p><p>最大深度是沿着从根节点到最远叶节点的最长路径的节点数。</p><p>注意：叶是没有子节点的节点。</p><p>例：给定二叉树[3,9,20,null,null,15,7]，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其深度 = 3</p><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="对称二叉树">对称二叉树</h2><p>给定一棵二叉树，检查它是否是其自身的镜像（即，围绕其中心对称）。</p><p>例如，此二叉树[1,2,2,3,4,4,3]是对称的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但[1,2,2,null,3,null,3]不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>递归和迭代地解决它。</p><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归地判断左右子树是否对称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r1 左子树根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r2 右子树根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recursive</span><span class="params">(TreeNode r1, TreeNode r2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (r1.val == r2.val) &amp;&amp; recursive(r1.left, r2.right) &amp;&amp; recursive(r1.right, r2.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代地判断树是否对称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">iterate</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span> || r1.val != r2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(r1.left);</span><br><span class="line">            queue.offer(r2.right);</span><br><span class="line">            queue.offer(r1.right);</span><br><span class="line">            queue.offer(r2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="comment">//        if (root == null) return true;</span></span><br><span class="line"><span class="comment">//        return recursive(root.left, root.right);</span></span><br><span class="line">        <span class="keyword">return</span> iterate(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.isSym(root, root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSym</span>(<span class="params">self, r1: TreeNode, r2: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">and</span> <span class="keyword">not</span> r2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">or</span> <span class="keyword">not</span> r2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r1.val == r2.val <span class="keyword">and</span> self.isSym(r1.left, r2.right)</span><br><span class="line">                <span class="keyword">and</span> self.isSym(r1.right, r2.left))</span><br></pre></td></tr></table></figure><h2 id="路径总和">路径总和</h2><p>给定一个二叉树和一个和，确定该树是否具有从根到叶的路径，以使该路径上的所有值加起来等于给定的和。</p><p>注意：叶是没有子节点的节点。</p><p>例：给定下面的二叉树，并且 <code>sum = 22</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure><p>返回true，因为存在从根到叶的路径 <code>5-&gt;4-&gt;11-&gt;2</code>，其总和为22。</p><p><strong>java 参考代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        cur += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> sum == cur;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) flag = hasPathSum(root.left, sum, cur);</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; root.right != <span class="literal">null</span>) flag = hasPathSum(root.right, sum, cur);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>python 参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (self.hasPathSum(root.left, <span class="built_in">sum</span> - root.val)</span><br><span class="line">                <span class="keyword">or</span> self.hasPathSum(root.right, <span class="built_in">sum</span> - root.val))</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/535/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/535/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/">https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的部分中，我们介绍了如何递归解决&lt;a href=&quot;https://wylu.me/posts/e85d694a&quot;&gt;树遍历&lt;/a&gt;问题。&lt;strong&gt;递归&lt;/strong&gt;是解决树问题的最强大，最常用的技术之一。&lt;/p&gt;
&lt;p&gt;众所周知，树可以递归定义为一个节点（根节点），该节点包含一个值和对子节点的引用列表。递归是树的自然特征之一。因此，许多树问题可以递归解决。对于每个递归函数调用，我们仅关注当前节点的问题，然后递归调用函数以解决其子级。&lt;/p&gt;
&lt;p&gt;通常，我们可以使用 &lt;strong&gt;自上而下&lt;/strong&gt; 的方法或 &lt;strong&gt;自下而上&lt;/strong&gt; 的方法递归地解决树问题。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="tree" scheme="https://wylu.me/categories/algorithm/tree/"/>
    
    
    <category term="二叉树" scheme="https://wylu.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="binary-tree" scheme="https://wylu.me/tags/binary-tree/"/>
    
    <category term="树" scheme="https://wylu.me/tags/%E6%A0%91/"/>
    
    <category term="递归" scheme="https://wylu.me/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="Recursion" scheme="https://wylu.me/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://wylu.me/posts/e85d694a/"/>
    <id>https://wylu.me/posts/e85d694a/</id>
    <published>2020-04-25T13:33:47.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>了解树和二叉树的相关概念；</p><p>理解不同遍历方法的工作原理，掌握相应遍历方法的递归和迭代实现；</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><span id="more"></span><h1 id="树和二叉树的概念">树和二叉树的概念</h1><p>树是模拟分层树结构的常用数据结构。</p><p>树的每个节点将具有一个根值和包含其它被称为子节点的引用列表。从图的角度来看，树也可以定义为具有 N 个节点和 N-1 个边的有向无环图。</p><p>二叉树是最典型的树结构之一。顾名思义，二叉树是一种树数据结构，其中每个节点最多具有两个孩子节点，分别称为左孩子和右孩子。</p><h1 id="二叉树节点定义">二叉树节点定义</h1><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="树的遍历">树的遍历</h1><p>本文的目的：</p><p>了解不同的树遍历方法之间的区别；</p><p>能够递归地解决前序，中序和后序遍历；</p><p>能够迭代解决前序，中序和后序遍历；</p><p>能够使用 BFS 进行分层遍历。</p><h2 id="前序遍历preorder-traversal">前序遍历(Preorder Traversal)</h2><p>前序遍历是首先访问根，然后遍历左子树，最后遍历右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/16a9e6b5c0d5b637a092b5a0879bef18.gif" alt="preorder-traversal" /></p><h3 id="例题">例题</h3><p>给定一个二叉树，返回其节点值的前序遍历序列。</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><h3 id="递归">递归</h3><h4 id="java">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 访问当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br></pre></td></tr></table></figure><h3 id="迭代">迭代</h3><h4 id="java-1">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.将根结点压入栈</span></span><br><span class="line"><span class="comment">     * 2.弹出栈顶结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="comment">     * 3.然后先将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 4.再将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="comment">// 先将右子树压入栈，以确保先遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="comment">// 将左子树压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-1">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行前序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.将根结点压入栈</span></span><br><span class="line"><span class="string">        2.弹出栈顶结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="string">        3.然后先将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        4.再将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 前序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="中序遍历inorder-traversal">中序遍历(Inorder Traversal)</h2><p>中序遍历是首先遍历左子树，然后访问根，最后遍历右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/861bb0ee8680a74d6e40c5d876271f54.gif" alt="inorder-traversal" /></p><p>通常，对于二叉搜索树，我们可以使用中序遍历以排序的顺序检索所有数据。</p><h3 id="例题-1">例题</h3><p>给定一个二叉树，返回其节点值的中序遍历序列。</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><h3 id="递归-1">递归</h3><h4 id="java-2">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 访问当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br></pre></td></tr></table></figure><h3 id="迭代-1">迭代</h3><h4 id="java-3">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.当前结点置为根结点</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点不为空，则将最左路径的所有结点压入栈中</span></span><br><span class="line"><span class="comment">     * 3.弹出栈顶结点作为当前结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="comment">     * 4.然后将当前结点置为当前结点的右子结点</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至当前结点为空且栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借助栈实现迭代中序遍历二叉树</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 确保先遍历未曾访问过的最左节点</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-3">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行中序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.当前结点置为根结点</span></span><br><span class="line"><span class="string">        2.如果当前结点不为空，则将最左路径的所有结点压入栈中</span></span><br><span class="line"><span class="string">        3.弹出栈顶结点作为当前结点，将结点值追加到结果序列的尾部</span></span><br><span class="line"><span class="string">        4.然后将当前结点置为当前结点的右子结点</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至当前结点为空且栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 中序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line"></span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="后序遍历postorder-traversal">后序遍历(Postorder Traversal)</h2><p>后序遍历是首先遍历左子树，然后遍历右子树，最后访问根。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a8f9ea34c137c0a579b69395328ba954.gif" alt="postorder-traversal" /></p><p>值得注意的是，当删除树中的节点时，删除过程应处于后序遍历状态。也就是说，删除节点时，先删除左节点，再删除右节点，然后再删除节点本身。</p><p>而且，后序在数学表达式中被广泛使用，编写程序来解析后序表达式会更容易。这是一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/4170d2a0e6bf349c5153f322f7bd050d.png" alt="mathematical-expression" /></p><p>你可以使用中序遍历轻松找出原始表达式，但是，程序要处理该表达式（中序表达式）并不容易，因为你必须检查操作的优先级。</p><p>如果按后序处理此树，则可以使用栈轻松处理表达式，每次遇到操作符时，只需从栈中弹出 2 个元素，计算结果并将结果推回栈中即可。</p><h3 id="例题-2">例题</h3><p>给定一个二叉树，返回其节点值的后序遍历序列。</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><h3 id="递归-2">递归</h3><h4 id="java-4">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">        <span class="comment">// 访问当前树的根结点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-4">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.recursiveTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.recursive(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cls, root: TreeNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        cls.recursive(root.left, res)</span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        cls.recursive(root.right, res)</span><br><span class="line">        <span class="comment"># 遍历当前树的根结点</span></span><br><span class="line">        res.append(root.val)</span><br></pre></td></tr></table></figure><h3 id="迭代-2">迭代</h3><h4 id="java-5">Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个辅助栈：</span></span><br><span class="line"><span class="comment">     * 1.将根结点压入栈</span></span><br><span class="line"><span class="comment">     * 2.弹出栈顶结点，将结点值插入结果序列的头部</span></span><br><span class="line"><span class="comment">     * 3.然后先将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 4.再将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后序遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.addFirst(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-5">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterateTraversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterateTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.iterate(root)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">cls, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代地进行后序遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        创建一个辅助栈：</span></span><br><span class="line"><span class="string">        1.将根结点压入栈</span></span><br><span class="line"><span class="string">        2.弹出栈顶结点，将结点值插入结果序列的头部</span></span><br><span class="line"><span class="string">        3.然后先将左子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        4.再将右子结点压入栈中（如果有）</span></span><br><span class="line"><span class="string">        5.重复步骤2、3、4，直至栈空</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            root (TreeNode): 树的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[int]: 后序遍历结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line"></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="层次遍历level-order-traversal">层次遍历(Level Order Traversal)</h2><p>层次遍历是逐级遍历树，每一层从左往右依次遍历结点。</p><p>广度优先搜索（Breadth-First Search）是一种遍历或搜索数据结构（如树或图）的算法。该算法从根节点开始，并首先访问该节点本身。然后遍历其邻居，遍历其第二级邻居，遍历其第三级邻居，依此类推。</p><p>当我们在树中进行广度优先搜索（BFS）时，我们访问的节点的顺序是层次遍历的顺序。</p><p>这是一个层次遍历的示例：</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/edf8dd3d276a32d86f8fff4428eebe6f.gif" alt="level-order-traversal" /></p><p>通常，我们使用队列来帮助我们进行BFS。</p><h3 id="例题-3">例题</h3><p>给定一个二叉树，返回其节点值的层次遍历序列。（即，从左到右，逐级）。</p><p><strong>Example:</strong></p><p>给定一棵二叉树 [3,9,20,null,null,15,7]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="java-6">Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用两个指针，curTail指向当前层的最右结点，nextTail指向下一层的最右结点；</span></span><br><span class="line"><span class="comment">     *   创建辅助队列，将根结点压入队列中</span></span><br><span class="line"><span class="comment">     * 2.如果当前结点的左子结点不为空，则左子结点入队列，并更新nextTail</span></span><br><span class="line"><span class="comment">     * 3.如果当前结点的右子结点不为空，则右子结点入队列，并更新nextTail</span></span><br><span class="line"><span class="comment">     * 4.如果当前结点已是当前层的最右结点，则将curTail更新为nextTail</span></span><br><span class="line"><span class="comment">     * 5.重复步骤2、3、4，直至队列空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 层次遍历结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curTail</span> <span class="operator">=</span> root, nextTail = <span class="literal">null</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">                nextTail = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">                nextTail = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur == curTail) &#123;</span><br><span class="line">                res.add(level);</span><br><span class="line">                level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                curTail = nextTail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python-6">python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        que = deque()</span><br><span class="line">        que.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            level, size = [], <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                root = que.popleft()</span><br><span class="line">                level.append(root.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    que.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    que.append(root.right)</span><br><span class="line"></span><br><span class="line">            ans.append(level)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/">https://leetcode.com/explore/learn/card/data-structure-tree/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/928/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/928/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/929/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/929/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/930/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/930/</a></p><p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/931/">https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/931/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解树和二叉树的相关概念；&lt;/p&gt;
&lt;p&gt;理解不同遍历方法的工作原理，掌握相应遍历方法的递归和迭代实现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;/li&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;li&gt;层次遍历&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://wylu.me/categories/algorithm/"/>
    
    <category term="tree" scheme="https://wylu.me/categories/algorithm/tree/"/>
    
    
    <category term="二叉树" scheme="https://wylu.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="前序遍历" scheme="https://wylu.me/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="中序遍历" scheme="https://wylu.me/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="后序遍历" scheme="https://wylu.me/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="层次遍历" scheme="https://wylu.me/tags/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>C函数指针的理解与使用</title>
    <link href="https://wylu.me/posts/184fc68/"/>
    <id>https://wylu.me/posts/184fc68/</id>
    <published>2020-04-14T15:14:32.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>通过一些具体例子，来深入理解并掌握函数指针的运用。</p><span id="more"></span><h1 id="c语言函数指针的理解与使用">C语言函数指针的理解与使用</h1><h2 id="函数指针的定义">函数指针的定义</h2><p>函数指针就是函数的指针。它是一个指针，指向一个函数。看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A) <span class="type">char</span>* (*fun1)(<span class="type">char</span>* p1, <span class="type">char</span>* p2);</span><br><span class="line">B) <span class="function"><span class="type">char</span>** <span class="title">fun2</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>;</span><br><span class="line">C) <span class="function"><span class="type">char</span>* <span class="title">fun3</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>;</span><br></pre></td></tr></table></figure><p>上面三个表达式分别什么意思？</p><ul><li><ol start="3" type="A"><li>这很容易，fun3是函数名，p1，p2是参数，其类型为 <code>char*</code> 型，函数的返回值为 <code>char*</code> 类型。</li></ol></li><li><ol start="2" type="A"><li>也很简单，与C）表达式相比，唯一不同的就是函数的返回值类型为 <code>char**</code>，是个二级指针。</li></ol></li><li><ol type="A"><li>fun1是函数名吗？回忆一下数组指针的定义：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*)[<span class="number">10</span>] p;</span><br></pre></td></tr></table></figure><p>这里 fun1 不是什么函数名，而是一个指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。同样，我们把这个表达式改写一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* (*)(<span class="type">char</span>* p1, <span class="type">char</span>* p2) fun1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数指针使用的例子">函数指针使用的例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun</span><span class="params">(<span class="type">char</span>* p1, <span class="type">char</span>* p2)</span></span>&#123;</span><br><span class="line">　　<span class="type">int</span> i = <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">　　<span class="keyword">if</span> (<span class="number">0</span> == i) <span class="keyword">return</span> p1;</span><br><span class="line">　　<span class="keyword">else</span> <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="type">char</span>* (*pf)(<span class="type">char</span>* p1, <span class="type">char</span>* p2); <span class="comment">//声明一个指向改函数的指针,未初始化</span></span><br><span class="line">　　pf = &amp;fun;</span><br><span class="line">　　(*pf) (<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>赋值方法 给函数指针赋值时，可以用 <code>&amp;fun</code> 或直接用函数名 fun。这是因为函数名被编译之后其实就是一个地址，所以这里两种用法没有本质的差别。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = fun;</span><br><span class="line">pf = &amp;fun;</span><br></pre></td></tr></table></figure></li><li><p>调用方法 可以直接使用指向函数的指针调用函数，无须提前解引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个等价调用</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">(*pf) (<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="built_in">fun</span>(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="intp-是什么"><code>*(int*)&amp;p</code> 是什么</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call Function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*p)();</span><br><span class="line">    *(<span class="type">int</span>*)&amp;p = (<span class="type">int</span>)function;</span><br><span class="line">    (*p)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>*(int*)&amp;p = (int)function;</code> 表示什么意思？先看这行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*p)();</span><br></pre></td></tr></table></figure><ul><li>这行代码定义了一个指针变量 p，p 指向一个函数，这个函数的参数和返回值都是 <code>void</code>。</li><li><code>&amp;p</code> 是求指针变量 p 本身的地址，这是一个32位的二进制常数（32位系统）。</li><li><code>(int*)&amp;p</code> 表示将地址强制转换成指向 int 类型数据的指针。</li><li><code>(int)function</code> 表示将函数的入口地址强制转换成 int 类型的数据。</li><li><code>*(int*)&amp;p = (int)function;</code> 表示将函数的入口地址赋值给指针变量 p。</li><li>那么 <code>(*p) ();</code> 就是表示对函数的调用。</li></ul><p>64位系统：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call Function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*p)();</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)&amp;p = (<span class="type">long</span> <span class="type">long</span>)function;</span><br><span class="line">    (*p)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="void-0-是什么"><code>(*(void(*) ())0) ()</code> 是什么</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="built_in">void</span>(*) ())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure><p>这是《C Traps and Pitfalls》书中的一个例子：</p><ul><li>第一步：<code>void(*) ()</code>，可以明白这是一个函数指针类型。这个函数没有参数，没有返回值。</li><li>第二步：<code>(void(*) ())0</code>，这是将0强制转换为函数指针类型，0是一个地址，也就是说一个函数存在首地址为0的一段区域内。</li><li>第三步：<code>(*(void(*) ())0)</code>，这是取0地址开始的一段内存里面的内容，其内容就是保存在首地址为0的一段区域内的函数。</li><li>第四步：<code>(*(void(*) ())0) ()</code>，这是函数调用。</li></ul><p>上面的例子再改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="type">char</span>**(*) (<span class="type">char</span>**, <span class="type">char</span>**))<span class="number">0</span>) (<span class="type">char</span>**, <span class="type">char</span>**);</span><br></pre></td></tr></table></figure><h2 id="使用函数指针的好处">使用函数指针的好处</h2><p>可以将实现同一功能的多个模块统一起来标识，这样一来更容易后期的维护，系统结构更加清晰。</p><p>归纳为：便于分层设计、利于系统抽象、降低耦合度以及使接口与实现分开。</p><h2 id="references">References</h2><p><a href="http://www.cnblogs.com/haore147/p/3647262.html">http://www.cnblogs.com/haore147/p/3647262.html</a></p><p><a href="https://www.cnblogs.com/huangzhenxiong/p/7772627.html">https://www.cnblogs.com/huangzhenxiong/p/7772627.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过一些具体例子，来深入理解并掌握函数指针的运用。&lt;/p&gt;</summary>
    
    
    
    <category term="programming-language" scheme="https://wylu.me/categories/programming-language/"/>
    
    <category term="c" scheme="https://wylu.me/categories/programming-language/c/"/>
    
    
    <category term="c" scheme="https://wylu.me/tags/c/"/>
    
    <category term="函数指针" scheme="https://wylu.me/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>wylu blog</title>
    <link href="https://wylu.me/posts/f6bd2bb1/"/>
    <id>https://wylu.me/posts/f6bd2bb1/</id>
    <published>2020-04-13T14:43:14.000Z</published>
    <updated>2022-11-23T15:43:27.703Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon"><h3 id="welcome-to-wylus-blog">Welcome to wylu's Blog</h3></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info no-icon&quot;&gt;&lt;h3 id=&quot;welcome-to-wylus-blog&quot;&gt;Welcome to wylu&#39;s Blog&lt;/h3&gt;
&lt;/div&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>应用密码学总结</title>
    <link href="https://wylu.me/posts/8ad7d8df/"/>
    <id>https://wylu.me/posts/8ad7d8df/</id>
    <published>2020-04-12T02:19:41.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>应用密码学学习总结，涉及密码学基本概念、古典密码、PGP安全电子邮件解决方案、对称加密、非对称加密、ElGamal密码体制、Diffie-Hellman密钥交换、数字签名等。</p><span id="more"></span><h1 id="概述">概述</h1><h2 id="信息安全的三个基本的目标">信息安全的三个基本的目标</h2><ul><li>保密性 Confidentiality 消息能够被安全的传送，即窃听者不能阅读发送的消息。</li><li>完整性 Integrity 消息的接收者应该能够验证在传递的过程中消息没有被修改；入侵者不能用假消息代替合法的消息。</li><li>可用性 Availability 即保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况。</li></ul><h2 id="数据的安全基于密钥的保密而不是算法的保密">数据的安全基于密钥的保密，而不是算法的保密</h2><h2 id="公钥密码使得无密钥传输的保密通信成为可能">公钥密码使得无密钥传输的保密通信成为可能</h2><h2 id="密码学的基本概念">密码学的基本概念</h2><p>密码学(Cryptology)：研究信息系统安全技术的科学。它包含两个分支：</p><ul><li>密码编码学(Cryptography)，对信息进行编码实现隐蔽信息的一门学问</li><li>密码分析学(Cryptanalysis)，研究分析破译密码或伪造的学问。 两者相互对立，而又互相促进地向前发展。</li></ul><h2 id="密码算法分类-i">密码算法分类-I</h2><p>按照保密性依赖的基础分为:</p><ul><li>受限制的（Restricted)算法: 算法的保密性基于保持算法的秘密。</li><li>基于密钥（Key-based)的算法: 算法的保密性基于对密钥的保密。</li></ul><h2 id="密码算法分类-ii">密码算法分类-II</h2><p>按照密钥的特点分为：</p><ul><li>对称密码算法（Symmetric Cipher)：就是加密密钥和解密密钥相同，或实质上等同，即从一个易于推出另一个。又称秘密密钥算法或单密钥算法。 对称密钥密码又可分为流密码和分组密码<ul><li>分组密码每次对一块数据(Block)加密例子：DES, IDEA, RC6, Rijndael</li><li>流密码每次对一位或一字节加密例子：One-time padding, Vigenére, Vernam</li></ul></li><li>非对称密钥算法（Asymmetric Cipher)：加密密钥和解密密钥不相同，从一个很难推出另一个。又称公钥密钥算法（Public-key Cipher) 。</li></ul><h1 id="数论基础">数论基础</h1><h2 id="互素">互素</h2><p>如果a,b的最大公约数为1，则称a,b互素。(注. (a,b)表示a,b的最大公约数) (3,5)=1 a,b互素，a,b不一定是素数，例如(9,4)=1</p><h2 id="模运算">模运算</h2><h3 id="模加法">模加法</h3><p>(a + b) mod m = ((a mod m) + (b mod m)) mod m 例: (11 + 15) mod 8 = ((11 mod 8) + (15 mod 8)) mod 8 = (3 + 7) mod 8 = 10 mod 8 = 2</p><h3 id="模减法">模减法</h3><p>(a - b) mod m = ((a mod m) - (b mod m)) mod m 例: (15 - 1) mod 7 = ((15 mod 7) - (1 mod 7)) mod 7 = (1 - 1) mod 7 = 0 mod 7 = 0</p><h3 id="模乘法">模乘法</h3><p>(a × b) mod m = ((a mod m) × (b mod m)) mod m 例: (7 × 9) mod 8 = ((7 mod 8) × (9 mod 8)) mod 8 = (7 × 1) mod 8 = 7 mod 8 = 7</p><h2 id="逆元">逆元</h2><h3 id="加法逆元">加法逆元</h3><p>x的加法逆元y是满足x + y ≡ 0 mod m的数 例: 2 + 6 ≡ 0 mod 8, 6和2互为模8的加法逆元</p><h3 id="乘法逆元">乘法逆元</h3><p>x的乘法逆元y是满足x × y ≡ 1 mod m 数。 例：2 × 4 ≡ 1 mod 7，2和4互为模7的乘法逆元</p><h3 id="如果m是一个素数则对每一个0xm-都存在乘法逆元">如果m是一个素数，则对每一个0&lt;x&lt;m, 都存在乘法逆元</h3><p>例： 1 × 1 ≡1 mod 7 2 × 4 ≡1 mod 7 3 × 5 ≡1 mod 7 4 × 2 ≡1 mod 7 5 × 3 ≡1 mod 7 6 × 6 ≡1 mod 7 ​ …</p><h3 id="一个定理">一个定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设a, b, c是任意三个不全为零的整数,且</span><br><span class="line">                     a= bq + r                      (1)</span><br><span class="line">其中q是整数, 则(a, b)=(b, r).</span><br><span class="line">对(1)进一步地约束，令b&gt;0,将a除以b所得的商记为q, 余数为r , 则(1)成为</span><br><span class="line">                     a= bq + r, 0&lt;=r&lt;b              (2)</span><br><span class="line">r是a对模b的非负最小剩余。</span><br><span class="line">进一步 (a, b)=(|a|, |b|)=(b, a)</span><br><span class="line">由此我们得到求(a, b)的Euclid辗转相除法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3f15c8e84962d30760085229d67a8a60.png" alt="Euclid" /></p><h3 id="解一次同余式">解一次同余式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个定理:</span><br><span class="line">若 (a, m) = 1, 则一次同余式</span><br><span class="line">                 ax ≡ b (mod m)</span><br><span class="line">有唯一解</span><br><span class="line">例：19x ≡ 1(mod 48)</span><br><span class="line">因为(19, 48) = 1, 所以一次同余式有唯一解，即19对于模48的有唯一逆元。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/c75b8f5ca55cf1486266f36d7e76e924.png" alt="Solve a congruence" /></p><h1 id="古典密码">古典密码</h1><h2 id="单表密码体制">单表密码体制</h2><p>如果明文中不同的位置的同一明文字母在密文中对应的密文字母相同,则称其为单表密码体制。</p><ul><li>乘法密码算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/3dd17f64de84a1c8ce3402f340d4ee36.png" alt="Multiplication cryptographic algorithm" /></p><ul><li>仿射密码算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/084606049081d419d0a7a927a5973eed.png" alt="Affine cryptographic algorithm" /></p><ul><li>语言的统计特性：频率特征；连接特征；重复特征</li></ul><h2 id="多表密码体制">多表密码体制</h2><p>如果明文中不同的位置的同一明文字母在密文中对应的密文字母不同,则称其为多表密码体制。</p><h1 id="安全电子邮件方案">安全电子邮件方案</h1><h2 id="pgp产生的背景">PGP产生的背景</h2><p>你的电子邮件不安全，电子邮件在传输中使用的SMTP协议。</p><ul><li>无法保证邮件在传输过程中不被人偷看。</li><li>无法确认来源。</li><li>无法确定邮件是否在传输过程中被篡改</li><li>当邮件被发到错误地址，可能造成信息泄露</li></ul><h2 id="pgp提供了一个安全电子邮件解决方案">PGP提供了一个安全电子邮件解决方案</h2><p>PGP (Pretty Good Privacy) 具有以下的功能</p><ul><li>消息加密</li><li>数字签名</li><li>完整性确认</li><li>数据压缩</li></ul><h3 id="pgp加密流程">PGP加密流程</h3><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b09aa8d21c3db8c63e087bfa93020877.png" alt="PGP encrypt" /></p><h3 id="pgp解密流程">PGP解密流程</h3><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/154124f32894f962838c70977cabdb26.png" alt="PGP decrypt" /></p><h3 id="pgp整合了对称加密和公钥加密的方案">PGP整合了对称加密和公钥加密的方案</h3><ul><li>保持了对称加密算法速度快的特点</li><li>具有公钥算法密钥分配方便的特点</li></ul><h2 id="pgp数字签名和hash函数">PGP数字签名和Hash函数</h2><p>直接对明文进行数字签名一些问题</p><ul><li>速度非常慢</li><li>生成大量的数据</li></ul><p>PGP的解决方案</p><ul><li>对明文使用一种Hash函数, 产生定长的数据, 称为消息摘要</li><li>PGP使用签名算法对摘要签名</li><li>PGP将签名和明文一同传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e6d41a3a99acd12139a2e0614676f81a.png" alt="PGP digital signature" /></p><h2 id="公共密钥分发和证明模型">公共密钥分发和证明模型</h2><h3 id="金字塔模型">金字塔模型</h3><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b1237f6ee63cf73edcde1c110fbf3476.png" alt="pyramid model" /></p><h3 id="直接信任模型">直接信任模型</h3><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/15201e23f3b4a7444812eca45aeebec8.png" alt="direct trust model" /></p><h3 id="信任网络">信任网络</h3><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/eeadb6d1e2d99037708952168a9f2d54.png" alt="trust network" /></p><h1 id="对称密码">对称密码</h1><h2 id="aes的若干要求和评估准则">AES的若干要求和评估准则</h2><ul><li>AES的基本要求：比DES快而且比DES安全，分组长度为128比特，密钥长度为128／192（超56比特）。</li><li>安全性评估：算法输出的随机性好，抗密码分析能力强，并且有可靠的数学基础。</li><li>成本估计准则：许可成本低，在各种平台上的计算高效率和较小的内存空间需求。</li><li>算法和实现特性准则：灵活性、硬件和软件适用性、算法的简明性。</li></ul><p>具体体现为：</p><ul><li>算法处理的密钥和分组长度必须具备灵活的支持范围；</li><li>算法在许多不同类型的环境下能够安全和有效地实现；</li><li>可以作为序列密码、哈希算法实现；</li><li>算法必须能够用软件和硬件两种方法实现，并且有利于有效的固件实现；</li><li>算法设计相对简单。</li></ul><h2 id="分组密码的填充与模式">分组密码的填充与模式</h2><p>（1）什么是填充，为什么需要填充</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f9013eaf183c39051322642f6ec35092.png" alt="padding" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a23e6ca46cd8f962fd8c8d3ea7c0b583.png" alt="no padding" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/498dab03a71688c382b722bcd0a0aede.png" alt="PKCS#5 padding" /></p><p>（2）什么是模式，为什么需要模式</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/03baa2362ee7ab6bb28622469c0fd4ad.png" alt="mode" /></p><p><strong>分组密码工作模式的应用背景</strong>：多次使用相同的密钥对多个分组加密，会引发许多安全问题。为了应对不同场合，因而需要开发出不同的工作模式来增强密码算法的安全性。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dce657af901a9be8a4c9ead487a94351.png" alt="group work mode" /></p><ul><li><p>ECB模式</p><p>特别适合数据较少的情况，对于很长的信息或者具有特定结构的信息（对ECB模式分组重放攻击），其大量重复的信息或固定的字符开头将给密码分析者提供大量的已知明密文对。若明文不是完整的分组，ECB需要进行填充。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/6d27b31840c3008c7c001b839233f4f2.png" alt="ECB" /></p><p>ECB模式的特点</p><ul><li>简单</li><li>有利于并行</li><li>计算误差不会被传递</li><li>不能隐藏明文的模式</li><li>可能对明文进行主动攻击</li></ul></li><li><p>CBC模式</p><p>由于加密算法的每次输入和本明文组没有固定的关系，因此就算有重复的明文组，加密后也看不出来了。为了配合算法的需要，有一个初始向量（IV）。与ECB一样有填充机制以保证完整的分组。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/ad096cfd9871a0ecdc00178942d7058a.png" alt="CBC" /></p><p>CBC的特点</p><ul><li>不容易主动攻击</li><li>不利于并行</li><li>计算误差传递</li><li>需要初始向量IV</li></ul><p>安全性好于ECB, 适合传输长度长的报文,是SSL, IPSec的标准</p></li><li><p>CFB模式</p><p>和OFB，CTR模式一样，均可将分组密码当做流密码（实际是将分组大小任意缩减）使用。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/86465767a9c0e7b63a53b490a9d6cdff.png" alt="CFB" /></p><p>CFB模式的特点</p><ul><li>隐藏了明文模式</li><li>分组密码转化为流模式</li><li>可以及时加密传输小于分组的数据</li><li>不利于并行计算</li><li>误差传递：一个明文单元损坏影响多个单元唯一的ＩＶ</li></ul></li><li><p>OFB模式</p><p>OFB的结构与CFB很相似，它用加密函数的输出填充移位寄存器，而CFB是用密文单元来填充移位寄存器。其他的不同是，OFB模式是对整个明文和密文分组进行运算，而不是仅对s位的子集运算，因而不至于浪费运算能力。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/95e95626263bd7b21a1fd7ef6a5a699e.png" alt="OFB" /></p><p>OFB模式的特点</p><ul><li>隐藏了明文模式</li><li>分组密码转化为流模式</li><li>可以及时加密传输小于分组的数据</li><li>不利于并行计算</li><li>对明文的主动攻击是可能的</li><li>误差传递：一个单元损坏只损坏对应单元</li><li>唯一的ＩＶ</li></ul><p>安全性于不如CFB</p></li></ul><h2 id="流密码">流密码</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/671d5585286d828bae248bbc87f1dac4.png" alt="vernam" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b5c90a3f672b9ff2547750220f26f073.png" alt="linear feedback shift register" /></p><h2 id="随机位的测试">随机位的测试</h2><ul><li>单个位测试(monobit test) 目的：校验1和0的个数是否大致相等。</li><li>扑克牌测试(poker test) 目的： 测试0至15的分布的随机随机性</li><li>连续串测试 目的：测试连续串长度分布的随机性</li></ul><h1 id="单向散列函数">单向散列函数</h1><h2 id="性质">性质</h2><ul><li>h(x)的输入x为任意长度</li><li>h(x)的输出长度固定</li><li>h(x)的计算方便快捷</li><li>h(x)的计算具有单向性</li><li>对于给定 x, 找到 y != x, 且 h(y) = h(x) 在计算不可行</li></ul><h2 id="应用">应用</h2><p>（1）使用Hash函数进行完整性验证的模型</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1fb4b778d7cd76503d1ca6c6548b03d.png" alt="check integrity by hash" /></p><p>（2）PGP的公钥真实性验证</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/96d0427d8cd4ed4256a083ac85ecfde7.png" alt="PGP public key verify" /></p><h2 id="碰撞">碰撞</h2><p>如果 y != x, 且 h(x) = h(y), 则称为碰撞 对给定的 x, 要找到一个 y 满足 y != x, h(x) = h(y) 在计算上不可行, 则称为弱无碰撞 要找到任意一对数 x,y, y != x, 满足 h(x) = h(y), 在计算上不可行, 则称为强无碰撞(包含弱无撞)</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/87b98ae5aff37e728c5e5d17c452cb40.png" alt="hash collision" /></p><h2 id="对数字签名的生日攻击">对数字签名的生日攻击</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/d7008582105ce8d2542314a8e7bc4fc1.png" alt="birthday attack" /></p><h1 id="不对称密码">不对称密码</h1><h2 id="公钥密码的特性">公钥密码的特性</h2><ul><li>特性一：加密和解密使用不同的钥匙</li><li>特性二：从一个钥匙推出另一个钥匙在计算上不可行</li><li>特性三：每个钥匙都可以做加密和解密</li></ul><h2 id="rsa算法">RSA算法</h2><p>RSA算法可用于加密、又可用于数字签字，易懂且易于实现，是目前仍然安全并且逐步被广泛应用的一种体制。</p><h2 id="euler函数">Euler函数</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/43af4c780145132ce7e8c6716b20920e.png" alt="Euler function" /></p><h2 id="euler定理">Euler定理</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/29d401af406d98301da457fc64798f54.png" alt="Euler theorem" /></p><h2 id="rsa密钥对生成步骤">RSA密钥对生成步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/f765b45da28bc037280f9b0d0d1d0b88.png" alt="RSA key pair generation" /></p><h2 id="rsa加密和解密步骤">RSA加密和解密步骤</h2><p>加密消息前，首先将它分成比n小的数据分组，再对每个分组加密</p><ul><li>加密： <span class="math inline">\(C=M^e(mod\ n)\)</span></li><li>解密： <span class="math inline">\(M=C^d(mod\ n)\)</span></li></ul><h2 id="rsa密钥对生成实例">RSA密钥对生成实例</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/424075aa423829a0391a98bcc853b3dd.png" alt="RSA key pair generation example" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a524e12cd4e5320bdbea37769d0795a1.png" alt="RSA encrypt and decrypt example" /></p><h2 id="rsa的缺点">RSA的缺点</h2><p>受到素数产生技术的限制，产生密钥很麻烦。 分组长度太大，为保证安全性，n 至少也要 600比特以上，使运算代价很高，尤其是速度较慢；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化</p><h2 id="当pq比较接近的数分解攻击">当p,q比较接近的数分解攻击</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/e1b350b3af660b9676912058b43da4e8.png" alt="decomposition attack 1" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/cb81f1e0fdca6c4789cbfa2c582f86ea.png" alt="decomposition attack 2" /></p><h2 id="选择明文攻击">选择明文攻击</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/44f805ba13c49f0c8804035da24accc1.png" alt="select plaintext attack" /></p><p>从算法上无法解决这一问题，主要措施是采用好的公钥协议：</p><ul><li>工作过程中实体不轻易对其他实体任意产生的信息加解密，不对自己一无所知的信息签名</li><li>对其他实体送来的随机文档签名时首先对文档作HASH处理</li></ul><h1 id="elgamal密码体制">ElGamal密码体制</h1><p>由ElGamal[1984,1985]提出，是一种基于离散对数问题的双钥密码体制，既可用于加密，又可用于签字。</p><h2 id="elgamal密钥对生成步骤">ElGamal密钥对生成步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/dfa9e6d2c54c514935d282d21d6bb40f.png" alt="ElGamal key pair gen" /></p><h2 id="elgamal加密和解密步骤">ElGamal加密和解密步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/bfc9dfa2e3d1a45ea98ed8deb13204b9.png" alt="ElGamal encrypt and decrypt" /></p><h2 id="elgamal密钥对生成例子">ElGamal密钥对生成例子</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/b346d1cfd0a6c7e3c07a2b098197d9f4.png" alt="ElGamal key pair gen example" /></p><h2 id="elgamal加密和解密例子">ElGamal加密和解密例子</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a1b84050c50736c456c11f9d727f072a.png" alt="ElGamal encrypt and decrypt example" /></p><h1 id="diffie-hellman密钥交换">Diffie-Hellman密钥交换</h1><p>密钥交换方案:允许两个用户可以安全地建立一个秘密信息，用于后续的通讯过程 算法的安全性依赖于:有限域上计算离散对数的难度</p><h2 id="dh密钥匙方案实现步骤">DH密钥匙方案实现步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7f49ca12367df14dd0ea2b488fc97910.png" alt="DH key exchange" /></p><h2 id="dh密钥匙交换方案实现例子">DH密钥匙交换方案实现例子</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c5a06b231c6c9c9c179d34d3b245ea1.png" alt="DH key exchange example" /></p><h2 id="dh密钥匙方案的第三者攻击方法">DH密钥匙方案的第三者攻击方法</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/87303aed7496f9dafae44487a9aa1d89.png" alt="DH third party attack" /></p><p>第三者攻击的方法的为什么可以成功呢? 问题在于：A和B在不安全的信道上通信, 那么双方如何能够知道通信的另一方的到底是谁呢? 是否能设计一种可以确认通信双方身份的DH密钥交换方案呢?</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8c0c85ce951daa2fb2b8fa057c29debb.png" alt="DH key exchange with identity auth" /></p><h1 id="数字签名">数字签名</h1><h2 id="rsa签名方案">RSA签名方案</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a8043e86475699d1aa460dba9191fca7.png" alt="RSA signature" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/7c232e619e9ac36d6f139d942db9901e.png" alt="RSA signature example" /></p><h2 id="elg签名方案">ELG签名方案</h2><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/faf924b5fdfa67b4fe0e78afc1151076.png" alt="ELG signature" /></p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/8b85c54a331eac1c619bd48f4bed5c5a.png" alt="ELG signature example" /></p><h1 id="实验02">实验02</h1><p>（1）使用PGP软件，产生一对新的公钥/私钥，并在PGP服务器上注册</p><p>思考：为什么不是由服务器统一产生公钥/私钥对呢，而是由客户端产生钥匙对呢？注册完成后，公钥/私钥存放在什么地方呢？私钥需要什么样的保护措施吗？</p><ul><li>公钥/私钥对不由任一政府或标准化组织所控制，使得PGP得到广泛信任，能够满足商业化的需求。</li><li>在服务器上注册后，公钥存放在服务器上，私钥则由使用者自己保存。</li><li>使用口令密码对私钥加密存储，口令密码方便记忆，也可以保护私钥。</li></ul><p>（2）邀请其他使用者互相签署对方的公钥</p><p>思考：此步骤的意义是什么？在签署他人的公钥前，应该注意什么？</p><ul><li>相互签署公钥用于建立信任体系，信任对方公钥是指定实体的合法公钥。</li><li>需要确认所签署公钥是指定实体的合法公钥，可行的方法有：物理上得到对方的公钥，这种方式最可靠，但有一定局限性；通过电话验证公钥；从双方都信任的第三方处获得对方公钥。</li></ul><p>（3）使用ASCII编码格式将自己的公钥发给其他使用者</p><p>思考：这样在整个PGP信任体系中的意义是什么？</p><ul><li>向信任的朋友发送公钥和接收信任朋友传送来的公钥，一般这些公钥都带有签名，在这种方式下，用户可以自行决定对周围的联系人是否信任，建立以个人为中心的信任模型。</li></ul><p>（4）发送加密及签名的电子邮件</p><p>思考: 加密时使用了谁的、哪一把钥匙；签名时又使用了谁的、哪一把钥匙？邮件是否一定要同时加密和签名呢？邮件的长度是可变的，但数字签名的数据长度似乎是定长，这是为什么？</p><ul><li>加密时使用了接收者的公钥</li><li>签名时使用了发送者的私钥</li><li>邮件不一定要同时加密和签名</li><li>实际上，sign &amp; verify 是利用 hash function 及非对称加密的技术来达到确认文件来源及文件内容是没被更改过的，而hash value的长度是由不同的hash function决定的，常见的hash function有MD2, MD5, SHA-1, SHA-128, SHA-256, SHA-512</li></ul><p>（5）收到他人的加密及签名的电子邮件后，解密并验证其签名的正确性</p><p>思考：解密时使用了谁的、哪一把钥匙；验证签名时又使用了谁的、哪一把钥匙？</p><ul><li>解密时使用了接收者的私钥</li><li>验证签名时使用了发送者的公钥</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用密码学学习总结，涉及密码学基本概念、古典密码、PGP安全电子邮件解决方案、对称加密、非对称加密、ElGamal密码体制、Diffie-Hellman密钥交换、数字签名等。&lt;/p&gt;</summary>
    
    
    
    <category term="cs" scheme="https://wylu.me/categories/cs/"/>
    
    <category term="cryptography" scheme="https://wylu.me/categories/cs/cryptography/"/>
    
    
    <category term="cryptography" scheme="https://wylu.me/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Nginx configuration for CodeIgniter</title>
    <link href="https://wylu.me/posts/ec244fdf/"/>
    <id>https://wylu.me/posts/ec244fdf/</id>
    <published>2020-04-04T08:58:27.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx server configuration for CodeIgniter</p><span id="more"></span><h1 id="my-environment">My Environment</h1><ul><li><strong>System:</strong> CentOS 7</li><li><strong>Web Server:</strong> Nginx v1.17.2</li><li><strong>Application Server:</strong> php-fpm (based on PHP 7.2)</li><li><strong>Web Framework:</strong> CodeIgniter v3.1.10</li></ul><h1 id="deploy-codeigniter-project">Deploy CodeIgniter project</h1><p>First, Goto <a href="https://www.codeigniter.com/download">Official website</a> and download CodeIgniter.</p><p>Then, create a folder named <code>ci</code> in the root directory of the nginx server and extract the CodeIgniter framework code into this directory. As follow:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@xyz html]# pwd</span><br><span class="line">/usr/share/nginx/html</span><br><span class="line">[root@xyz html]# tree -L 1 ci</span><br><span class="line">ci</span><br><span class="line">├── application</span><br><span class="line">├── composer.json</span><br><span class="line">├── contributing.md</span><br><span class="line">├── index.php</span><br><span class="line">├── license.txt</span><br><span class="line">├── readme.rst</span><br><span class="line">├── system</span><br><span class="line">└── user_guide</span><br><span class="line"></span><br><span class="line">3 directories, 5 files</span><br><span class="line">[root@xyz html]#</span><br></pre></td></tr></table></figure><p>The path <code>/usr/share/nginx/html</code> is the default static files path of nginx in my machine. You can use any other path actually. Just for simple, my goal to test the nginx server configuration.</p><h1 id="edit-nginx-server-configuration">Edit Nginx server configuration</h1><p>Edit nginx default configuration file named <code>default.conf</code>, which is in <code>/etc/nginx/conf.d</code>.</p><p>I highly recommend you back up before changing the server configuration.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /ci &#123;</span><br><span class="line">        try_files $uri $uri/ /ci/index.php?/$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    location ~ /\.ht &#123;</span><br><span class="line">        deny  all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="test">Test</h1><p><strong>My codeigniter folder is <code>ci</code> which is located in <code>/usr/share/nginx/html/ci</code>.</strong></p><ul><li><p>default controller</p><p><code>http://yourdomain/ci/index.php/</code></p><p><code>http://yourdomain/ci/index.php/welcome</code></p><p>The effect of these two urls is the same. They all execute the <code>index</code> function of <code>Welcome</code> controller in <code>Welcome.php</code> file.</p></li><li><p>custom controller</p><p>Create a file named <code>Test.php</code> in <code>application/controllers</code> directory and edit it as follow:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Test Controller index!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello CodeIgniter!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Restart service and test:</p><p><code>http://yourdomain/ci/index.php/Test/</code></p><p><code>http://yourdomain/ci/index.php/Test/hello</code></p><p>All these work well.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx server configuration for CodeIgniter&lt;/p&gt;</summary>
    
    
    
    <category term="programming-language" scheme="https://wylu.me/categories/programming-language/"/>
    
    <category term="php" scheme="https://wylu.me/categories/programming-language/php/"/>
    
    
    <category term="CodeIgniter" scheme="https://wylu.me/tags/CodeIgniter/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB分片集群搭建</title>
    <link href="https://wylu.me/posts/e54730f4/"/>
    <id>https://wylu.me/posts/e54730f4/</id>
    <published>2020-04-04T08:17:04.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>在如今的互联网环境下，海量数据已随处可见并且还在不断增长，对于如何存储处理海量数据，比较常见的方法有两种：</p><ul><li><strong>垂直扩展</strong>：通过增加单台服务器的配置，例如使用更强悍的 CPU、更大的内存、更大容量的磁盘，此种方法虽然成本很高，但是实现比较简单，维护起来也比较方便。</li><li><strong>水平扩展</strong>：通过使用更多配置一般的服务器来共同承担工作负载，此种方法很灵活，可以根据工作负载的大小动态增减服务器的数量，但是实现比较复杂，得有专门的人员来运维。</li></ul><p>MongoDB 支持通过分片技术从而进行水平扩展，用以支撑海量数据集和高吞吐量的操作。如果数据集不够大，还是建议您使用 <a href="https://docs.mongodb.com/manual/replication/">MongoDB 副本集</a>，因为分片需要处理更多的技术细节，所以在分片环境下其性能可能始终没有副本集性能强。本文通过介绍如何搭建 MongoDB 分片集群以及及一些相关核心概念，可以帮您快速理解 MongoDB 是如何通过分片技术来处理海量数据的。</p><span id="more"></span><h1 id="分片集群组件">分片集群组件</h1><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/29228540b81791a13235d9e8e5cf3d2c.svg" alt="sharded cluster" /></p><p>MongoDB 分片集群（参考官方文档 <a href="https://docs.mongodb.com/manual/sharding/">Sharded Cluster</a>）由以下三个组件构成，缺一不可：</p><ul><li>mongos：数据库集群请求的入口，所有的请求都通过 mongos 进行协调，不需要在应用程序添加一个路由选择器，mongos 自己就是一个请求分发中心，它负责把对应的数据请求请求转发到对应的 shard 服务器上。在生产环境通常有多 mongos 作为请求的入口，防止其中一个挂掉所有的 mongodb 请求都没有办法操作。</li><li>config server：顾名思义为配置服务器，存储所有数据库元信息（路由、分片）的配置。mongos 本身没有物理存储分片服务器和数据路由信息，只是缓存在内存里，配置服务器则实际存储这些数据。mongos 第一次启动或者关掉重启就会从 config server 加载配置信息，以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态，这样 mongos 就能继续准确路由。从 MongoDB 3.4 开始，必须将配置服务器部署为副本集（CSRS，全称是 Config Servers Replica Set），因为它存储了分片路由的元数据，防止数据丢失！</li><li>shard，分片（sharding）是指将数据库拆分，将其分散在不同的机器上的过程，每个分片是整体数据的子集，且都可以部署为副本集。将数据分散到不同的机器上，不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。基本思想就是将集合切成小块，这些块分散到若干片里，每个片只负责总数据的一部分，最后通过一个均衡器来对各个分片进行均衡（数据迁移）。</li></ul><p>其它名词概念：</p><ul><li>replica set：中文翻译副本集，其实就是 shard 的备份，防止 shard 挂掉之后数据丢失。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</li><li>仲裁者（Arbiter）：是复制集中的一个 MongoDB 实例，它并不保存数据。仲裁节点使用最小的资源并且不要求硬件设备，不能将 Arbiter 部署在同一个数据集节点中，可以部署在其他应用服务器或者监视服务器中，也可部署在单独的虚拟机中。为了确保复制集中有奇数的投票成员（包括 primary），需要添加仲裁节点做为投票，否则 primary 不能运行时不会自动切换 primary。</li></ul><p>简单了解之后，我们可以这样总结一下，应用请求 mongos 来操作 mongodb 的增删改查，配置服务器存储数据库元信息，并且和 mongos 做同步，数据最终存入在 shard（分片）上，为了防止数据丢失同步在副本集中存储了一份，仲裁在数据存储到分片的时候决定存储到哪个节点。</p><h1 id="sharded-key-分片键">Sharded Key 分片键</h1><p>MongoDB 通过定义 shared key（分片键）从而对整个集合进行分片，分片键的好坏直接影响到整个集群的性能。另外需要注意的是，一个集合只有且只能有一个分片键，一旦分片键确定好之后就不能更改。分片键分为以下两种类型：</p><ul><li><strong>基于 Hashed 的分片</strong>：MongoDB 会计算分片键字段值的哈希值，用以确定该文档存于哪个 chunk，从而达到将集合分摊到不同的 chunk。此种类型能够使得数据整体分布比较均匀，对于等值查询效率很高，但是对于范围查询效率就比较低，因为可能要扫描所有的分片才能获取到数据。</li><li><strong>基于 Ranged 的分片</strong>：MongoDB 会将相似的值放到一个 chunk 中，所以说如果在查询的时候带上分片键的范围条件，查询效率会非常高，因为不需要扫描所有的分片就可以定位到数据。注意，如果片键的值为单调递增或单调递减，那么不适合采用该分片策略，因为数据总会写到一个分片，从而没有很好地分散 IO。</li></ul><p>分片键的类型需要根据实际的业务场景决定，例如有张非常大的用户表，用户表里有用户 ID 字段，每次查询的时候都会带上用户 ID，如果想对该用户表进行分片，可以选择将用户 ID 字段作为 shard key，并且分片键类型可以使用基于 Hashed 的分片。</p><h1 id="chunk-块">Chunk 块</h1><p><strong>chunk</strong>（块）是均衡器迁移数据的最小单元，默认大小为 64MB，取值范围为 1-1024MB。一个块只存在于一个分片，每个块由片键特定范围内的文档组成，块的范围为左闭又开即 <code>[start,end)</code>。一个文档属于且只属于一个块，当一个块增加到特定大小的时候，会通过拆分点（split point）被拆分成 2 个较小的块。在有些情况下，chunk 会持续增长，超过 ChunkSize，官方称为 <a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/Maximum-Number-of-Documents-Per-Chunk-to-Migrate">jumbo chunk</a>，该块无法被 MongoDB 拆分，也不能被均衡器迁移，故久而久之会导致 chunk 在分片服务器上分布不均匀，从而成为性能瓶颈，表现之一为 insert 数据变慢。</p><h2 id="chunk-的拆分">Chunk 的拆分</h2><p>mongos 会记录每个块中有多少数据，一旦达到了阈值就会检查是否需要对其进行拆分，如果确实需要拆分则可以在配置服务器上更新这个块的相关元信息。</p><p>chunk 的拆分过程如下：</p><ol type="1"><li>mongos 接收到客户端发起的写请求后会检查当前块的拆分阈值点。</li><li>如果需要拆分，mongos 则会像分片服务器发起一个拆分请求。</li><li>分片服务器会做拆分工作，然后将信息返回 mongos。</li></ol><p>注意，相同的片键只能保存在相同的块中，如果一个相同的片键过多，则会导致一个块过大，成为 jumbo chunk，所以具有不同值的片键很重要。</p><h2 id="chunk-的迁移过程"><a href="https://docs.mongodb.com/manual/core/sharding-balancer-administration/">Chunk 的迁移过程</a></h2><ol type="1"><li>均衡器进程发送 <code>moveChunk</code> 命令到源分片。</li><li>源分片使用内部 <code>moveChunk</code> 命令，在迁移过程，对该块的操作还是会路由到源分片。</li><li>目标分片构建索引。</li><li>目标分片开始进行数据复制。</li><li>复制完成后会同步在迁移过程中该块的更改。</li><li>同步完成后源分片会连接到配置服务器，使用块的新位置更新集群元数据。</li><li>源分片完成元数据更新后，一旦块上没有打开的游标，源分片将删除其文档副本。</li></ol><p>迁移过程可确保一致性，并在平衡期间最大化块的可用性。</p><h2 id="chunk-迁移的阈值">Chunk 迁移的阈值</h2><p>为了最大程度地减少平衡对集群的影响，平衡器仅在分片集合的块分配达到某些阈值之后才开始平衡。阈值适用于集合中具有最多块的 shard 与该集合中具有最少块的 shard 之间的块数差异。平衡器具有以下阈值：</p><table><thead><tr class="header"><th style="text-align: left;">Number of Chunks</th><th style="text-align: left;">Migration Threshold</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Fewer than 20</td><td style="text-align: left;">2</td></tr><tr class="even"><td style="text-align: left;">20-79</td><td style="text-align: left;">4</td></tr><tr class="odd"><td style="text-align: left;">80 and greater</td><td style="text-align: left;">8</td></tr></tbody></table><p>当该集合的任何两个分片上的块数之差小于2或块迁移失败时，平衡器将停止在目标集合上运行。</p><h2 id="修改-chunk-size-的注意事项">修改 Chunk Size 的注意事项</h2><p>修改 chunk 大小需要注意以下几点：</p><ol type="1"><li>chunk 的自动拆分操作仅发生在插入或更新的时候。</li><li>如果减少 chunk size，将会耗费一些时间将原有的 chunk 拆分到新 chunk，并且此操作不可逆。</li><li>如果新增 chunk size，已存在的 chunk 只会等到新的插入或更新操作将其扩充至新的大小。</li><li>chunk size 的可调整范围为 1-1024MB。</li></ol><h1 id="balancer-均衡器">Balancer 均衡器</h1><p>MongoDB 的 balancer（均衡器）是监视每个分片的 chunk 数的一个后台进程。当分片上的 chunk 数达到特定迁移阈值时，均衡器会尝试在分片之间自动迁移块，使得每个分片的块的数量达到平衡。分片群集的平衡过程对用户和应用程序层完全透明，但在执行过程时可能会对性能产生一些影响。</p><p>从 MongoDB 3.4 开始，balancer 在配置服务器副本集（CSRS）的主服务器上运行，在 3.4 版本中，当平衡器进程处于活动状态时，主配置服务器的的 locks 集合通过修改 <code>_id: "balancer"</code> 文档会获取一个 balancer lock，该 balancer lock 不会被释放，是为了保证只有一个 mongos 实例能够在分片集群中执行管理任务。从 3.6 版本开始，均衡器不再需要 balancer lock。</p><p>均衡器可以动态的开启和关闭，也可以针对指定的集合开启和关闭，还可以手动控制均衡器迁移 chunk 的时间，避免在业务高峰期的时候迁移 chunk 从而影响集群性能。以下命令将均衡器的迁移 chunk 时间控制在凌晨 02 点至凌晨 06 点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use config</span><br><span class="line">db.settings.update(</span><br><span class="line">   &#123; _id: &quot;balancer&quot; &#125;,</span><br><span class="line">   &#123; $set: &#123; activeWindow : &#123; start : &quot;02:00&quot;, stop : &quot;06:00&quot; &#125; &#125; &#125;,</span><br><span class="line">   &#123; upsert: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="环境准备">环境准备</h1><ul><li><p>系统系统：CentOS7 64位</p></li><li><p>三台服务器：192.168.0.11/12/13</p></li><li><p>安装包：mongodb-linux-x86_64-4.2.5.tgz</p></li><li><p>服务器规划</p><table><thead><tr class="header"><th><strong>服务器11</strong></th><th><strong>服务器12</strong></th><th><strong>服务器13</strong></th></tr></thead><tbody><tr class="odd"><td>mongos</td><td>mongos</td><td>mongos</td></tr><tr class="even"><td>config server</td><td>config server</td><td>config server</td></tr><tr class="odd"><td>shard server1 主节点</td><td>shard server1 副节点</td><td>shard server1 仲裁</td></tr><tr class="even"><td>shard server2 仲裁</td><td>shard server2 主节点</td><td>shard server2 副节点</td></tr><tr class="odd"><td>shard server3 副节点</td><td>shard server3 仲裁</td><td>shard server3 主节点</td></tr></tbody></table></li><li><p>端口分配</p><ul><li>mongos：20000</li><li>config：21000</li><li>shard1：27001</li><li>shard2：27002</li><li>shard3：27003</li></ul></li></ul><h1 id="分片集群搭建">分片集群搭建</h1><h2 id="安装-mongodb">安装 mongodb</h2><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat-tarball/">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat-tarball/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf mongodb-linux-x86_64-4.2.5.tgz -C /usr/local/</span><br><span class="line">mv mongodb-linux-x86_64-4.2.5 mongodb</span><br></pre></td></tr></table></figure><h3 id="创建数据和日志目录">创建数据和日志目录</h3><p>分别在每台机器建立 conf、mongos、config、shard1、shard2、shard3 六个目录，因为 mongos 不存储数据，只需要建立日志文件目录即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/mongodb/conf /usr/local/mongodb/mongos/log /usr/local/mongodb/config/data /usr/local/mongodb/config/log /usr/local/mongodb/shard1/data /usr/local/mongodb/shard1/log /usr/local/mongodb/shard2/data /usr/local/mongodb/shard2/log /usr/local/mongodb/shard3/data /usr/local/mongodb/shard3/log</span><br></pre></td></tr></table></figure><h3 id="配置环境变量">配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$MONGODB_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>使修改立即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="config-server-配置服务器">config server 配置服务器</h2><p>mongodb3.4 以后要求配置服务器也创建副本集，不然集群搭建不成功。</p><p>添加配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/config.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/config/log/configsrv.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/config/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/config/log/configsrv.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">21000</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 声明这是集群的配置服务器</span></span><br><span class="line"><span class="attr">configsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=configs</span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>启动三台服务器的 config server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/config.conf</span><br></pre></td></tr></table></figure><p>登录任意一台配置服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 21000</span><br></pre></td></tr></table></figure><p>定义 config server 副本集配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;configs&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:21000&quot; &#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:21000&quot; &#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:21000&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 config server 副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>其中，<code>_id : "configs"</code> 应与配置文件中配置的 <code>replicaction.replSetName</code> 一致，"members" 中的 "host" 为三个节点的 ip 和 port</p><h2 id="配置分片副本集三台机器">配置分片副本集（三台机器）</h2><h3 id="设置第一个分片副本集">设置第一个分片副本集</h3><p>添加配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard1.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard1/log/shard1.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard1/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard1/log/shard1.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27001</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard1</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>启动三台服务器的 shard1 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard1.conf</span><br></pre></td></tr></table></figure><p>登录任意一台非 arbiter 的 shard1 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27001</span><br></pre></td></tr></table></figure><p>使用 admin 数据库，定义 shard1 server 副本集配置：</p><p>第三个节点的 <code>arbiterOnly: true</code> 代表其为仲裁节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard1&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27001&quot;&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27001&quot;&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27001&quot;, arbiterOnly: true&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 shard1 server 副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><h3 id="设置第二个分片副本集">设置第二个分片副本集</h3><p>添加配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard2.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard2/log/shard2.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard2/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard2/log/shard2.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27002</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard2</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>启动三台服务器的 shard2 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard2.conf</span><br></pre></td></tr></table></figure><p>登录任意一台非 arbiter 的 shard2 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27002</span><br></pre></td></tr></table></figure><p>使用 admin 数据库，定义 shard2 server 副本集配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard2&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27002&quot;, arbiterOnly: true&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27002&quot;&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27002&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 shard2 server 副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><h3 id="设置第三个分片副本集">设置第三个分片副本集</h3><p>添加配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/shard3.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/shard3/log/shard3.pid</span><br><span class="line"><span class="attr">dbpath</span>=/usr/local/mongodb/shard3/data</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/shard3/log/shard3.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27003</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 副本集名称</span></span><br><span class="line"><span class="attr">replSet</span>=shard3</span><br><span class="line"><span class="comment"># 声明这是集群的一个分片服务器</span></span><br><span class="line"><span class="attr">shardsvr</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>启动三台服务器的 shard3 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/shard3.conf</span><br></pre></td></tr></table></figure><p>登录任意一台非 arbiter 的 shard3 server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27003</span><br></pre></td></tr></table></figure><p>使用 admin 数据库，定义 shard3 server 副本集配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">config = &#123;</span><br><span class="line">    _id : &quot;shard3&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : 0, host : &quot;192.168.0.11:27003&quot;&#125;,</span><br><span class="line">        &#123;_id : 1, host : &quot;192.168.0.12:27003&quot;, arbiterOnly: true&#125;,</span><br><span class="line">        &#123;_id : 2, host : &quot;192.168.0.13:27003&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 shard3 server 副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><h2 id="配置路由服务器-mongos">配置路由服务器 mongos</h2><p>先启动配置服务器和分片服务器，后启动路由实例：（三台机器）</p><p>添加配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pidfilepath</span>=/usr/local/mongodb/mongos/log/mongos.pid</span><br><span class="line"><span class="attr">logpath</span>=/usr/local/mongodb/mongos/log/mongos.log</span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bind_ip</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">20000</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 监听的配置服务器, 只能有1个或者3个, configs为配置服务器的副本集名字</span></span><br><span class="line"><span class="attr">configdb</span>=configs/<span class="number">192.168</span>.<span class="number">0.11</span>:<span class="number">21000</span>,<span class="number">192.168</span>.<span class="number">0.12</span>:<span class="number">21000</span>,<span class="number">192.168</span>.<span class="number">0.13</span>:<span class="number">21000</span></span><br><span class="line"><span class="comment"># 设置最大连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>启动三台服务器的 mongos server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos -f /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure><h2 id="启用分片">启用分片</h2><p>目前搭建了 mongodb 配置服务器、路由服务器，各个分片服务器，不过应用程序连接到 mongos 路由服务器并不能使用分片机制，还需要在程序里设置分片配置，让分片生效。</p><p>登陆任意一台 mongos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure><p>使用 admin 数据库，串联路由服务器与分片副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">sh.addShard(&quot;shard1/192.168.0.11:27001,192.168.0.12:27001,192.168.0.13:27001&quot;)</span><br><span class="line">sh.addShard(&quot;shard2/192.168.0.11:27002,192.168.0.12:27002,192.168.0.13:27002&quot;)</span><br><span class="line">sh.addShard(&quot;shard3/192.168.0.11:27003,192.168.0.12:27003,192.168.0.13:27003&quot;)</span><br></pre></td></tr></table></figure><p>查看集群状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure><h2 id="测试分片">测试分片</h2><h3 id="基于-hashed-的分片">基于 Hashed 的分片</h3><p>目前配置服务、路由服务、分片服务、副本集服务都已经串联起来了，现在我们希望插入数据时，数据能够自动分片。</p><p>首先连接到 mongos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure><p>切换到 admin 数据库，让指定的数据库、指定的集合分片生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 <span class="built_in">test</span> 库的分片功能</span></span><br><span class="line">db.runCommand(&#123;enablesharding: &quot;test&quot;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择集合的分片键，注意这里创建的是 <span class="built_in">hash</span> 索引</span></span><br><span class="line">db.runCommand(&#123;shardcollection: &quot;test.hashed&quot;, key: &#123;_id: &quot;hashed&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里设置 test 数据库的 <code>hashed</code> 表需要分片，根据 <code>_id</code> 自动分片到 shard1，shard2，shard3 上面去，之所以这样设置是因为不是所有 mongodb 的数据库和表都需要分片！</p><p>查看此时的分片的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">sh.status()</span></span><br><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">        &quot;currentVersion&quot; : 6,</span><br><span class="line">        &quot;clusterId&quot; : ObjectId(&quot;5e82a238caf5457afd11f184&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/192.168.0.11:27001,192.168.0.12:27001&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/192.168.0.12:27002,192.168.0.13:27002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard3&quot;,  &quot;host&quot; : &quot;shard3/192.168.0.11:27003,192.168.0.13:27003&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        &quot;4.2.5&quot; : 1</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  no</span><br><span class="line">        Failed balancer rounds in last 5 attempts:  0</span><br><span class="line">        Migration Results for the last 24 hours:</span><br><span class="line">                6 : Success</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard1&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : &#123;  &quot;uuid&quot; : UUID(&quot;3ed17366-fef3-4225-bdc4-f89f8bf751cf&quot;),  &quot;lastMod&quot; : 1 &#125; &#125;</span><br><span class="line">                test.hashed</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : &quot;hashed&quot; &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  2</span><br><span class="line">                                shard2  2</span><br><span class="line">                                shard3  2</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;-6148914691236517204&quot;) &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;-6148914691236517204&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;-3074457345618258602&quot;) &#125; on : shard1 Timestamp(1, 1)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;-3074457345618258602&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(0) &#125; on : shard2 Timestamp(1, 2)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(0) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;3074457345618258602&quot;) &#125; on : shard2 Timestamp(1, 3)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;3074457345618258602&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : NumberLong(&quot;6148914691236517204&quot;) &#125; on : shard3 Timestamp(1, 4)</span><br><span class="line">                        &#123; &quot;_id&quot; : NumberLong(&quot;6148914691236517204&quot;) &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard3 Timestamp(1, 5)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure><p>切换到 test 数据库，测试分片配置结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入测试数据</span></span><br><span class="line">for (var i = 1; i &lt;= 100000; i++) db.hashed.save(&#123;&quot;task&quot;: i, &quot;createTime&quot;: new Date()&#125;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分片情况</span></span><br><span class="line">db.hashed.stats();</span><br></pre></td></tr></table></figure><p>查看分片情况，省掉了部分无关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">use <span class="built_in">test</span></span></span><br><span class="line">switched to db test</span><br><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash"><span class="keyword">for</span> (var i = 1; i &lt;= 100000; i++) db.hashed.save(&#123;<span class="string">&quot;task&quot;</span>: i, <span class="string">&quot;createTime&quot;</span>: new Date()&#125;);</span></span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">db.hashed.stats()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;sharded&quot; : true,</span><br><span class="line">        &quot;capped&quot; : false,</span><br><span class="line">        ...</span><br><span class="line">        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">        &quot;count&quot; : 100000,</span><br><span class="line">        &quot;size&quot; : 5600000,</span><br><span class="line">        &quot;storageSize&quot; : 2539520,</span><br><span class="line">        &quot;totalIndexSize&quot; : 4485120,</span><br><span class="line">        &quot;indexSizes&quot; : &#123;</span><br><span class="line">                &quot;_id_&quot; : 1036288,</span><br><span class="line">                &quot;_id_hashed&quot; : 3448832</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;avgObjSize&quot; : 56,</span><br><span class="line">        &quot;maxSize&quot; : NumberLong(0),</span><br><span class="line">        &quot;nindexes&quot; : 2,</span><br><span class="line">        &quot;nchunks&quot; : 6,</span><br><span class="line">        &quot;shards&quot; : &#123;</span><br><span class="line">                &quot;shard3&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1872584,</span><br><span class="line">                        &quot;count&quot; : 33439,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 675840,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;shard2&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1874656,</span><br><span class="line">                        &quot;count&quot; : 33476,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 663552,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;shard1&quot; : &#123;</span><br><span class="line">                        &quot;ns&quot; : &quot;test.hashed&quot;,</span><br><span class="line">                        &quot;size&quot; : 1852760,</span><br><span class="line">                        &quot;count&quot; : 33085,</span><br><span class="line">                        &quot;avgObjSize&quot; : 56,</span><br><span class="line">                        &quot;storageSize&quot; : 1200128,</span><br><span class="line">                        &quot;capped&quot; : false,</span><br><span class="line">                        ...</span><br><span class="line">                        &quot;ok&quot; : 1,</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ok&quot; : 1,</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到数据分到3个分片，各自分片数量为：</p><ul><li>shard1 <code>"count": 33085</code></li><li>shard2 <code>"count": 33476</code></li><li>shard3 <code>"count": 33439</code></li></ul><p>33085 + 33476 + 33085 = 100000</p><h3 id="基于-ranged-的分片">基于 Ranged 的分片</h3><p>基于范围分片特别适合范围查找，因为可以直接定位到分片，所以效率很高。</p><p>为了方便看到基于 Ranged 分片的效果，我们先修改分片集群的 Chunk Size。</p><blockquote><p>分片群集的默认块大小为 64 MB。 此默认块大小适用于大多数部署。但是，如果您发现自动迁移的 I/O超出了硬件的处理能力，则可能需要减小块大小。对于自动拆分和迁移，小的块大小会导致更快和更频繁的迁移。块大小的允许范围在 1 到 1024 MB（含）之间。</p></blockquote><p>连接到 mongos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 20000</span><br></pre></td></tr></table></figure><p>切换到 config 数据库，使用 save() 来设置全局块大小的配置值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use config</span><br><span class="line">db.settings.save(&#123;_id: &quot;chunksize&quot;, value: 2&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 chunk size 配置值</span></span><br><span class="line">db.settings.find(&#123;_id: &quot;chunksize&quot;&#125;)</span><br></pre></td></tr></table></figure><p>切换到 admin 数据库，让指定的数据库、指定的集合分片生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 <span class="built_in">test</span> 库的分片功能</span></span><br><span class="line">db.runCommand(&#123;enablesharding: &quot;test&quot;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择集合的分片键，此时 MongoDB 会自动为 age 字段创建索引</span></span><br><span class="line">db.runCommand(&#123;shardcollection: &quot;test.ranged&quot;, key: &#123;&quot;age&quot;: 1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里设置 test 数据库的 <code>ranged</code> 表需要分片，根据 <code>age</code> 自动分片到 shard1，shard2，shard3，查看此时的分片的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mongos&gt; </span><span class="language-bash">sh.status()</span></span><br><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">        &quot;currentVersion&quot; : 6,</span><br><span class="line">        &quot;clusterId&quot; : ObjectId(&quot;5e82fe6c6f3857f3fd9253ed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/10.251.1.231:27001,10.251.1.232:27001&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/10.251.1.232:27002,10.251.1.233:27002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard3&quot;,  &quot;host&quot; : &quot;shard3/10.251.1.231:27003,10.251.1.233:27003&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        &quot;4.2.5&quot; : 1</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  no</span><br><span class="line">        Failed balancer rounds in last 5 attempts:  0</span><br><span class="line">        Migration Results for the last 24 hours:</span><br><span class="line">                No recent migrations</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;_id&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;_id&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard1&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : &#123;  &quot;uuid&quot; : UUID(&quot;73c9a05f-b578-41ea-92c0-42d11821004c&quot;),  &quot;lastMod&quot; : 1 &#125; &#125;</span><br><span class="line">                test.ranged</span><br><span class="line">                        shard key: &#123; &quot;age&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1  1</span><br><span class="line">                        &#123; &quot;age&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;age&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard1 Timestamp(1, 0)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mongos&gt;</span></span><br></pre></td></tr></table></figure><p>切换到 test 数据库，测试分片配置结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入测试数据</span></span><br><span class="line">for (var i = 1; i &lt;= 100000; i++) db.ranged.save(&#123;&quot;age&quot;: NumberInt(i % 100), &quot;createTime&quot;: new Date()&#125;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分片情况</span></span><br><span class="line">db.ranged.stats()</span><br></pre></td></tr></table></figure><h1 id="后期运维">后期运维</h1><h2 id="启动关闭">启动关闭</h2><p>mongodb 的启动顺序是，先启动配置服务器，再启动分片，最后启动 mongos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/conf/config.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard1.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard2.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/shard3.conf</span><br><span class="line">mongod -f /usr/local/mongodb/conf/mongos.conf</span><br></pre></td></tr></table></figure><p>关闭时，直接 killall 杀掉所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall mongod</span><br><span class="line">killall mongos</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><ol type="1"><li>Mongodb 分片需要比较大的内存，搭建时分配比较大的内存空间，线上环境是 48G</li><li>每个 mongodb 实例，需要限制 wiredTigerCacheSizeGB 大小，即在每个配置文件中增加这个配置。根据经验，如果每台机器上的实例个数 n，<code>n * wiredTigerCacheSizeGB &lt; 2/3</code> 总内存</li><li>Mongodb 分片后，每次 update 数据时，必须指定片键，没有片键无法 update</li></ol><h1 id="附录">附录</h1><h2 id="清除数据和日志目录">清除数据和日志目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm -rf config/data/*</span><br><span class="line">rm -rf config/log/*</span><br><span class="line">rm -rf mongos/log/*</span><br><span class="line">rm -rf shard1/data/*</span><br><span class="line">rm -rf shard1/log/*</span><br><span class="line">rm -rf shard2/data/*</span><br><span class="line">rm -rf shard2/log/*</span><br><span class="line">rm -rf shard3/data/*</span><br><span class="line">rm -rf shard3/log/*</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://docs.mongodb.com/manual/sharding/">https://docs.mongodb.com/manual/sharding/</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/index.html">https://www.ibm.com/developerworks/cn/opensource/os-mongodb-sharded-cluster/index.html</a></p><p><a href="http://www.ityouknow.com/mongodb/2017/08/05/mongodb-cluster-setup.html">http://www.ityouknow.com/mongodb/2017/08/05/mongodb-cluster-setup.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在如今的互联网环境下，海量数据已随处可见并且还在不断增长，对于如何存储处理海量数据，比较常见的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;垂直扩展&lt;/strong&gt;：通过增加单台服务器的配置，例如使用更强悍的 CPU、更大的内存、更大容量的磁盘，此种方法虽然成本很高，但是实现比较简单，维护起来也比较方便。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;水平扩展&lt;/strong&gt;：通过使用更多配置一般的服务器来共同承担工作负载，此种方法很灵活，可以根据工作负载的大小动态增减服务器的数量，但是实现比较复杂，得有专门的人员来运维。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MongoDB 支持通过分片技术从而进行水平扩展，用以支撑海量数据集和高吞吐量的操作。如果数据集不够大，还是建议您使用 &lt;a href=&quot;https://docs.mongodb.com/manual/replication/&quot;&gt;MongoDB 副本集&lt;/a&gt;，因为分片需要处理更多的技术细节，所以在分片环境下其性能可能始终没有副本集性能强。本文通过介绍如何搭建 MongoDB 分片集群以及及一些相关核心概念，可以帮您快速理解 MongoDB 是如何通过分片技术来处理海量数据的。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://wylu.me/categories/web/"/>
    
    <category term="mongo" scheme="https://wylu.me/categories/web/mongo/"/>
    
    
    <category term="mongodb" scheme="https://wylu.me/tags/mongodb/"/>
    
    <category term="sharding-cluster" scheme="https://wylu.me/tags/sharding-cluster/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB副本集搭建</title>
    <link href="https://wylu.me/posts/fd4a1d37/"/>
    <id>https://wylu.me/posts/fd4a1d37/</id>
    <published>2020-04-04T06:46:47.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>对于互联网应用来说，我们要尽量保证服务的不可间断性，一旦出现故障需要尽快的恢复。MongoDB 的副本集模式主要解决了在其主从模式下故障无法自动转移的情况，自动实现高可用。三个成员副本集提供足够的冗余性，以承受大多数网络分区和其他系统故障，这些集合对于许多分布式读取操作也具有足够的容量。本文介绍如何从三个现有 mongod 实例创建三成员副本集，包括不启用访问控制的和启用访问控制的。</p><span id="more"></span><h1 id="mongodb副本集搭建">MongoDB副本集搭建</h1><p>MongoDB Replica Set</p><h1 id="三成员副本集部署模式">三成员副本集部署模式</h1><h2 id="p-s-s">P-S-S</h2><p>Primary with Two Secondary Members 是具有三个存储数据的成员的副本集部署模式，它包含：</p><ul><li>一个主节点 primary</li><li>两个副节点 secondary （每个副节点都可以被选举为主节点）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/71ff1feced2a2fa4d924c9ed148c4437.svg" alt="P-S-S" /></p><p>除 primary 成员外，P-S-S 部署始终提供数据集的两个完整副本。这些副本集提供了额外的容错能力和高可用性。 如果主服务器不可用，则副本集将 secondary 成员选为 primary 并继续正常操作。原本的 primary 在可用时会重新加入副本集。</p><p><img src="https://cdn.jsdelivr.net/gh/wylu/img/a65dbacf011bf17efb8c12d1f8658b2f.svg" alt="elect" /></p><h1 id="环境准备">环境准备</h1><ul><li>系统系统：CentOS7 64位</li></ul><table><thead><tr class="header"><th>Replica Set Member</th><th>Hostname</th></tr></thead><tbody><tr class="odd"><td>rs0-0</td><td>127.0.0.1:27017</td></tr><tr class="even"><td>rs0-1</td><td>127.0.0.1:27018</td></tr><tr class="odd"><td>rs0-2</td><td>127.0.0.1:27019</td></tr></tbody></table><h1 id="部署说明">部署说明</h1><p>下面将一个示例说明在单机部署一个 P-S-S 集群的流程。</p><h2 id="前提">前提</h2><p>对于测试和开发环境，您可以在本地系统或虚拟实例中运行 mongod 实例。</p><p>在部署副本集之前，必须在将成为副本集一部分的每个系统上安装 MongoDB。</p><p>每个成员都必须能够连接到其他每个成员。</p><h2 id="副本集名称">副本集名称</h2><p>此过程中的示例创建一个名为 rs0 的新副本集。</p><p>如果您的应用程序连接到多个副本集，则每个副本集应具有不同的名称。某些驱动程序通过副本集名称对副本集连接进行分组。</p><h2 id="基于命令行参数的部署">基于命令行参数的部署</h2><ol type="1"><li><p>通过执行类似于下列示例的命令，为每个成员创建必要的数据目录，它们将存储 mongod 实例的数据库文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/rs0-0/data /srv/mongodb/rs0-1/data /srv/mongodb/rs0-2/data</span><br></pre></td></tr></table></figure></li><li><p>通过下列命令，在终端窗口中启动 mongod 实例：</p><p>启动第一个成员</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure><p>启动第二个成员</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27018 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-1/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure><p>启动第三个成员</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27019 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-2/data --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure><p>通过上面的启动，将使每个实例作为名为 rs0 的副本集的成员，每个副本集都在不同的端口上运行，并使用 <code>--dbpath</code> 设置指定数据目录的路径。如果您已经在使用建议的端口，请选择其他端口。</p><p>这些实例同时绑定到主机的 localhost 和 ip 地址。</p><p><code>--oplogSize</code> 设置减少了每个 mongod 实例使用的磁盘空间。这是测试和开发部署的理想选择，因为它可以防止计算机过载。有关此配置选项和其他配置选项的更多信息，请参阅 <a href="https://docs.mongodb.com/manual/reference/configuration-options/">配置文件选项</a>。</p></li><li><p>通过 mongo shell 连接到您的 mongod 实例之一。您需要通过指定其端口号来指示哪个实例。为了简单明了，直接连接第一个，如以下命令所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure></li><li><p>在 mongo shell 中，使用 <code>rs.initiate()</code> 初始化副本集。您可以在 mongo shell 环境中创建副本集配置对象，如以下示例所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rsconf = &#123;</span><br><span class="line">  _id: &quot;rs0&quot;,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 0,</span><br><span class="line">     host: &quot;127.0.0.1:27017&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 1,</span><br><span class="line">     host: &quot;127.0.0.1:27018&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     _id: 2,</span><br><span class="line">     host: &quot;127.0.0.1:27019&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实际情况替换为系统的主机名和端口，然后将 rsconf 文件传递给 <code>rs.initiate()</code>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate( rsconf )</span><br></pre></td></tr></table></figure></li><li><p>通过以下命令来显示当前 <a href="https://docs.mongodb.com/manual/reference/replica-configuration/">副本配置</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.conf()</span><br></pre></td></tr></table></figure><p>副本集配置对象类似于以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;rs0&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;protocolVersion&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">1</span>)<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;members&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27018&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&lt;hostname&gt;:27019&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;arbiterOnly&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;buildIndexes&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;hidden&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;priority&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;tags&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;slaveDelay&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>)<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;votes&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;chainingAllowed&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;heartbeatIntervalMillis&quot;</span> <span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;heartbeatTimeoutSecs&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;electionTimeoutMillis&quot;</span> <span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;catchUpTimeoutMillis&quot;</span> <span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;getLastErrorModes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;getLastErrorDefaults&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;w&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;wtimeout&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;replicaSetId&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;598f630adc9053c6ee6d5f38&quot;</span>)</span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>随时使用 <code>rs.status()</code> 检查副本集的状态。</p><p>从运行该方法的成员的角度返回副本集状态。此方法为 <a href="https://docs.mongodb.com/manual/reference/command/replSetGetStatus/#dbcmd.replSetGetStatus">replSetGetStatus</a> 命令提供了包装。</p><p>此输出使用从副本集其他成员发送的心跳数据包派生的数据反映副本集的当前状态。</p></li></ol><h2 id="基于配置文件的部署">基于配置文件的部署</h2><p><a href="https://docs.mongodb.com/manual/reference/configuration-options/">https://docs.mongodb.com/manual/reference/configuration-options/</a></p><ol type="1"><li><p>创建日志文件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/rs0-0/log /srv/mongodb/rs0-1/log /srv/mongodb/rs0-2/log</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /srv/mongodb/conf</span><br></pre></td></tr></table></figure></li><li><p>创建每个成员的配置文件</p><p>第一个成员的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-0.conf</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-0/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-0/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-0/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure><p>第二个成员的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-1.conf</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-1/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-1/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-1/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27018</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure><p>第三个成员的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /srv/mongodb/conf/rs0-2.conf</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">   <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/srv/mongodb/rs0-2/log/mongod.log</span></span><br><span class="line">   <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">   <span class="attr">dbPath:</span> <span class="string">/srv/mongodb/rs0-2/data</span></span><br><span class="line">   <span class="attr">journal:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">   <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">pidFilePath:</span> <span class="string">/srv/mongodb/rs0-2/mongod.pid</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">   <span class="attr">replSetName:</span> <span class="string">rs0</span></span><br><span class="line">   <span class="attr">oplogSizeMB:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">   <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">27019</span></span><br><span class="line"><span class="comment"># security:</span></span><br><span class="line"><span class="comment">#     keyFile: /srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="comment">#     authorization: disabled</span></span><br></pre></td></tr></table></figure></li><li><p>启动副本集成员</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /srv/mongodb/conf/rs0-0.conf</span><br><span class="line">mongod -f /srv/mongodb/conf/rs0-1.conf</span><br><span class="line">mongod -f /srv/mongodb/conf/rs0-2.conf</span><br></pre></td></tr></table></figure></li><li><p>查看 mongod 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep mongod</span><br></pre></td></tr></table></figure><p>剩余初始副本集的步骤与上面命令行方式部署的操作相同。</p></li></ol><h1 id="启用身份验证">启用身份验证</h1><p>默认情况下，MongoDB 不会进行身份验证，也没有账号，只要能连接上服务就可以对数据库进行各种操作，出于安全角度考虑，我们应当为其添加认证访问。</p><p>通过 <code>--auth</code> 选项可以开启身份认证，此外，副本集设置身份验证与单机不同，需要增加一个 <code>keyFile</code> 以便副本集成员相互认证。</p><h2 id="创建一个用户">创建一个用户</h2><p>首先创建一个用于身份验证的用户，首先使用 mongo shell 连接到集群的 primary 节点，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017</span><br></pre></td></tr></table></figure><p>切换到 admin 数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure><p>在 admin 下创建用户 root：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">  user: &quot;root&quot;,</span><br><span class="line">  pwd: &quot;toor&quot;,</span><br><span class="line">  roles: [</span><br><span class="line">    &#123;role: &quot;userAdminAnyDatabase&quot;, db:&quot;admin&quot;&#125;,</span><br><span class="line">    &#123;role: &quot;readWriteAnyDatabase&quot;, db: &quot;admin&quot;&#125;,</span><br><span class="line">    &#123;role:&quot;clusterAdmin&quot;, db:&quot;admin&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="创建-keyfile">创建 KeyFile</h2><p>这个文件需要满足下面几点要求：</p><ul><li>文本长度需要在 6 和 1024 之间</li><li>认证时候不考虑文件中空白字符</li><li>连接到副本集的成员和 mongos 进程的 keyfile 文件内容必须一样</li><li>必须是 base64 编码，但是不能有等号</li><li>文件权限必须是 X00，也就是说，不能分配任何权限给 group 成员和 other 成员</li></ul><p>我们可以在 Linux 上直接使用 openssl 创建一个这样的文件，然后上传至其他副本集成员服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -base64 512 &gt; mongodb.key</span><br><span class="line">chmod 400 mongodb.key</span><br></pre></td></tr></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>如果你是通过配置文件形式部署的副本集，那么需要修改对应成员的配置：</p><p>（假设 Key File 文件在 <code>/srv/mongodb</code> 目录下）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">keyFile:</span> <span class="string">/srv/mongodb/mongodb.key</span></span><br><span class="line"><span class="attr">authorization:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure><p>如果你是直接通过命令行参数形式启动的副本集，那么需要使用 <code>--auth</code> 选项并指定 <code>--keyFile</code>，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0 --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure><h2 id="测试密码认证">测试密码认证</h2><p>关闭三个 mongod 服务实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall mongod</span><br></pre></td></tr></table></figure><p>添加 <code>--auth</code> 和 <code>--keyFile</code> 选项重新启动 mongod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第一个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27017 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-0  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第二个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27018 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-1  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第三个成员</span></span><br><span class="line">nohup mongod --replSet rs0 --port 27019 --bind_ip 0.0.0.0 --dbpath /srv/mongodb/rs0-2  --auth --keyFile=/srv/mongodb/mongodb.key --oplogSize 128 &amp;</span><br></pre></td></tr></table></figure><p>重启 mongodb ，第一次登陆时，直接查询会报权限错误，使用 <code>db.auth()</code> 认证后就可以成功读取数据库了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rs0:PRIMARY&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">rs0:PRIMARY&gt; db.auth(&#x27;root&#x27;, &#x27;toor&#x27;)</span><br><span class="line">1</span><br><span class="line">rs0:PRIMARY&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">test    0.000GB</span><br><span class="line">rs0:PRIMARY&gt;</span><br></pre></td></tr></table></figure><h1 id="问题">问题</h1><h2 id="初始化失败">初始化失败</h2><p>在初始化一个 MongoDB 副本集的过程中，出现了初始化失败，报 "No host described in new configuration 1 for replica set mongotest maps to this node"。具体报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rsconf = &#123;</span></span><br><span class="line">...   _id: &quot;rs0&quot;,</span><br><span class="line">...   members: [</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 0,</span><br><span class="line">...      host: &quot;0.0.0.0:27017&quot;</span><br><span class="line">...     &#125;,</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 1,</span><br><span class="line">...      host: &quot;0.0.0.0:27018&quot;</span><br><span class="line">...     &#125;,</span><br><span class="line">...     &#123;</span><br><span class="line">...      _id: 2,</span><br><span class="line">...      host: &quot;0.0.0.0:27019&quot;</span><br><span class="line">...     &#125;</span><br><span class="line">...    ]</span><br><span class="line">... &#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rs.initiate( rsconf )</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;operationTime&quot; : Timestamp(0, 0),</span><br><span class="line">        &quot;ok&quot; : 0,</span><br><span class="line">        &quot;errmsg&quot; : &quot;No host described in new configuration 1 for replica set rs0 maps to this node&quot;,</span><br><span class="line">        &quot;code&quot; : 93,</span><br><span class="line">        &quot;codeName&quot; : &quot;InvalidReplicaSetConfig&quot;,</span><br><span class="line">        &quot;$clusterTime&quot; : &#123;</span><br><span class="line">                &quot;clusterTime&quot; : Timestamp(0, 0),</span><br><span class="line">                &quot;signature&quot; : &#123;</span><br><span class="line">                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),</span><br><span class="line">                        &quot;keyId&quot; : NumberLong(0)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法，将 rsconf 中的 IP 替换为真正的 IP，如：127.0.0.1。</p><h2 id="开启认证后-secondary-读取失败">开启认证后 SECONDARY 读取失败</h2><p>"errmsg" : "not master and slaveOk=false" 的解决办法参考：</p><p><a href="https://stackoverflow.com/questions/8990158/mongodb-replicates-and-error-err-not-master-and-slaveok-false-code">https://stackoverflow.com/questions/8990158/mongodb-replicates-and-error-err-not-master-and-slaveok-false-code</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">rs0:SECONDARY&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">rs0:SECONDARY&gt; db.auth(&#x27;root&#x27;, &#x27;toor&#x27;)</span><br><span class="line">1</span><br><span class="line">rs0:SECONDARY&gt; show dbs</span><br><span class="line">2020-03-30T12:03:51.218+0800 E  QUERY    [js] uncaught exception: Error: listDatabases failed:&#123;</span><br><span class="line">        &quot;operationTime&quot; : Timestamp(1585541025, 1),</span><br><span class="line">        &quot;ok&quot; : 0,</span><br><span class="line">        &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">        &quot;code&quot; : 13435,</span><br><span class="line">        &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,</span><br><span class="line">        &quot;$clusterTime&quot; : &#123;</span><br><span class="line">                &quot;clusterTime&quot; : Timestamp(1585541025, 1),</span><br><span class="line">                &quot;signature&quot; : &#123;</span><br><span class="line">                        &quot;hash&quot; : BinData(0,&quot;DHLkVZz2fe4aeAjIxEmkHu9FhBE=&quot;),</span><br><span class="line">                        &quot;keyId&quot; : NumberLong(&quot;6809843876723949571&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; :</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">Mongo.prototype.getDBs/&lt;@src/mongo/shell/mongo.js:135:19</span><br><span class="line">Mongo.prototype.getDBs@src/mongo/shell/mongo.js:87:12</span><br><span class="line">shellHelper.show@src/mongo/shell/utils.js:906:13</span><br><span class="line">shellHelper@src/mongo/shell/utils.js:790:15</span><br><span class="line">@(shellhelp2):1:1</span><br><span class="line">rs0:SECONDARY&gt; rs.slaveOk()</span><br><span class="line">rs0:SECONDARY&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">rs0:SECONDARY&gt;</span><br></pre></td></tr></table></figure><h1 id="references">References</h1><p><a href="https://docs.mongodb.com/manual/reference/configuration-options/">https://docs.mongodb.com/manual/reference/configuration-options/</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb-replication/index.html">https://www.ibm.com/developerworks/cn/opensource/os-mongodb-replication/index.html</a></p><p><a href="https://docs.mongodb.com/manual/core/retryable-writes/#retryable-writes">https://docs.mongodb.com/manual/core/retryable-writes/#retryable-writes</a></p><p><a href="https://docs.mongodb.com/manual/reference/configuration-file-settings-command-line-options-mapping/#conf-file-command-line-mapping">Configuration File Settings and Command-Line Options Mapping</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于互联网应用来说，我们要尽量保证服务的不可间断性，一旦出现故障需要尽快的恢复。MongoDB 的副本集模式主要解决了在其主从模式下故障无法自动转移的情况，自动实现高可用。三个成员副本集提供足够的冗余性，以承受大多数网络分区和其他系统故障，这些集合对于许多分布式读取操作也具有足够的容量。本文介绍如何从三个现有 mongod 实例创建三成员副本集，包括不启用访问控制的和启用访问控制的。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://wylu.me/categories/web/"/>
    
    <category term="mongo" scheme="https://wylu.me/categories/web/mongo/"/>
    
    
    <category term="mongodb" scheme="https://wylu.me/tags/mongodb/"/>
    
    <category term="replica-set" scheme="https://wylu.me/tags/replica-set/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT主题博客接入谷歌广告</title>
    <link href="https://wylu.me/posts/9d582ac3/"/>
    <id>https://wylu.me/posts/9d582ac3/</id>
    <published>2020-03-29T02:15:47.000Z</published>
    <updated>2022-11-23T17:04:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>本文将向你展示 Hexo + NexT 主题博客如何接入 Google 广告联盟 Google Adsense</p><span id="more"></span><h1 id="前提">前提</h1><ul><li>使用 Hexo 和 NexT 主题搭建博客</li><li>可以登录 Google Adsense 网站（科学上网）</li></ul><h1 id="注册账号">注册账号</h1><p><a href="https://www.google.com/adsense/">Google Adsense</a></p><h1 id="向网站列表添加新网站">向网站列表添加新网站</h1><p>要在新网站上展示广告或设置网站级屏蔽规则，首先需要先将相应网站添加到您的网站列表中。</p><h2 id="添加新网站">添加新网站</h2><ol type="1"><li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li><li>点击 <strong>网站</strong>。</li><li>点击 <strong>添加网站</strong>。</li><li>输入您网站的网址。</li><li><p><strong>将您的网站关联到 AdSense</strong>。</p><p>将代码复制并粘贴到网页的 HTML 中，放置在 <code>&lt;head&gt;</code> 和 <code>&lt;/head&gt;</code> 标签之间。</p><p>使用 Hexo + NexT 搭建的博客站点，只要将 Google 提供的 AdSense 代码添加到 <code>/themes/next/layout/_partials/head/head.swig</code> 文件末尾即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-ad-client=<span class="string">&quot;ca-pub-5699403938610067&quot;</span> <span class="keyword">async</span> src=<span class="string">&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以下是添加了代码的 HTML 网页示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">&quot;ca-pub-5699403938610067&quot;</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">This is the head of your page.</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">This is the body of your page.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击 <strong>完成</strong>。 Google AdSense 会审核您的网站是否可以开始展示广告。</p></li></ol><h2 id="审核网站是否已可以开始展示广告">审核网站是否已可以开始展示广告</h2><p>添加新网站后，Google AdSense 会检查以确保您的网站已可以开始展示广告。它将验证您是否是网站所有者以及您的网站是否符合 AdSense 合作规范。通常，此过程几天之内就能完成，但在某些情况下最长可能需要 2 周时间。Google AdSense 会在审核完毕并确认您的网站可以开始展示广告后通知您。</p><h1 id="放置广告">放置广告</h1><p>根据站点的结构设计和选择广告的投放位置，目前 Google AdSense 主要提供了 <strong>按网站</strong> 和 <strong>按广告单元</strong>* 两种形式的广告添加方式。</p><h2 id="按网站自动广告">按网站（自动广告）</h2><p><a href="https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304&amp;visit_id=637240760139765363-4192744759&amp;rd=1">自动广告</a>是 Google AdSense 近来提供的一种广告形式，它自动会分析您的网页，然后根据您的布局、内容和现有 Google 广告找到新位置来展示广告。您只需放置一段广告代码即可开始使用。在您放置代码后，自动广告会根据您对网站和广告设置所做的任何更改自动进行调整。自动广告可自动调整以适应每种屏幕尺寸。</p><h3 id="前期准备">前期准备</h3><p>确保您的网站已列入广告页面。如未列入，您需要在设置自动广告之前，将相应网站添加到您的网站列表中。</p><h3 id="设置自动广告">设置自动广告</h3><ol type="1"><li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li><li>点击 <strong>广告</strong> 接着点击 <strong>概览</strong>。</li><li>在汇总了您所有网站的表格中，点击相应网站旁边的“修改”图标 修改。该网站就会在<a href="https://support.google.com/adsense/answer/9262310">广告设置预览模式</a>下打开。<ul><li>提示：在自动广告投放之前，您可以使用预览功能尝试不同的广告设置。</li></ul></li><li>在“网站设置”下，启用 <strong>自动广告</strong>。</li><li>（可选）如果您想让 Google 为您一起优化广告单元和自动广告，并在效果最佳的广告展示位置上投放广告，请启用 <strong>优化您现有的广告单元</strong> 选项。<ul><li>注意：此设置目前尚未启用。启用此设置意味着您愿意让 Google 在日后为您优化现有广告单元。</li></ul></li><li>（可选）点击 <strong>广告格式</strong> 可关闭页内广告和重叠式广告，或开启页面中的匹配内容。详细了解广告格式和匹配内容设置。</li><li>（可选）点击 <strong>广告投放量</strong>，然后使用滑块控制您在网页上展示的广告数量。了解如何为自动广告选择广告投放量。</li><li>（可选）在“排除的网页”部分中，点击 <strong>管理</strong> 可<a href="https://support.google.com/adsense/answer/9262311">阻止特定网页展示自动广告</a>。</li><li>点击 <strong>应用到网站</strong>。</li></ol><p><strong>注意</strong>：确保您已将 AdSense 代码放置到您网站的每个网页上。广告最多可能需要一个小时才会展示在网页上。</p><h2 id="按广告单元">按广告单元</h2><p><a href="https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242">广告单元</a>是指在同一段 AdSense 广告代码的作用下显示出来的一个或多个 Google 广告。您可以在 AdSense 帐号的广告页面上创建、自定义和管理广告单元。利用广告单元，您可以掌控广告的展示位置；利用原生广告单元，您可以更灵活地进行自定义设置。</p><h3 id="广告单元的类型">广告单元的类型</h3><p>AdSense 提供多种不同类型的广告单元。如果展示广告单元不符合您网站的要求，不妨试试其他更具特色的广告单元：</p><ul><li><a href="https://support.google.com/adsense/topic/9183360">展示广告单元</a><ul><li>这种格式的广告适用范围广，在任何空间都能投放。</li><li>默认情况下，展示广告属于自适应广告，也就是说它们会自动根据您的页面布局和用户的设备屏幕调整自身尺寸。</li><li>这种格式的广告可进行自定义，以显示固定尺寸的广告。</li><li>此外，这种格式的广告还与 AMP 网页兼容。</li></ul></li><li><a href="https://support.google.com/adsense/topic/9183582">信息流广告单元</a><ul><li>在信息流（例如，文章或产品列表）内投放的原生广告，看起来十分自然，可提供良好的用户体验。</li></ul></li><li><a href="https://support.google.com/adsense/topic/9183594">文章内嵌广告单元</a><ul><li>完美融入网页段落之间的原生广告，可增强用户的阅读体验。</li></ul></li><li><a href="https://support.google.com/adsense/topic/9185053">匹配内容单元</a><ul><li>一种内容推荐功能，可向网站访问者宣传您的内容，有望提升收入、网页浏览量并延长用户在网站上停留的时间。</li></ul></li></ul><h3 id="展示广告推荐">展示广告（推荐）</h3><p>使用范围广，在任何空间都能投放。</p><p>要新建可在您的帐号中管理的展示广告单元，请按以下步骤操作：</p><ol type="1"><li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li><li>点击 <strong>广告</strong> 接着点击 <strong>概览</strong>。</li><li>点击 <strong>“按广告单元”</strong>。</li><li>点击 <strong>展示广告</strong>。</li><li>为此广告单元命名。建议您使用具有唯一性的描述性名称，便于您今后轻松找到此广告单元。</li><li>在“广告尺寸”部分，选择您想要展示的广告的尺寸：<ul><li>建议您将 <strong>自适应</strong> 选项保持选中状态。自适应广告会自动根据您的页面布局和用户的设备屏幕调整自身尺寸。详细了解<a href="https://support.google.com/adsense/answer/9183362">展示广告单元的自适应行为</a>。</li><li>如果您更倾向于自行指定在您的网页上展示何种尺寸的广告，请选择 <strong>固定尺寸</strong>，然后输入所需的宽度和高度。请注意，固定尺寸的广告单元可投放的广告数量可能较少，因而所创造的收入也可能不如采用自适应尺寸的广告单元。有关详情，请参阅<a href="https://support.google.com/adsense/answer/9185043">固定尺寸的展示广告单元指南</a>。</li><li>提示：不妨参阅<a href="https://support.google.com/google-ads/answer/7031480">最常见的固定广告尺寸</a>示例。</li></ul></li><li>点击 <strong>保存并获取代码</strong>。</li><li>复制广告单元代码并将其粘贴在要展示广告的网页上，放在 <code>&lt;body&gt;&lt;body/&gt;</code> 标记之间。</li><li>点击完成。</li></ol><p>通常，广告只需几分钟便会展示在网页上，但有时也可能会需要长达一个小时。如果一小时后广告仍未展示，请前往 <strong>网站</strong> 页面<a href="https://support.google.com/adsense/answer/9128461">查看您的网站是否处于“准备就绪”状态</a>。</p><h3 id="信息流广告">信息流广告</h3><p>与您网站的外观浑然一体，可以自然地展示在推送的文章资讯以及连续显示的产品或服务介绍之间。</p><p>您可以通过两种方式创建信息流广告单元。最简便快捷的方法是让 Google 扫描您的网页，然后自动为您制作广告。另外，您也可以手动制作信息流广告。</p><p>注意：如果您的信息流是纯文本，请使用手动方法制作信息流广告。</p><ol type="1"><li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li><li>点击 <strong>广告</strong>。</li><li>点击 <strong>广告单元</strong>。</li><li>选择 <strong>信息流广告</strong>。</li><li>选择要如何制作信息流广告：<ul><li>让 Google 提供样式建议（推荐）</li><li>手动创建广告样式</li></ul></li><li>复制信息流广告代码并粘贴到您网站上信息流的 HTML 中。</li></ol><p>制作信息流广告详情参考 <a href="https://support.google.com/adsense/answer/9185051?hl=zh-Hans">https://support.google.com/adsense/answer/9185051?hl=zh-Hans</a></p><h3 id="文章内嵌广告">文章内嵌广告</h3><p>同样与您的网站浑然一体，与文章和内容页面完美融合。</p><p>要创建文章内嵌广告单元，请按以下步骤操作：</p><ol type="1"><li><a href="http://www.google.com/adsense">登录</a>您的 AdSense 帐号。</li><li>点击 <strong>广告</strong>。</li><li>点击 <strong>广告单元</strong>。</li><li>点击 <strong>文章内嵌广告</strong>。</li><li>为文章内嵌广告单元指定名称。<ul><li>建议您为文章内嵌广告单元的名称添加诸如“Native”（“原生”）之类的前缀，以帮助您跟踪其效果。</li></ul></li><li>设置您的广告样式，使其与您的内容相匹配。如需了解详情，请参阅<a href="https://support.google.com/adsense/answer/9189960">文章内嵌广告设置</a>。</li><li>通过在预览区域更改容器宽度，测试您的广告在不同尺寸屏幕上的外观。使用拖动手柄更改宽度。</li><li>点击 <strong>保存并获取代码</strong>。</li><li>复制文章内嵌广告代码并将其粘贴到您网站网页的 HTML 中。 建议在文章前两段下方放置代码。</li></ol><p><strong>重要提示：</strong>如果您想在网页上放置多个文章内嵌广告，请务必在广告之间放置足够的内容，尽可能避免对读者形成干扰。</p><p>文章内嵌自适应广告尺寸：</p><p>请注意，默认情况下文章内嵌广告属于自适应广告，也就是说它们可根据观看设备自动调整尺寸。在处于纵向模式的移动设备上，文章内嵌广告会展开以占据用户屏幕的整个宽度。在桌面设备和采用其他配置模式的移动设备上，文章内嵌广告的宽度始终等于其所在的父级容器（<code>&lt;div&gt;</code>、<code>&lt;iframe&gt;</code> 等）的宽度。（请注意，文章内嵌广告的最小宽度为 250 像素）。AdSense 会自动调整文章内嵌广告的高度。</p><h2 id="next-广告代码插入位置">NexT 广告代码插入位置</h2><p>由于是博客网站，所以第二种信息流广告没有投入使用，这里主要使用了第一种和第三种。这里，提供几种针对 Hexo NexT 主题广告代码插入位置的操作:</p><h3 id="创建-google-adsense.swig">创建 google-adsense.swig</h3><p>首先在 <code>themes/next/layout/_custom</code> 目录下，新建 google-adsense.swig 文件，并将对应广告单元的代码插入其中。</p><p>然后在需要展示广告的位置插入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="插入评论区">插入评论区</h3><p>将下列代码插入 <code>themes/next/layout/_partials/comments.swig</code> 文件末尾即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="插入侧边栏">插入侧边栏</h3><p>将下列代码插入 <code>themes/next/layout/_macro/sidebar.swig</code> 文件中 <code>&lt;div class=”sidebar-inner”&gt;&lt;/div&gt;</code> 的最下侧即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-inner&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  &#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插入文章中">插入文章中</h3><p>编辑 <code>themes/next/layout/_macro/post.swig</code> 文件，将下面的 include 语句添加到 post body 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;#################&#125;</span><br><span class="line">&#123;### POST BODY ###&#125;</span><br><span class="line">&#123;#################&#125;</span><br><span class="line">&lt;div class=&quot;post-body&#123;%- if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;%- endif %&#125;&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">  &#123;%- if is_index %&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">      &#123;&#123; post.content &#125;&#125;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; partial(&#x27;_custom/google-adsense.swig&#x27;) &#125;&#125;</span><br><span class="line">    &#123;&#123; post.content &#125;&#125;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项">注意事项</h1><p>在成功接入 AdSense 广告之后，并不算结束，Google 会根据几种方式和数据判断广告点击是否作弊，从而注销你的账号。</p><ul><li>作弊广告点击者的 IP 地址与你 Adsense 账户登录 IP 地址相同</li><li>作弊广告点击的 CTR 数据太高</li><li>作弊广告点击者的 IP 地址来自同一个地理区域</li><li>根据 Cookies 判断作弊 Adsense 广告点击</li><li>作弊广告点击者页面停留时间太短</li><li>直接访问者的广告点击率过高</li><li>流量小但广告点击率高</li><li>在网页上用文字提示请求鼓动点击广告</li></ul><h1 id="references">References</h1><p><a href="https://support.google.com/adsense/answer/9130038">https://support.google.com/adsense/answer/9130038</a></p><p><a href="https://support.google.com/adsense/answer/9261307?hl=zh-Hans&amp;ref_topic=9261304">https://support.google.com/adsense/answer/9261307?hl=zh-Hans&amp;ref_topic=9261304</a></p><p><a href="https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304">https://support.google.com/adsense/answer/9261306?hl=zh-Hans&amp;ref_topic=9261304</a></p><p><a href="https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242">https://support.google.com/adsense/answer/9183549?hl=zh-Hans&amp;ref_topic=9183242</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将向你展示 Hexo + NexT 主题博客如何接入 Google 广告联盟 Google Adsense&lt;/p&gt;</summary>
    
    
    
    <category term="tool" scheme="https://wylu.me/categories/tool/"/>
    
    <category term="hexo" scheme="https://wylu.me/categories/tool/hexo/"/>
    
    
    <category term="hexo" scheme="https://wylu.me/tags/hexo/"/>
    
    <category term="next" scheme="https://wylu.me/tags/next/"/>
    
  </entry>
  
</feed>
